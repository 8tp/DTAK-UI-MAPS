extern "C" {
#include "dittoffi.h"
}

#include "retainable.h"

#ifdef SWIG
%feature("director", assumeoverride=1) ConnectionRequestHandlerRust;
#endif

/** \brief
 *  Context object for Kotlin DittoConnectionRequestHandler which handles wiring up callbacks from
 *  Rust across the FFI boundary.
 */
class ConnectionRequestHandlerRust: public Retainable {
public:
  virtual ~ConnectionRequestHandlerRust() {}

  static void invokeEventHandler(
    Erased_t const *ctx,
    dittoffi_connection_request_t *connection_request
  ) {
    auto inst = (ConnectionRequestHandlerRust *)ctx;
    return inst->eventHandler(connection_request);
  }

  virtual void eventHandler(
    dittoffi_connection_request_t *connection_request
  ) = 0;

  virtual void registerConnectionRequestHandler(
    struct CDitto *ditto_raw,
    ConnectionRequestHandlerRust *handler
  ) {
    Erased_t* handler_pointer;
    if (handler != nullptr) {
      Retainable::invokeRetain(handler);
      handler_pointer = (Erased_t *)handler;
    } else {
      handler_pointer = NULL; // Pass null to clear the handler
    }

    FfiConnectionRequestHandlerVTable_t const v_table = {
      .release_vptr = (void (*)(Erased_t *)) ConnectionRequestHandlerRust::invokeRelease,
      .retain_vptr = ConnectionRequestHandlerRust::invokeVirtualPtrRetain,
      .on_connecting = ConnectionRequestHandlerRust::invokeEventHandler
    };

    VirtualPtr__Erased_ptr_FfiConnectionRequestHandlerVTable_t const ffi_handler = {
      .ptr = handler_pointer,
      .vtable = v_table
    };

    dittoffi_presence_set_connection_request_handler(ditto_raw, ffi_handler);
  }
};
