'use strict';

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/** @internal */
class KeepAlive {
    /** @internal */
    get isActive() {
        return this.intervalID !== null;
    }
    /** @internal */
    constructor() {
        this.countsByID = {};
        this.intervalID = null;
    }
    /** @internal */
    retain(id) {
        if (typeof this.countsByID[id] === 'undefined')
            this.countsByID[id] = 0;
        this.countsByID[id] += 1;
        if (this.intervalID === null) {
            // Keep the process alive as long as there is at least one ID being
            // tracked by setting a time interval with the maximum delay. This will
            // prevent the process from exiting.
            const maxDelay = 2147483647; // Signed 32 bit integer, see docs: https://developer.mozilla.org/en-US/docs/Web/API/setInterval
            this.intervalID = setInterval(() => {
                /* no-op */
            }, maxDelay);
            KeepAlive.finalizationRegistry.register(this, this.intervalID, this);
        }
    }
    /** @internal */
    release(id) {
        if (typeof this.countsByID[id] === 'undefined') {
            throw new Error(`Internal inconsistency, trying to release a keep-alive ID that hasn't been retained before or isn't tracked anymore: ${id}`);
        }
        this.countsByID[id] -= 1;
        if (this.countsByID[id] === 0)
            delete this.countsByID[id];
        if (Object.keys(this.countsByID).length === 0) {
            // Nothing is tracked anymore, it's safe to clear the interval
            // and let the process do what it wants.
            KeepAlive.finalizationRegistry.unregister(this);
            clearInterval(this.intervalID);
            this.intervalID = null;
        }
    }
    /** @internal */
    currentIDs() {
        return Object.keys(this.countsByID);
    }
    /** @internal */
    countForID(id) {
        var _a;
        return (_a = this.countsByID[id]) !== null && _a !== void 0 ? _a : null;
    }
}
KeepAlive.finalizationRegistry = new FinalizationRegistry(clearInterval);

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/**
 * Generic observer handle returned by various observation APIs. The observation
 * remains active until the {@link stop | stop()} method is called explicitly or
 * the observer instance is garbage collected. Therefore, to keep the observation
 * alive, you have to keep a reference to the corresponding observer.
 */
class Observer {
    /** @internal */
    get token() {
        return this._token;
    }
    /** @internal */
    constructor(observerManager, token, options = {}) {
        this.observerManager = observerManager;
        this._token = token;
        this.options = options;
        if (options.stopsWhenFinalized) {
            Observer.finalizationRegistry.register(this, { observerManager, token }, this);
        }
    }
    /**
     * Returns `true` if the observer has been explicitly stopped via the `stop()`
     * method. Otherwise returns `false`.
     */
    get isStopped() {
        return (this.token !== undefined && this.observerManager.hasObserver(this.token));
    }
    /**
     * Stops the observation. Calling this method multiple times has no effect.
     */
    stop() {
        const token = this.token;
        if (token) {
            delete this._token;
            Observer.finalizationRegistry.unregister(this);
            this.observerManager.removeObserver(token);
        }
    }
    static finalize(observerManagerAndToken) {
        const { observerManager, token } = observerManagerAndToken;
        observerManager.removeObserver(token);
    }
}
Observer.finalizationRegistry = new FinalizationRegistry(Observer.finalize);

const isReactNativeBuild = false;

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
// NOTE: we use a token to detect private invocation of the constructor. This is
// not secure and just to prevent accidental private invocation on the client
// side.
const privateToken$1 = Symbol('privateConstructorToken');
/**
 * Represents a CRDT counter that can be upserted as part of a document or
 * assigned to a property during an update of a document.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class Counter {
    /**
     * The value of the counter.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get value() {
        return this._value;
    }
    /**
     * Creates a new counter that can be used as part of a document's content.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    constructor() {
        this._value = 0.0;
    }
    /** @internal */
    static '@ditto.create'(mutDoc, path, value) {
        // @ts-expect-error - using hidden argument
        const counter = mutDoc ? new MutableCounter(privateToken$1) : new Counter();
        counter.mutDoc = mutDoc;
        counter.path = path;
        counter._value = value;
        return counter;
    }
}
// -----------------------------------------------------------------------------
/**
 * Represents a mutable CRDT counter that can be incremented by a specific
 * amount while updating a document.
 *
 * This class can't be instantiated directly, it's returned automatically for
 * any counter property within an update block via {@link MutableDocumentPath.counter}.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class MutableCounter extends Counter {
    /**
     * Increments the counter by `amount`, which can be any valid number.
     *
     * Only valid within the `update` closure of
     * {@link PendingCursorOperation.update | PendingCursorOperation.update()} and
     * {@link PendingIDSpecificOperation.update | PendingIDSpecificOperation.update()},
     * otherwise an exception is thrown.
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    increment(amount) {
        const mutDoc = this.mutDoc;
        const path = this.path;
        if (!mutDoc) {
            throw new Error(`Can't increment counter, only possible within the closure of a collection's update() method.`);
        }
        mutDoc.at(path)['@ditto.increment'](amount);
        // We also increment the local value to make sure that the change is
        // reflected locally as well as in the underlying document
        this._value += amount;
    }
    /** @internal */
    constructor() {
        if (arguments[0] === privateToken$1)
            super();
        else
            throw new Error(`MutableCounter constructor is for internal use only.`);
    }
}

//
// Copyright © 2022 DittoLive Incorporated. All rights reserved.
//
// NOTE: we use a token to detect private invocation of the constructor. This is
// not secure and just to prevent accidental private invocation on the client
// side.
const privateToken = '@ditto.ff82dae89821c5ab822a8b539056bce4';
/**
 * Represents a CRDT register that can be upserted as part of a document or
 * assigned to a property during an update of a document.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class Register {
    /**
     * Returns the value of the register.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get value() {
        return this['@ditto.value'];
    }
    /**
     * Creates a new Register that can be used as part of a document's content.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    constructor(value) {
        this['@ditto.value'] = value;
    }
    /** @internal */
    static '@ditto.create'(mutableDocument, path, value) {
        const register = mutableDocument
            ? new MutableRegister(value, privateToken)
            : new Register(value);
        register['@ditto.mutableDocument'] = mutableDocument;
        register['@ditto.path'] = path;
        register['@ditto.value'] = value;
        return register;
    }
}
// -----------------------------------------------------------------------------
/**
 * Represents a mutable CRDT register that can be set to a specific value when
 * updating a document.
 *
 * This class can't be instantiated directly, it's returned automatically for
 * any register property of a document within an update block via
 * {@link MutableDocumentPath.register}.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class MutableRegister extends Register {
    /**
     * Returns the value of the register.
     *
     * Not available in React Native environments.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get value() {
        return super.value;
    }
    /**
     * Convenience setter, equivalent to {@link set | set()}.
     *
     * Not available in React Native environments.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    set value(value) {
        this.set(value);
    }
    /**
     * Sets the register to the provided value.
     *
     * Only valid within the `update` closure of
     * {@link PendingCursorOperation.update | PendingCursorOperation.update()} and
     * {@link PendingIDSpecificOperation.update | PendingIDSpecificOperation.update()},
     * otherwise an exception is thrown.
     *
     * Not available in React Native environments.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    set(value) {
        const mutableDocument = this['@ditto.mutableDocument'];
        const path = this['@ditto.path'];
        mutableDocument.at(path)['@ditto.set'](value);
        // We also set the local value to make sure that the change is
        // reflected locally as well as in the underlying document.
        this['@ditto.value'] = value;
    }
    /** @internal */
    constructor(value) {
        if (arguments[1] === privateToken)
            super(value);
        else
            throw new Error(`MutableRegister constructor is for internal use only.`);
    }
}

const ditto = (function () {
  // IMPORTANT: most packagers perform _static_ analysis to identity native
  // Node modules to copy them into the right directory within the
  // final package. This only works if we use constant strings with
  // require(). Therefore, we use an if for all supported targets and
  // explicitly require each instead of dynamically building the require
  // path.

  const target = process.platform + '-' + process.arch;
  try {
    if (target === 'darwin-x64') return require('./ditto.darwin-x64.node')
    if (target === 'darwin-arm64') return require('./ditto.darwin-arm64.node')
    if (target === 'linux-x64') return require('./ditto.linux-x64.node')
    if (target === 'linux-arm64') return require('./ditto.linux-arm64.node')
    if (target === 'win32-x64') return require('./ditto.win32-x64.node')
  } catch (error) {
    throw new Error("Couldn't load native module 'ditto." + target + ".node' due to error:" + error.toString())
  }

  throw new Error("No native module 'ditto." + target + ".node' found. Please check the Ditto documentation for supported platforms.")
})();
function boxCBytesIntoBuffer(...args) { return ditto.boxCBytesIntoBuffer(...args) }
function boxCStringIntoString(...args) { return ditto.boxCStringIntoString(...args) }
function cStringVecToStringArray(...args) { return ditto.cStringVecToStringArray(...args) }
function ditto_add_subscription(...args) { return ditto.ditto_add_subscription(...args) }
function ditto_auth_client_get_app_id(...args) { return ditto.ditto_auth_client_get_app_id(...args) }
function ditto_auth_client_get_site_id(...args) { return ditto.ditto_auth_client_get_site_id(...args) }
function ditto_auth_client_is_web_valid(...args) { return ditto.ditto_auth_client_is_web_valid(...args) }
function ditto_auth_client_login_with_credentials(...args) { return ditto.ditto_auth_client_login_with_credentials(...args) }
function ditto_auth_client_login_with_token(...args) { return ditto.ditto_auth_client_login_with_token(...args) }
function ditto_auth_client_login_with_token_and_feedback(...args) { return ditto.ditto_auth_client_login_with_token_and_feedback(...args) }
function ditto_auth_client_logout(...args) { return ditto.ditto_auth_client_logout(...args) }
function ditto_auth_client_make_login_provider(...args) { return ditto.ditto_auth_client_make_login_provider(...args) }
function ditto_auth_client_user_id(...args) { return ditto.ditto_auth_client_user_id(...args) }
function ditto_auth_set_login_provider(...args) { return ditto.ditto_auth_set_login_provider(...args) }
function ditto_cancel_resolve_attachment(...args) { return ditto.ditto_cancel_resolve_attachment(...args) }
function ditto_clear_presence_callback(...args) { return ditto.ditto_clear_presence_callback(...args) }
function ditto_clear_presence_v3_callback(...args) { return ditto.ditto_clear_presence_v3_callback(...args) }
function ditto_collection_evict(...args) { return ditto.ditto_collection_evict(...args) }
function ditto_collection_evict_query_str(...args) { return ditto.ditto_collection_evict_query_str(...args) }
function ditto_collection_exec_query_str(...args) { return ditto.ditto_collection_exec_query_str(...args) }
function ditto_collection_get(...args) { return ditto.ditto_collection_get(...args) }
function ditto_collection_get_with_write_transaction(...args) { return ditto.ditto_collection_get_with_write_transaction(...args) }
function ditto_collection_insert_value(...args) { return ditto.ditto_collection_insert_value(...args) }
function ditto_collection_remove(...args) { return ditto.ditto_collection_remove(...args) }
function ditto_collection_remove_query_str(...args) { return ditto.ditto_collection_remove_query_str(...args) }
function ditto_collection_update(...args) { return ditto.ditto_collection_update(...args) }
function ditto_collection_update_multiple(...args) { return ditto.ditto_collection_update_multiple(...args) }
function ditto_disable_sync_with_v3(...args) { return ditto.ditto_disable_sync_with_v3(...args) }
function ditto_document_free(...args) { return ditto.ditto_document_free(...args) }
function ditto_document_get_cbor_with_path_type(...args) { return ditto.ditto_document_get_cbor_with_path_type(...args) }
function ditto_document_id(...args) { return ditto.ditto_document_id(...args) }
function ditto_document_id_query_compatible(...args) { return ditto.ditto_document_id_query_compatible(...args) }
function ditto_document_increment_counter(...args) { return ditto.ditto_document_increment_counter(...args) }
function ditto_document_remove(...args) { return ditto.ditto_document_remove(...args) }
function ditto_document_set_cbor(...args) { return ditto.ditto_document_set_cbor(...args) }
function ditto_document_set_cbor_with_timestamp(...args) { return ditto.ditto_document_set_cbor_with_timestamp(...args) }
function ditto_documents_hash(...args) { return ditto.ditto_documents_hash(...args) }
function ditto_documents_hash_mnemonic(...args) { return ditto.ditto_documents_hash_mnemonic(...args) }
function ditto_error_message(...args) { return ditto.ditto_error_message(...args) }
function ditto_free(...args) { return ditto.ditto_free(...args) }
function ditto_free_attachment_handle(...args) { return ditto.ditto_free_attachment_handle(...args) }
function ditto_get_collection_names(...args) { return ditto.ditto_get_collection_names(...args) }
function ditto_get_complete_attachment_path(...args) { return ditto.ditto_get_complete_attachment_path(...args) }
function ditto_get_sdk_version(...args) { return ditto.ditto_get_sdk_version(...args) }
function ditto_identity_config_make_manual_v0(...args) { return ditto.ditto_identity_config_make_manual_v0(...args) }
function ditto_identity_config_make_offline_playground(...args) { return ditto.ditto_identity_config_make_offline_playground(...args) }
function ditto_identity_config_make_online_playground(...args) { return ditto.ditto_identity_config_make_online_playground(...args) }
function ditto_identity_config_make_online_with_authentication(...args) { return ditto.ditto_identity_config_make_online_with_authentication(...args) }
function ditto_identity_config_make_shared_key(...args) { return ditto.ditto_identity_config_make_shared_key(...args) }
function ditto_init_sdk_version(...args) { return ditto.ditto_init_sdk_version(...args) }
function ditto_live_query_register_str_detached(...args) { return ditto.ditto_live_query_register_str_detached(...args) }
function ditto_live_query_signal_available_next(...args) { return ditto.ditto_live_query_signal_available_next(...args) }
function ditto_live_query_start(...args) { return ditto.ditto_live_query_start(...args) }
function ditto_live_query_stop(...args) { return ditto.ditto_live_query_stop(...args) }
function ditto_log(...args) { return ditto.ditto_log(...args) }
function ditto_logger_emoji_headings_enabled(...args) { return ditto.ditto_logger_emoji_headings_enabled(...args) }
function ditto_logger_emoji_headings_enabled_get(...args) { return ditto.ditto_logger_emoji_headings_enabled_get(...args) }
function ditto_logger_enabled(...args) { return ditto.ditto_logger_enabled(...args) }
function ditto_logger_enabled_get(...args) { return ditto.ditto_logger_enabled_get(...args) }
function ditto_logger_init(...args) { return ditto.ditto_logger_init(...args) }
function ditto_logger_minimum_log_level(...args) { return ditto.ditto_logger_minimum_log_level(...args) }
function ditto_logger_minimum_log_level_get(...args) { return ditto.ditto_logger_minimum_log_level_get(...args) }
function ditto_logger_set_custom_log_cb(...args) { return ditto.ditto_logger_set_custom_log_cb(...args) }
function ditto_logger_set_log_file(...args) { return ditto.ditto_logger_set_log_file(...args) }
function ditto_new_attachment_from_bytes(...args) { return ditto.ditto_new_attachment_from_bytes(...args) }
function ditto_new_attachment_from_file(...args) { return ditto.ditto_new_attachment_from_file(...args) }
function ditto_presence_v1(...args) { return ditto.ditto_presence_v1(...args) }
function ditto_presence_v3(...args) { return ditto.ditto_presence_v3(...args) }
function ditto_read_transaction(...args) { return ditto.ditto_read_transaction(...args) }
function ditto_read_transaction_free(...args) { return ditto.ditto_read_transaction_free(...args) }
function ditto_register_presence_v1_callback(...args) { return ditto.ditto_register_presence_v1_callback(...args) }
function ditto_register_presence_v3_callback(...args) { return ditto.ditto_register_presence_v3_callback(...args) }
function ditto_register_transport_condition_changed_callback(...args) { return ditto.ditto_register_transport_condition_changed_callback(...args) }
function ditto_remove_subscription(...args) { return ditto.ditto_remove_subscription(...args) }
function ditto_resolve_attachment(...args) { return ditto.ditto_resolve_attachment(...args) }
function ditto_run_garbage_collection(...args) { return ditto.ditto_run_garbage_collection(...args) }
function ditto_sdk_transports_error_free(...args) { return ditto.ditto_sdk_transports_error_free(...args) }
function ditto_sdk_transports_error_new(...args) { return ditto.ditto_sdk_transports_error_new(...args) }
function ditto_sdk_transports_error_value(...args) { return ditto.ditto_sdk_transports_error_value(...args) }
function ditto_sdk_transports_init(...args) { return ditto.ditto_sdk_transports_init(...args) }
function ditto_set_device_name(...args) { return ditto.ditto_set_device_name(...args) }
function ditto_shutdown(...args) { return ditto.ditto_shutdown(...args) }
function ditto_small_peer_info_get_is_enabled(...args) { return ditto.ditto_small_peer_info_get_is_enabled(...args) }
function ditto_small_peer_info_get_metadata(...args) { return ditto.ditto_small_peer_info_get_metadata(...args) }
function ditto_small_peer_info_get_sync_scope(...args) { return ditto.ditto_small_peer_info_get_sync_scope(...args) }
function ditto_small_peer_info_set_enabled(...args) { return ditto.ditto_small_peer_info_set_enabled(...args) }
function ditto_small_peer_info_set_metadata(...args) { return ditto.ditto_small_peer_info_set_metadata(...args) }
function ditto_small_peer_info_set_sync_scope(...args) { return ditto.ditto_small_peer_info_set_sync_scope(...args) }
function ditto_validate_document_id(...args) { return ditto.ditto_validate_document_id(...args) }
function ditto_write_transaction(...args) { return ditto.ditto_write_transaction(...args) }
function ditto_write_transaction_commit(...args) { return ditto.ditto_write_transaction_commit(...args) }
function ditto_write_transaction_rollback(...args) { return ditto.ditto_write_transaction_rollback(...args) }
function dittoffi_DEFAULT_DATABASE_ID(...args) { return ditto.dittoffi_DEFAULT_DATABASE_ID(...args) }
function dittoffi_DITTO_DEVELOPMENT_PROVIDER(...args) { return ditto.dittoffi_DITTO_DEVELOPMENT_PROVIDER(...args) }
function dittoffi_authentication_status_free(...args) { return ditto.dittoffi_authentication_status_free(...args) }
function dittoffi_authentication_status_is_authenticated(...args) { return ditto.dittoffi_authentication_status_is_authenticated(...args) }
function dittoffi_authentication_status_user_id(...args) { return ditto.dittoffi_authentication_status_user_id(...args) }
function dittoffi_base64_encode(...args) { return ditto.dittoffi_base64_encode(...args) }
function dittoffi_connection_request_authorize(...args) { return ditto.dittoffi_connection_request_authorize(...args) }
function dittoffi_connection_request_connection_type(...args) { return ditto.dittoffi_connection_request_connection_type(...args) }
function dittoffi_connection_request_free(...args) { return ditto.dittoffi_connection_request_free(...args) }
function dittoffi_connection_request_identity_service_metadata_json(...args) { return ditto.dittoffi_connection_request_identity_service_metadata_json(...args) }
function dittoffi_connection_request_peer_key_string(...args) { return ditto.dittoffi_connection_request_peer_key_string(...args) }
function dittoffi_connection_request_peer_metadata_json(...args) { return ditto.dittoffi_connection_request_peer_metadata_json(...args) }
function dittoffi_crypto_generate_secure_random_token(...args) { return ditto.dittoffi_crypto_generate_secure_random_token(...args) }
function dittoffi_differ_diff(...args) { return ditto.dittoffi_differ_diff(...args) }
function dittoffi_differ_free(...args) { return ditto.dittoffi_differ_free(...args) }
function dittoffi_differ_new(...args) { return ditto.dittoffi_differ_new(...args) }
function dittoffi_ditto_absolute_persistence_directory(...args) { return ditto.dittoffi_ditto_absolute_persistence_directory(...args) }
function dittoffi_ditto_config_default(...args) { return ditto.dittoffi_ditto_config_default(...args) }
function dittoffi_ditto_is_activated(...args) { return ditto.dittoffi_ditto_is_activated(...args) }
function dittoffi_ditto_is_sync_active(...args) { return ditto.dittoffi_ditto_is_sync_active(...args) }
function dittoffi_ditto_open_throws(...args) { return ditto.dittoffi_ditto_open_throws(...args) }
function dittoffi_ditto_set_authentication_status_handler(...args) { return ditto.dittoffi_ditto_set_authentication_status_handler(...args) }
function dittoffi_ditto_set_cloud_sync_enabled(...args) { return ditto.dittoffi_ditto_set_cloud_sync_enabled(...args) }
function dittoffi_ditto_stop_sync(...args) { return ditto.dittoffi_ditto_stop_sync(...args) }
function dittoffi_ditto_transport_config(...args) { return ditto.dittoffi_ditto_transport_config(...args) }
function dittoffi_ditto_try_new_blocking(...args) { return ditto.dittoffi_ditto_try_new_blocking(...args) }
function dittoffi_ditto_try_set_transport_config(...args) { return ditto.dittoffi_ditto_try_set_transport_config(...args) }
function dittoffi_ditto_try_start_sync(...args) { return ditto.dittoffi_ditto_try_start_sync(...args) }
function dittoffi_error_code(...args) { return ditto.dittoffi_error_code(...args) }
function dittoffi_error_description(...args) { return ditto.dittoffi_error_description(...args) }
function dittoffi_error_free(...args) { return ditto.dittoffi_error_free(...args) }
function dittoffi_get_sdk_semver(...args) { return ditto.dittoffi_get_sdk_semver(...args) }
function dittoffi_logger_try_export_to_file_async(...args) { return ditto.dittoffi_logger_try_export_to_file_async(...args) }
function dittoffi_presence_peer_metadata_json(...args) { return ditto.dittoffi_presence_peer_metadata_json(...args) }
function dittoffi_presence_set_connection_request_handler(...args) { return ditto.dittoffi_presence_set_connection_request_handler(...args) }
function dittoffi_presence_try_set_peer_metadata_json(...args) { return ditto.dittoffi_presence_try_set_peer_metadata_json(...args) }
function dittoffi_query_result_commit_id(...args) { return ditto.dittoffi_query_result_commit_id(...args) }
function dittoffi_query_result_free(...args) { return ditto.dittoffi_query_result_free(...args) }
function dittoffi_query_result_has_commit_id(...args) { return ditto.dittoffi_query_result_has_commit_id(...args) }
function dittoffi_query_result_item_at(...args) { return ditto.dittoffi_query_result_item_at(...args) }
function dittoffi_query_result_item_cbor(...args) { return ditto.dittoffi_query_result_item_cbor(...args) }
function dittoffi_query_result_item_count(...args) { return ditto.dittoffi_query_result_item_count(...args) }
function dittoffi_query_result_item_free(...args) { return ditto.dittoffi_query_result_item_free(...args) }
function dittoffi_query_result_item_json(...args) { return ditto.dittoffi_query_result_item_json(...args) }
function dittoffi_query_result_item_new(...args) { return ditto.dittoffi_query_result_item_new(...args) }
function dittoffi_query_result_mutated_document_id_at(...args) { return ditto.dittoffi_query_result_mutated_document_id_at(...args) }
function dittoffi_query_result_mutated_document_id_count(...args) { return ditto.dittoffi_query_result_mutated_document_id_count(...args) }
function dittoffi_store_begin_transaction_async_throws(...args) { return ditto.dittoffi_store_begin_transaction_async_throws(...args) }
function dittoffi_store_transactions(...args) { return ditto.dittoffi_store_transactions(...args) }
function dittoffi_transaction_complete_async_throws(...args) { return ditto.dittoffi_transaction_complete_async_throws(...args) }
function dittoffi_transaction_execute_async_throws(...args) { return ditto.dittoffi_transaction_execute_async_throws(...args) }
function dittoffi_transaction_free(...args) { return ditto.dittoffi_transaction_free(...args) }
function dittoffi_transaction_info(...args) { return ditto.dittoffi_transaction_info(...args) }
function dittoffi_try_add_sync_subscription(...args) { return ditto.dittoffi_try_add_sync_subscription(...args) }
function dittoffi_try_base64_decode(...args) { return ditto.dittoffi_try_base64_decode(...args) }
function dittoffi_try_exec_statement(...args) { return ditto.dittoffi_try_exec_statement(...args) }
function dittoffi_try_experimental_register_change_observer_str_detached(...args) { return ditto.dittoffi_try_experimental_register_change_observer_str_detached(...args) }
function dittoffi_try_remove_sync_subscription(...args) { return ditto.dittoffi_try_remove_sync_subscription(...args) }
function dittoffi_try_verify_license(...args) { return ditto.dittoffi_try_verify_license(...args) }
function getDeadlockTimeout$1(...args) { return ditto.getDeadlockTimeout(...args) }
function jsDocsToCDocs(...args) { return ditto.jsDocsToCDocs(...args) }
function refCBytesIntoBuffer(...args) { return ditto.refCBytesIntoBuffer(...args) }
function refCStringToString(...args) { return ditto.refCStringToString(...args) }
function setDeadlockTimeout$1(...args) { return ditto.setDeadlockTimeout(...args) }
function withOutBoxCBytes(...args) { return ditto.withOutBoxCBytes(...args) }

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
// This internal module contains the Ditto FFI error type and helper functions
// for working with it. Except for the feature flag helper, this module should
// not depend on any other parts of the Ditto Javascript SDK.
/** Matches a `<...>` prefix in an FFI result error message, e.g. `<dql> ...`. **/
const PREFIX_REGEX = new RegExp(/^<.*?>\s*/);
/**
 * Represents an exception that occurred during a call into the Ditto FFI.
 *
 * Use the {@link throwOnErrorStatus | throwOnErrorStatus()} helper to
 * automatically throw this error when an FFI call returns with a non-zero
 * return value.
 *
 * @internal
 */
class DittoFFIError extends Error {
    /**
     * Only call this constructor after having called `FFI.ensureInitialized()`
     * and `FFI.trace()`.
     *
     * @param code numerical status code returned by an FFI call or an
     * {@link FFIResultErrorCode} for errors returned on FFI result objects
     * @param messageOverride overrides the thread-local error message set in
     * Ditto core
     * @param messageFallback fallback message to use if the thread-local error
     * message is empty
     */
    constructor(code, messageOverride, messageFallback) {
        // Call `ffiErrorMessage()` even when an override is provided to ensure that
        // the thread-local error message is cleared.
        const threadLocalErrorMessage = ffiErrorMessage();
        super(messageOverride || threadLocalErrorMessage || messageFallback);
        this.code = code;
    }
}
/**
 * Throws a {@link DittoFFIError} if the given `ffiError` is not `null`.
 *
 * Removes the thread-local error message from Ditto core. If an error description
 * is available on the given `ffiError`, it is used as the error message of the
 * thrown {@link DittoFFIError}. A prefix in the error message is removed, e.g.
 * `<dql> ...`.
 *
 * If no error description is available, the given `ffiFunctionName` is used to
 * produce a fallback error message.
 *
 * @internal
 */
function throwOnErrorResult(ffiError, ffiFunctionName) {
    if (ffiError !== null) {
        let errorCode;
        let errorMsg;
        try {
            errorCode = dittoffi_error_code(ffiError);
            errorMsg = boxCStringIntoString(dittoffi_error_description(ffiError));
            dittoffi_error_free(ffiError);
        }
        catch (err) {
            throw new DittoFFIError(-1, `Failed to retrieve Ditto core error message: ${err.message}`);
        }
        if (errorMsg == null) {
            errorMsg = `${ffiFunctionName}() failed with error code: ${errorCode}`;
        }
        else {
            // Remove prefix from error message, e.g. `<dql> ...`.
            errorMsg = errorMsg.replace(PREFIX_REGEX, '');
        }
        throw new DittoFFIError(errorCode, errorMsg);
    }
}
/**
 * Retrieves last thread-local error message and removes it.
 *
 * Subsequent call to this function (if no new error message has been set) will
 * always return `null`.
 *
 * This function is not calling `FFI.ensureInitialized()` to avoid a circular
 * dependency. This is okay as long as this function is only called from a
 * context where `FFI.ensureInitialized()` has already been called.
 *
 * @internal
 */
function ffiErrorMessage() {
    const errorMessageCString = ditto_error_message();
    return boxCStringIntoString(errorMessageCString);
}

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
// NOTE: This is a temporary *hand-written* shim file for glue code for the
// Ditto native Node module. Mid to long term, we'll either move all of this
// code to the native side or generate this file via a companion CLI tool or
// something equivalent.
//
// IMPORTANT: please leave this file self-contained and do not import any
// sources from the JS SDK.
/** @internal */
const DittoCRDTTypeKey = '_ditto_internal_type_jkb12973t4b';
/** @internal */
const DittoCRDTValueKey = '_value';
/** @internal */
var DittoCRDTType;
(function (DittoCRDTType) {
    DittoCRDTType[DittoCRDTType["counter"] = 0] = "counter";
    DittoCRDTType[DittoCRDTType["register"] = 1] = "register";
    DittoCRDTType[DittoCRDTType["attachment"] = 2] = "attachment";
    DittoCRDTType[DittoCRDTType["rga"] = 3] = "rga";
    DittoCRDTType[DittoCRDTType["rwMap"] = 4] = "rwMap";
})(DittoCRDTType || (DittoCRDTType = {}));
// ------------------------------------------------------------- Constants --
/** @internal */
function DITTO_DEVELOPMENT_PROVIDER() {
    ensureInitialized();
    const providerCString = dittoffi_DITTO_DEVELOPMENT_PROVIDER();
    return refCStringToString(providerCString);
}
/** @internal */
function DEFAULT_DATABASE_ID() {
    ensureInitialized();
    const idCString = dittoffi_DEFAULT_DATABASE_ID();
    return refCStringToString(idCString);
}
// ------------------------------------------------------------- Differ --------
function differNew() {
    ensureInitialized();
    return dittoffi_differ_new();
}
function differDiff(differ, items) {
    ensureInitialized();
    return dittoffi_differ_diff(differ, items);
}
function differFree(differ) {
    ensureInitialized();
    dittoffi_differ_free(differ);
}
// HACK: underlying safer-ffi doesn't equivalent a CDitto with dittoffi_store_t
// although they are C aliases so we need to force it's type.
/** @internal */
function dittoPointerToStorePointer(dittoHandle) {
    return {
        addr: dittoHandle.addr,
        type: 'dittoffi_store_t const *',
    };
}
// ------------------------------------------------------------- Document ------
/** @internal */
function documentSetCBORWithTimestamp(document, path, cbor, timestamp) {
    ensureInitialized();
    const pathX = bytesFromString(path);
    const errorCode = ditto_document_set_cbor_with_timestamp(document, pathX, cbor, timestamp);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_document_set_cbor_with_timestamp() failed with error code: ${errorCode}`);
    }
}
/** @internal */
function documentSetCBOR(document, path, cbor) {
    ensureInitialized();
    // NOTE: not sure if this should be async or not.
    const pathX = bytesFromString(path);
    const errorCode = ditto_document_set_cbor(document, pathX, cbor);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_document_set_cbor() failed with error code: ${errorCode}`);
    }
}
/** @internal */
function documentID(self) {
    ensureInitialized();
    // REFACTOR: add proper error handling.
    const documentIDX = ditto_document_id(self);
    return boxCBytesIntoBuffer(documentIDX);
}
/** @internal */
function documentGetCBORWithPathType(document, path, pathType) {
    ensureInitialized();
    const pathBytes = bytesFromString(path);
    const cborPathResultRaw = ditto_document_get_cbor_with_path_type(document, pathBytes, pathType);
    const cborPathResult = {
        statusCode: cborPathResultRaw.status_code,
        cbor: boxCBytesIntoBuffer(cborPathResultRaw.cbor),
    };
    return cborPathResult;
}
/** @internal */
function documentRemove(document, path) {
    ensureInitialized();
    const pathBytes = bytesFromString(path);
    const errorCode = ditto_document_remove(document, pathBytes);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_document_remove() failed with error code: ${errorCode}`);
    }
}
/** @internal */
function documentIncrementCounter(document, path, amount) {
    ensureInitialized();
    const pathBytes = bytesFromString(path);
    const errorCode = ditto_document_increment_counter(document, pathBytes, amount);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_document_increment_counter() failed with error code: ${errorCode}`);
    }
}
/** @internal */
function documentFree(self) {
    ensureInitialized();
    // REFACTOR: add proper error handling.
    ditto_document_free(self);
}
// ----------------------------------------------------------- DocumentID ------
/** @internal */
function documentIDQueryCompatible(docID, stringPrimitiveFormat) {
    ensureInitialized();
    const docIDString = ditto_document_id_query_compatible(docID, stringPrimitiveFormat);
    return boxCStringIntoString(docIDString);
}
/** @internal */
function validateDocumentID(docID) {
    ensureInitialized();
    const cborCBytes = withOutBoxCBytes((outCBOR) => {
        const errorCode = ditto_validate_document_id(docID, outCBOR);
        if (errorCode !== 0) {
            throw new Error(errorMessage() ||
                `ditto_validate_document_id() failed with error code: ${errorCode}`);
        }
        return outCBOR;
    });
    return boxCBytesIntoBuffer(cborCBytes);
}
// ----------------------------------------------------------- Collection ------
/** @internal */
async function collectionGet(ditto, collectionName, documentID, readTransaction) {
    ensureInitialized();
    // REFACTOR: add proper error handling.
    const collectionNamePointer = bytesFromString(collectionName);
    const { status_code: errorCode, document } = await ditto_collection_get(ditto, collectionNamePointer, documentID, readTransaction);
    if (errorCode === NOT_FOUND_ERROR_CODE)
        return null;
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_collection_get() failed with error code: ${errorCode}`);
    }
    return document;
}
/** @internal */
async function collectionGetWithWriteTransaction(ditto, collectionName, documentID, writeTransaction) {
    ensureInitialized();
    const collectionNamePointer = bytesFromString(collectionName);
    const { status_code: errorCode, document } = await ditto_collection_get_with_write_transaction(ditto, collectionNamePointer, documentID, writeTransaction);
    if (errorCode === NOT_FOUND_ERROR_CODE)
        return null;
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_collection_get_with_write_transaction() failed with error code: ${errorCode}`);
    }
    return document;
}
/** @internal */
async function collectionInsertValue(ditto, collectionName, doc_cbor, writeStrategy, writeTransaction) {
    ensureInitialized();
    // REFACTOR: add proper error handling.
    const collectionNameX = bytesFromString(collectionName);
    let strategy;
    switch (writeStrategy) {
        case 'merge':
            strategy = 'Merge';
            break;
        case 'insertIfAbsent':
            strategy = 'InsertIfAbsent';
            break;
        case 'insertDefaultIfAbsent':
            strategy = 'InsertDefaultIfAbsent';
            break;
        case 'updateDifferentValues':
            strategy = 'UpdateDifferentValues';
            break;
        default:
            throw new Error(`Unsupported write strategy '${writeStrategy}' provided.`);
    }
    const { status_code: errorCode, id } = await ditto_collection_insert_value(ditto, collectionNameX, doc_cbor, strategy, null, writeTransaction !== null && writeTransaction !== void 0 ? writeTransaction : null);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_collection_insert_value() failed with error code: ${errorCode}`);
    }
    return boxCBytesIntoBuffer(id);
}
/** @internal */
async function collectionRemove(ditto, collectionName, writeTransaction, documentID) {
    ensureInitialized();
    // REFACTOR: add proper error handling.
    const collectionNameX = bytesFromString(collectionName);
    const { status_code: errorCode, bool_value: didRemove } = await ditto_collection_remove(ditto, collectionNameX, writeTransaction, documentID);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_collection_remove() failed with error code: ${errorCode}`);
    }
    return didRemove;
}
/** @internal */
async function collectionEvict(ditto, collectionName, writeTransaction, documentID) {
    ensureInitialized();
    // REFACTOR: add proper error handling.
    const collectionNameX = bytesFromString(collectionName);
    const { status_code: errorCode, bool_value: didEvict } = await ditto_collection_evict(ditto, collectionNameX, writeTransaction, documentID);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_collection_evict() failed with error code: ${errorCode}`);
    }
    return didEvict;
}
/** @internal */
async function collectionUpdate(ditto, collectionName, writeTransaction, document) {
    ensureInitialized();
    const collectionNameX = bytesFromString(collectionName);
    const errorCode = await ditto_collection_update(ditto, collectionNameX, writeTransaction, document);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_collection_update() failed with error code: ${errorCode}`);
    }
}
/** @internal */
async function collectionUpdateMultiple(ditto, collectionName, writeTransaction, documents) {
    ensureInitialized();
    const collectionNameX = bytesFromString(collectionName);
    const cDocuments = jsDocsToCDocs(documents);
    const errorCode = await ditto_collection_update_multiple(ditto, collectionNameX, writeTransaction, cDocuments);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_collection_update_multiple() failed with error code: ${errorCode}`);
    }
}
/** @internal */
async function collectionExecQueryStr(ditto, collectionName, writeTransaction, query, queryArgsCBOR, orderBy, limit, offset) {
    ensureInitialized();
    const collectionNameX = bytesFromString(collectionName);
    const queryX = bytesFromString(query);
    return await ditto_collection_exec_query_str(ditto, collectionNameX, writeTransaction, queryX, queryArgsCBOR, orderBy, limit, offset);
}
/** @internal */
async function collectionRemoveQueryStr(ditto, collectionName, writeTransaction, query, queryArgsCBOR, orderBy, limit, offset) {
    ensureInitialized();
    const collectionNameX = bytesFromString(collectionName);
    const queryX = bytesFromString(query);
    return await ditto_collection_remove_query_str(ditto, collectionNameX, writeTransaction, queryX, queryArgsCBOR, orderBy, limit, offset);
}
/** @internal */
async function collectionEvictQueryStr(ditto, collectionName, writeTransaction, query, queryArgsCBOR, orderBy, limit, offset) {
    ensureInitialized();
    const collectionNameX = bytesFromString(collectionName);
    const queryX = bytesFromString(query);
    return await ditto_collection_evict_query_str(ditto, collectionNameX, writeTransaction, queryX, queryArgsCBOR, orderBy, limit, offset);
}
/**
 * This FFI can error:
 * - DQL parser error
 * - Incorrect arguments to query parameters
 * - Collection is not found.
 *
 * @internal
 */
async function tryExecStatement(ditto, query, queryArgsCBOR) {
    ensureInitialized();
    const queryBytesPointer = bytesFromString(query);
    const result = await dittoffi_try_exec_statement(ditto, queryBytesPointer, queryArgsCBOR);
    throwOnErrorResult(result.error, 'dittoffi_try_exec_statement');
    return result.success;
}
/** @internal */
function addSubscription(ditto, collectionName, query, queryArgsCBOR, orderBy, limit, offset) {
    ensureInitialized();
    const collectionNameX = bytesFromString(collectionName);
    const queryX = bytesFromString(query);
    const statusCode = ditto_add_subscription(ditto, collectionNameX, queryX, queryArgsCBOR, orderBy, limit, offset);
    if (statusCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_add_subscription() failed with error code: ${statusCode}`);
    }
}
/** @internal */
function removeSubscription(ditto, collectionName, query, queryArgsCBOR, orderBy, limit, offset) {
    ensureInitialized();
    const collectionNameX = bytesFromString(collectionName);
    const queryX = bytesFromString(query);
    const statusCode = ditto_remove_subscription(ditto, collectionNameX, queryX, queryArgsCBOR, orderBy, limit, offset);
    if (statusCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_remove_subscription() failed with error code: ${statusCode}`);
    }
}
/** @internal */
function tryAddSyncSubscription(dittoPointer, query, queryArgsCBOR) {
    ensureInitialized();
    const queryBuffer = bytesFromString(query);
    const result = dittoffi_try_add_sync_subscription(dittoPointer, queryBuffer, queryArgsCBOR);
    throwOnErrorResult(result.error, 'dittoffi_try_add_sync_subscription');
}
/** @internal */
function tryRemoveSyncSubscription(dittoPointer, query, queryArgsCBOR) {
    ensureInitialized();
    const queryBuffer = bytesFromString(query);
    const result = dittoffi_try_remove_sync_subscription(dittoPointer, queryBuffer, queryArgsCBOR);
    throwOnErrorResult(result.error, 'dittoffi_try_remove_sync_subscription');
}
// ----------------------------------------------------------- QueryResult ------
/**
 * Doesn't error
 *
 * @internal
 */
function queryResultFree(queryResultPointer) {
    ensureInitialized();
    dittoffi_query_result_free(queryResultPointer);
}
/**
 * Doesn't error
 *
 * @internal
 */
function queryResultItemFree(queryResultItemPointer) {
    ensureInitialized();
    dittoffi_query_result_item_free(queryResultItemPointer);
}
/**
 * Can error only on internal bug.
 *
 * @internal */
function queryResultItems(queryResultPointer) {
    ensureInitialized();
    const rv = [];
    const resultCount = dittoffi_query_result_item_count(queryResultPointer);
    for (let i = 0; i < resultCount; i++)
        rv.push(dittoffi_query_result_item_at(queryResultPointer, i));
    return rv;
}
/**
 * Doesn't error
 *
 * @internal
 */
function queryResultMutatedDocumentIDs(queryResultPointer) {
    ensureInitialized();
    const rv = [];
    const resultCount = dittoffi_query_result_mutated_document_id_count(queryResultPointer);
    for (let i = 0; i < resultCount; i++) {
        const cborBytes = dittoffi_query_result_mutated_document_id_at(queryResultPointer, i);
        rv.push(boxCBytesIntoBuffer(cborBytes));
    }
    return rv;
}
/**
 * @internal
 */
function queryResultHasCommitID(queryResultPointer) {
    ensureInitialized();
    return dittoffi_query_result_has_commit_id(queryResultPointer);
}
/**
 * @internal
 */
function queryResultCommitID(queryResultPointer) {
    ensureInitialized();
    const commitId = dittoffi_query_result_commit_id(queryResultPointer);
    // the FFI function returns a number or BigInt, we convert it to BigInt
    // to simplify the API
    return BigInt(commitId);
}
/**
 * The result CBOR contains a map/object with fields and values. No CRDTs are
 * present there as they are not needed. By default only values from registers
 * are returned and non-register fields are ignored.
 *
 * Doesn't error
 *
 * @internal
 */
function queryResultItemCBOR(queryResultItemPointer) {
    ensureInitialized();
    const cborBytes = dittoffi_query_result_item_cbor(queryResultItemPointer);
    return boxCBytesIntoBuffer(cborBytes);
}
/**
 * Returns JSON-encoded results given a DQL result item pointer.
 *
 * Compare for {@link queryResultItemCBOR} above.
 *
 * Doesn't error
 *
 * @internal
 */
function queryResultItemJSON(queryResultItemPointer) {
    ensureInitialized();
    const jsonBytes = dittoffi_query_result_item_json(queryResultItemPointer);
    return boxCStringIntoString(jsonBytes);
}
function queryResultItemNew(jsonData) {
    ensureInitialized();
    const result = dittoffi_query_result_item_new(jsonData);
    throwOnErrorResult(result.error, 'dittoffi_query_result_item_new');
    return result.success;
}
// ------------------------------------------------------------ LiveQuery ------
/** @internal */
function liveQueryRegister(ditto, collectionName, query, queryArgsCBOR, orderBy, limit, offset, eventHandler, 
// Cb may be called in parallel at any point, so let's use
// an optional error handler (which defaults to the ditto logger at 'Error' level).
onError) {
    ensureInitialized();
    const collectionNameBuffer = bytesFromString(collectionName);
    const queryBuffer = bytesFromString(query);
    // Note(Daniel): the callback is now registered to be called in a detached
    // manner: if the FFI / Rust does `cb()`, then when that call returns, the js
    // callback itself may not have completed. This is fine, since `signalNext()`
    // shall be the proper way to let the Rust core know the FFI call completed.
    const { status_code: errorCode, i64: id } = ditto_live_query_register_str_detached(ditto, collectionNameBuffer, queryBuffer, queryArgsCBOR, orderBy, limit, offset, wrapBackgroundCbForFFI(onError, eventHandler));
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `\`ditto_live_query_register_str()\` failed with error code: ${errorCode}`);
    }
    return id;
}
/** @internal */
function tryExperimentalRegisterChangeObserver(ditto, query, queryArgsCBOR, changeHandler) {
    ensureInitialized();
    const errorHandler = (err) => log('Error', `The registered store observer callback failed with ${err}`);
    const wrappedCallback = wrapBackgroundCbForFFI(errorHandler, changeHandler);
    const queryBuffer = bytesFromString(query);
    // Note(Daniel): the callback is registered to be called in a detached manner:
    // if the FFI / Rust does `cb()`, then when that call returns, the js callback
    // itself may not have completed. This is fine, since `signalNext()` shall be
    // the proper way to let the Rust core know the FFI call completed.
    const result = dittoffi_try_experimental_register_change_observer_str_detached(ditto, queryBuffer, queryArgsCBOR, wrappedCallback);
    throwOnErrorResult(result.error, 'dittoffi_try_experimental_register_change_observer_str_detached');
    return result.success;
}
/** @internal */
async function liveQueryStart(ditto, liveQueryID) {
    ensureInitialized();
    const errorCode = await ditto_live_query_start(ditto, liveQueryID);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `\`ditto_live_query_start()\` failed with error code: ${errorCode}`);
    }
}
/** @internal */
function liveQueryStop(ditto, liveQueryID) {
    ensureInitialized();
    ditto_live_query_stop(ditto, liveQueryID);
}
/** @internal */
async function liveQuerySignalAvailableNext(ditto, liveQueryID) {
    ensureInitialized();
    await ditto_live_query_signal_available_next(ditto, liveQueryID);
}
// ------------------------------------------------------ ReadTransaction ------
/** @internal */
async function readTransaction(ditto) {
    ensureInitialized();
    // REFACTOR: add proper error handling.
    const { status_code: errorCode, txn: readTransaction } = await ditto_read_transaction(ditto);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `\`ditto_read_transaction()\` failed with error code: ${errorCode}`);
    }
    return readTransaction;
}
/** @internal */
function readTransactionFree(self) {
    ensureInitialized();
    // REFACTOR: add proper error handling.
    return ditto_read_transaction_free(self);
}
// ----------------------------------------------------- WriteTransaction ------
/** @internal */
async function writeTransaction(ditto) {
    ensureInitialized();
    // REFACTOR: add proper error handling.
    const { status_code: errorCode, txn: writeTransaction } = await ditto_write_transaction(ditto, null);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_write_transaction() failed with error code: ${errorCode}`);
    }
    return writeTransaction;
}
/** @internal */
async function writeTransactionCommit(ditto, self) {
    ensureInitialized();
    const errorCode = await ditto_write_transaction_commit(ditto, self);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_write_transaction_commit() failed with error code: ${errorCode}`);
    }
}
/** @internal */
async function writeTransactionRollback(ditto, transaction) {
    ensureInitialized();
    const errorCode = await ditto_write_transaction_rollback(ditto, transaction);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_write_transaction_rollback() failed with error code: ${errorCode}`);
    }
}
// --------------------------------------------------------------- Logger ------
/** @internal */
function loggerInit() {
    ensureInitialized();
    ditto_logger_init();
}
/** @internal */
async function loggerSetCustomLogCb(cb) {
    ensureInitialized();
    if (null === cb) {
        await ditto_logger_set_custom_log_cb(null);
    }
    else {
        // IDEA: pass custom error handler here instead of null?
        const wrappedCallback = wrapBackgroundCbForFFI(null, (loglevel, cMsg) => {
            try {
                const msg = boxCStringIntoString(cMsg);
                cb(loglevel, msg);
            }
            catch (e) {
                log('Error', `The registered cb in \`ditto_logger_set_custom_log_cb()\` failed with: ${e}`);
            }
        });
        await ditto_logger_set_custom_log_cb(wrappedCallback);
    }
}
/** @internal */
function loggerEnabled(enabled) {
    ensureInitialized();
    ditto_logger_enabled(!!enabled);
}
/** @internal */
function loggerEnabledGet() {
    ensureInitialized();
    return !!ditto_logger_enabled_get();
}
/** @internal */
function loggerEmojiHeadingsEnabled(loggerEmojiHeadingsEnabled) {
    ensureInitialized();
    ditto_logger_emoji_headings_enabled(loggerEmojiHeadingsEnabled);
}
/** @internal */
function loggerEmojiHeadingsEnabledGet() {
    ensureInitialized();
    return ditto_logger_emoji_headings_enabled_get();
}
/** @internal */
function loggerMinimumLogLevel(logLevel) {
    ensureInitialized();
    ditto_logger_minimum_log_level(logLevel);
}
/** @internal */
function loggerMinimumLogLevelGet() {
    ensureInitialized();
    return ditto_logger_minimum_log_level_get();
}
/** @internal */
function loggerSetLogFile(path) {
    ensureInitialized();
    const pathBytesOrNull = path ? bytesFromString(path) : null;
    const errorCode = ditto_logger_set_log_file(pathBytesOrNull);
    if (errorCode !== 0) {
        const message = errorMessage();
        throw new Error(`Can't set log file, due to error: ${message}`);
    }
}
/** @internal */
async function loggerTryExportToFile(path) {
    ensureInitialized();
    const pathBytes = bytesFromString(path);
    const result = await new Promise((resolve, reject) => {
        const wrappedCallback = wrapBackgroundCbForFFI(reject, resolve);
        dittoffi_logger_try_export_to_file_async(pathBytes, wrappedCallback);
    });
    throwOnErrorResult(result.error, 'dittoffi_logger_try_export_to_file_async');
    return result.success;
}
/** @internal */
function log(level, message) {
    ensureInitialized();
    const messageBuffer = bytesFromString(message);
    ditto_log(level, messageBuffer);
}
// ----------------------------------------------------------- AuthClient ------
/** @internal */
function dittoIdentityConfigMakeOnlinePlayground(appID, sharedToken, baseURL) {
    ensureInitialized();
    const appIDX = bytesFromString(appID);
    const sharedTokenX = bytesFromString(sharedToken);
    const baseURLX = bytesFromString(baseURL);
    const { status_code: errorCode, identity_config: identityConfig } = ditto_identity_config_make_online_playground(appIDX, sharedTokenX, baseURLX);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_identity_config_make_online_playground() failed with error code: ${errorCode}`);
    }
    return identityConfig;
}
/** @internal */
function dittoIdentityConfigMakeOnlineWithAuthentication(appID, baseURL) {
    ensureInitialized();
    const appIDX = bytesFromString(appID);
    const baseURLX = bytesFromString(baseURL);
    const { status_code: errorCode, identity_config: identityConfig } = ditto_identity_config_make_online_with_authentication(appIDX, baseURLX);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_identity_config_make_online_with_authentication() failed with error code: ${errorCode}`);
    }
    return identityConfig;
}
/** @internal */
function dittoIdentityConfigMakeOfflinePlayground(appId, siteID) {
    ensureInitialized();
    const appIdX = bytesFromString(appId);
    const siteIDX = Number(siteID);
    const { status_code: errorCode, identity_config: identityConfig } = ditto_identity_config_make_offline_playground(appIdX, siteIDX);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_identity_config_make_offline_playground() failed with error code: ${errorCode}`);
    }
    return identityConfig;
}
/** @internal */
function dittoIdentityConfigMakeSharedKey(appId, sharedKey, siteID) {
    ensureInitialized();
    const appIdX = bytesFromString(appId);
    const sharedKeyX = bytesFromString(sharedKey);
    const siteIDX = Number(siteID);
    const { status_code: errorCode, identity_config: identityConfig } = ditto_identity_config_make_shared_key(appIdX, sharedKeyX, siteIDX);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_identity_config_make_shared_key() failed with error code: ${errorCode}`);
    }
    return identityConfig;
}
/** @internal */
function dittoIdentityConfigMakeManual(configCBORBase64) {
    ensureInitialized();
    const configCBORBase64X = bytesFromString(configCBORBase64);
    const { status_code: errorCode, identity_config: identityConfig } = ditto_identity_config_make_manual_v0(configCBORBase64X);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_identity_config_make_manual_v0() failed with error code: ${errorCode}`);
    }
    return identityConfig;
}
/** @internal */
function dittoAuthClientGetSiteID(ditto) {
    ensureInitialized();
    return ditto_auth_client_get_site_id(ditto);
}
/** @internal */
function dittoAuthClientGetAppID(ditto) {
    ensureInitialized();
    const cString = ditto_auth_client_get_app_id(ditto);
    return boxCStringIntoString(cString);
}
function dittoAuthClientUserID(ditto) {
    ensureInitialized();
    const cStr = ditto_auth_client_user_id(ditto);
    return boxCStringIntoString(cStr);
}
/** @internal */
function dittoAuthClientIsWebValid(ditto) {
    ensureInitialized();
    return ditto_auth_client_is_web_valid(ditto) !== 0;
}
async function dittoAuthClientLoginWithTokenAndFeedback(ditto, token, provider) {
    ensureInitialized();
    const tokenBytes = bytesFromString(token);
    const providerBytes = bytesFromString(provider);
    const result = await ditto_auth_client_login_with_token_and_feedback(ditto, tokenBytes, providerBytes);
    // Our `login_with_token_and_feedback()` API returns the `clientInfo` string
    // even when authentication has failed, so this function does not throw an
    // error when the status code is non-zero.
    const error = result.status_code === 0
        ? null
        : new DittoFFIError(result.status_code, undefined, 'Ditto failed to authenticate.');
    const clientInfo = result.c_string
        ? boxCStringIntoString(result.c_string)
        : null;
    return {
        error,
        clientInfo,
    };
}
async function dittoAuthClientLoginWithToken(ditto, token, provider) {
    ensureInitialized();
    const tokenBytes = bytesFromString(token);
    const providerBytes = bytesFromString(provider);
    const errorCode = await ditto_auth_client_login_with_token(ditto, tokenBytes, providerBytes);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `Ditto failed to authenticate (error code: ${errorCode}).`);
    }
}
async function dittoAuthClientLoginWithUsernameAndPassword(ditto, username, password, provider) {
    ensureInitialized();
    const usernameBytes = bytesFromString(username);
    const passwordBytes = bytesFromString(password);
    const providerBytes = bytesFromString(provider);
    const errorCode = await ditto_auth_client_login_with_credentials(ditto, usernameBytes, passwordBytes, providerBytes);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `Ditto failed to authenticate (error code: ${errorCode}).`);
    }
}
async function dittoAuthClientLogout(ditto) {
    ensureInitialized();
    const errorCode = await ditto_auth_client_logout(ditto);
    if (errorCode !== 0) {
        throw new Error(errorMessage() || `Ditto failed to logout (error code: ${errorCode}).`);
    }
}
/** @internal */
function dittoSetAuthenticationStatusHandler(ditto, authenticationStatusUpdateCb, 
// Cb may be called in parallel at any point, so let's use an optional error handler
onError) {
    ensureInitialized();
    dittoffi_ditto_set_authentication_status_handler(ditto, wrapBackgroundCbForFFI(onError, authenticationStatusUpdateCb));
}
function authenticationStatusUserID(ffiAuthenticationStatus) {
    ensureInitialized();
    return boxCStringIntoString(dittoffi_authentication_status_user_id(ffiAuthenticationStatus));
}
function authenticationStatusIsAuthenticated(ffiAuthenticationStatus) {
    ensureInitialized();
    return dittoffi_authentication_status_is_authenticated(ffiAuthenticationStatus);
}
function authenticationStatusFree(ffiAuthenticationStatus) {
    ensureInitialized();
    dittoffi_authentication_status_free(ffiAuthenticationStatus);
}
// --------------------------------------------------------- Transactions ------
function storeTransactions(store) {
    ensureInitialized();
    const cborBytes = dittoffi_store_transactions(store);
    return boxCBytesIntoBuffer(cborBytes);
}
async function storeBeginTransaction(store, options) {
    ensureInitialized();
    const ffiOptions = {
        is_read_only: options.isReadOnly,
        hint: bytesFromString(options.hint),
    };
    return new Promise((resolve, reject) => {
        const callback = wrapBackgroundCbForFFI(reject, (resultObj) => {
            throwOnErrorResult(resultObj.error, 'dittoffi_store_begin_transaction_async_throws');
            resolve(resultObj.success);
        });
        dittoffi_store_begin_transaction_async_throws(store, ffiOptions, callback);
    });
}
async function transactionCompleteAsync(transaction, action) {
    ensureInitialized();
    return new Promise((resolve, reject) => {
        const callback = wrapBackgroundCbForFFI(reject, (resultObj) => {
            throwOnErrorResult(resultObj.error, 'dittoffi_transaction_complete_async_throws');
            const action = resultObj.success;
            resolve(action);
        });
        dittoffi_transaction_complete_async_throws(transaction, action, callback);
    });
}
async function transactionExecuteAsync(transaction, query, queryArgsCbor) {
    ensureInitialized();
    return new Promise((resolve, reject) => {
        const callback = wrapBackgroundCbForFFI(reject, (resultObj) => {
            throwOnErrorResult(resultObj.error, 'dittoffi_transaction_execute_async_throws');
            resolve(resultObj.success);
        });
        const queryBytes = bytesFromString(query);
        dittoffi_transaction_execute_async_throws(transaction, queryBytes, queryArgsCbor, callback);
    });
}
function transactionInfo(transaction) {
    ensureInitialized();
    const cborBytes = dittoffi_transaction_info(transaction);
    return boxCBytesIntoBuffer(cborBytes);
}
function transactionFree(transaction) {
    ensureInitialized();
    dittoffi_transaction_free(transaction);
}
// --------------------------------------------------------- Ditto Config ------
/** @internal */
function dittoConfigDefault() {
    ensureInitialized();
    const cborBytes = dittoffi_ditto_config_default();
    return boxCBytesIntoBuffer(cborBytes);
}
/** @internal */
function dittoAbsolutePersistenceDirectory(dittoPointer) {
    ensureInitialized();
    const cString = dittoffi_ditto_absolute_persistence_directory(dittoPointer);
    return boxCStringIntoString(cString);
}
/** @internal */
function dittoOpenThrows(configCBOR, transportConfigMode, defaultRootDirectory) {
    ensureInitialized();
    const defaultRootDirectoryPointer = bytesFromString(defaultRootDirectory);
    // // Debug: Log CBOR bytes in hex format. The output can be pasted to https://cbor.me
    // // to visualize the CBOR structure.
    // const hexBytes = Array.from(configCBOR)
    //   .map((byte) => byte.toString(16).padStart(2, '0').toUpperCase())
    //   .join(' ');
    // console.log(`DEBUG: CBOR bytes (${configCBOR.length} bytes):`);
    // console.log(hexBytes);
    const result = dittoffi_ditto_open_throws(configCBOR, transportConfigMode, defaultRootDirectoryPointer);
    throwOnErrorResult(result.error, 'dittoffi_ditto_open_throws');
    return result.success;
}
/** @internal */
function dittoTryNewBlocking(path, identityConfig, historyTracking, transportConfigMode) {
    ensureInitialized();
    // Encryption is not supported by the JS SDK.
    const experimentalPassphrase = null;
    const pathPointer = bytesFromString(path);
    const experimentalPassphrasePointer = bytesFromString(experimentalPassphrase);
    const result = dittoffi_ditto_try_new_blocking(pathPointer, identityConfig, historyTracking, experimentalPassphrasePointer, transportConfigMode);
    throwOnErrorResult(result.error, 'dittoffi_ditto_try_new_blocking');
    return result.success;
}
/** @internal */
async function dittoGetCollectionNames(self) {
    ensureInitialized();
    const result = await ditto_get_collection_names(self);
    const errorCode = result.status_code;
    const cStringVec = result.names;
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_get_collection_names() failed with error code: ${errorCode}`);
    }
    // WORKAROUND: cStringVecToStringArray() returns an `object` for the Wasm
    // variant, but it really is an array. We therefore force-cast here. Remove as
    // soon the exported function has proper type.
    const strings = cStringVecToStringArray(cStringVec);
    return strings;
}
/** @internal */
function dittoFree(self) {
    ensureInitialized();
    // REFACTOR: add proper error handling.
    return ditto_free(self);
}
/** @internal */
function getDeadlockTimeout() {
    ensureInitialized();
    return getDeadlockTimeout$1();
}
/** @internal */
function setDeadlockTimeout(duration) {
    ensureInitialized();
    setDeadlockTimeout$1(duration);
}
/** @internal */
function cryptoGenerateSecureRandomToken() {
    ensureInitialized();
    const docIDString = dittoffi_crypto_generate_secure_random_token();
    return boxCStringIntoString(docIDString);
}
/** @internal */
function dittoRegisterPresenceV1Callback(self, cb) {
    ensureInitialized();
    ditto_register_presence_v1_callback(self, wrapBackgroundCbForFFI((err) => log('Error', `The registered presence callback v1 errored with ${err}`), (cJsonStr) => {
        const jsonStr = refCStringToString(cJsonStr);
        cb(jsonStr);
    }));
}
/** @internal */
async function dittoClearPresenceCallback(self) {
    ensureInitialized();
    return ditto_clear_presence_callback(self);
}
/** @internal */
function dittoRegisterPresenceV3Callback(self, cb) {
    ensureInitialized();
    ditto_register_presence_v3_callback(self, wrapBackgroundCbForFFI((err) => log('Error', `The registered presence callback v3 errored with ${err}`), (cJsonStr) => {
        const jsonStr = refCStringToString(cJsonStr);
        cb(jsonStr);
    }));
}
/** @internal */
async function dittoClearPresenceV3Callback(self) {
    ensureInitialized();
    return ditto_clear_presence_v3_callback(self);
}
/** @internal */
function presencePeerMetadataJSON(self) {
    ensureInitialized();
    const result = dittoffi_presence_peer_metadata_json(self);
    const typedArray = boxCBytesIntoBuffer(result);
    const textDecoder = new TextDecoder();
    return textDecoder.decode(typedArray);
}
/** @internal */
async function presenceTrySetPeerMetadataJSON(self, jsonString) {
    ensureInitialized();
    const jsonDataCString = bytesFromString(jsonString);
    const result = await dittoffi_presence_try_set_peer_metadata_json(self, jsonDataCString);
    throwOnErrorResult(result.error, 'dittoffi_presence_try_set_peer_metadata_json');
}
/** @internal */
function connectionRequestPeerKeyString(connectionRequest) {
    ensureInitialized();
    const cString = dittoffi_connection_request_peer_key_string(connectionRequest);
    return boxCStringIntoString(cString);
}
/** @internal */
function connectionRequestPeerMetadataJSON(connectionRequest) {
    ensureInitialized();
    const jsonByteRef = dittoffi_connection_request_peer_metadata_json(connectionRequest);
    const jsonBuffer = refCBytesIntoBuffer(jsonByteRef);
    const textDecoder = new TextDecoder();
    return textDecoder.decode(jsonBuffer);
}
/** @internal */
function connectionRequestIdentityServiceMetadataJSON(connectionRequest) {
    ensureInitialized();
    const jsonBytesRef = dittoffi_connection_request_identity_service_metadata_json(connectionRequest);
    const jsonBuffer = refCBytesIntoBuffer(jsonBytesRef);
    const textDecoder = new TextDecoder();
    return textDecoder.decode(jsonBuffer);
}
/** @internal */
function connectionRequestConnectionType(connectionRequest) {
    ensureInitialized();
    return dittoffi_connection_request_connection_type(connectionRequest);
}
/** @internal */
function connectionRequestAuthorize(connectionRequest, authorization) {
    ensureInitialized();
    dittoffi_connection_request_authorize(connectionRequest, authorization);
}
/** @internal */
function connectionRequestFree(connectionRequest) {
    ensureInitialized();
    dittoffi_connection_request_free(connectionRequest);
}
/** @internal */
function presenceSetConnectionRequestHandler(ditto, connectionRequestHandler, onError) {
    ensureInitialized();
    if (connectionRequestHandler == null) {
        dittoffi_presence_set_connection_request_handler(ditto, null);
    }
    else {
        const wrappedCallback = wrapAsyncBackgroundCbForFFI(onError, connectionRequestHandler);
        dittoffi_presence_set_connection_request_handler(ditto, wrappedCallback);
    }
}
/** @internal */
function dittoIsActivated(ditto) {
    ensureInitialized();
    return dittoffi_ditto_is_activated(ditto);
}
/** @internal */
function dittoIsSyncActive(ditto) {
    ensureInitialized();
    return dittoffi_ditto_is_sync_active(ditto);
}
/** @internal */
function dittoTryStartSync(ditto) {
    ensureInitialized();
    const result = dittoffi_ditto_try_start_sync(ditto);
    throwOnErrorResult(result.error, 'dittoffi_ditto_try_start_sync');
}
/** @internal */
function dittoStopSync(ditto) {
    ensureInitialized();
    return dittoffi_ditto_stop_sync(ditto);
}
/** @internal */
function dittoSetTransportConfig(ditto, transportConfigData) {
    ensureInitialized();
    const result = dittoffi_ditto_try_set_transport_config(ditto, transportConfigData, true);
    throwOnErrorResult(result.error, 'dittoffi_ditto_try_set_transport_config');
}
/** @internal */
function dittoTransportConfig(ditto) {
    ensureInitialized();
    const cborBytes = dittoffi_ditto_transport_config(ditto);
    return boxCBytesIntoBuffer(cborBytes);
}
/** @internal */
function dittoSetCloudSyncEnabled(ditto, cloudSyncEnabled) {
    ensureInitialized();
    dittoffi_ditto_set_cloud_sync_enabled(ditto, cloudSyncEnabled);
}
/** @internal */
function dittoSmallPeerInfoGetIsEnabled(dittoPointer) {
    ensureInitialized();
    return ditto_small_peer_info_get_is_enabled(dittoPointer);
}
/** @internal */
function dittoSmallPeerInfoSetEnabled(dittoPointer, isEnabled) {
    ensureInitialized();
    return ditto_small_peer_info_set_enabled(dittoPointer, isEnabled);
}
/** @internal */
function dittoSmallPeerInfoGetSyncScope(dittoPointer) {
    ensureInitialized();
    return ditto_small_peer_info_get_sync_scope(dittoPointer);
}
/** @internal */
function dittoSmallPeerInfoSetSyncScope(dittoPointer, syncScope) {
    ensureInitialized();
    return ditto_small_peer_info_set_sync_scope(dittoPointer, syncScope);
}
/** @internal */
function dittoSmallPeerInfoGetMetadata(dittoPointer) {
    ensureInitialized();
    const cString = ditto_small_peer_info_get_metadata(dittoPointer);
    return boxCStringIntoString(cString);
}
/** @internal */
function dittoSmallPeerInfoSetMetadata(dittoPointer, metadata) {
    ensureInitialized();
    const metadataCString = bytesFromString(metadata);
    const statusCode = ditto_small_peer_info_set_metadata(dittoPointer, metadataCString);
    switch (statusCode) {
        case 0:
            return;
        case -1:
            throw new Error('Internal inconsistency, the observability subsystem is unavailable.');
        case 1:
            throw new Error(`Validation error, size limit exceeded: ${errorMessage() || 'metadata is too big'}`);
        case 2:
            throw new Error(`Validation error, ${errorMessage() || 'depth limit for metadata object exceeded'}`);
        case 3:
            throw new Error(`Validation error, ${errorMessage() || `'${metadata}' is not a valid JSON object`}`);
        default:
            throw new Error(errorMessage() ||
                `Internal inconsistency, ditto_small_peer_info_set_metadata() returned an unknown error code: ${statusCode}`);
    }
}
/** @internal */
function dittoRegisterTransportConditionChangedCallback(self, cb) {
    ensureInitialized();
    if (!cb) {
        ditto_register_transport_condition_changed_callback(self, null);
    }
    else {
        ditto_register_transport_condition_changed_callback(self, wrapBackgroundCbForFFI((err) => log('Error', `The registered "transport condition changed" callback errored with ${err}`), cb));
    }
}
/** @internal */
function dittoSetDeviceName(dittoPointer, deviceName) {
    ensureInitialized();
    const deviceNameCString = bytesFromString(deviceName);
    const truncatedDeviceNameCString = ditto_set_device_name(dittoPointer, deviceNameCString);
    return boxCStringIntoString(truncatedDeviceNameCString);
}
// Not supported on Wasm.
/** @internal */
function dittoNewAttachmentFromFile(ditto, sourcePath, fileOperation) {
    ensureInitialized();
    const sourcePathCString = bytesFromString(sourcePath);
    const outAttachment = {};
    const errorCode = ditto_new_attachment_from_file(ditto, sourcePathCString, fileOperation, outAttachment);
    if (errorCode !== 0) {
        throw new DittoFFIError(errorCode, null, `ditto_new_attachment_from_file() failed with error code: ${errorCode}`);
    }
    return outAttachment;
}
/** @internal */
async function dittoNewAttachmentFromBytes(ditto, bytes) {
    ensureInitialized();
    const outAttachment = {};
    const errorCode = await ditto_new_attachment_from_bytes(ditto, bytes, outAttachment);
    if (errorCode !== 0) {
        throw new DittoFFIError(errorCode, null, `ditto_new_attachment_from_bytes() failed with error code: ${errorCode}`);
    }
    return outAttachment;
}
/**
 * @throws {@link DittoFFIError}
 * @internal
 */
async function dittoResolveAttachment(ditto, id, namedCallbacks, 
// Cb may be called in parallel at any point, so let's use
// an optional error handler (which defaults to the ditto logger at 'Error' level).
onError) {
    ensureInitialized();
    const { onComplete, onProgress, onDelete } = namedCallbacks;
    const wrappedOnComplete = wrapBackgroundCbForFFI(onError, onComplete);
    const wrappedOnProgress = wrapBackgroundCbForFFI(onError, onProgress);
    const wrappedOnDelete = wrapBackgroundCbForFFI(onError, onDelete);
    const { status_code: errorCode, cancel_token: cancelToken } = await ditto_resolve_attachment(ditto, id, wrappedOnComplete, wrappedOnProgress, wrappedOnDelete);
    if (errorCode !== 0) {
        throw new DittoFFIError(errorCode, null, `ditto_resolve_attachment() failed with error code: ${errorCode}`);
    }
    return cancelToken;
}
/** @internal */
function dittoCancelResolveAttachment(dittoPointer, id, cancelToken) {
    ensureInitialized();
    const errorCode = ditto_cancel_resolve_attachment(dittoPointer, id, cancelToken);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_cancel_resolve_attachment() failed with error code: ${errorCode}`);
    }
}
/** @internal */
function freeAttachmentHandle(attachmentHandlePointer) {
    ensureInitialized();
    ditto_free_attachment_handle(attachmentHandlePointer);
}
/** @internal */
function dittoGetCompleteAttachmentPath(dittoPointer, attachmentHandlePointer) {
    ensureInitialized();
    const pathCString = ditto_get_complete_attachment_path(dittoPointer, attachmentHandlePointer);
    return refCStringToString(pathCString);
}
/** @internal */
function dittoGetSDKVersion(ditto) {
    ensureInitialized();
    const cString = ditto_get_sdk_version(ditto);
    return boxCStringIntoString(cString);
}
/** @internal */
function dittoGetSDKSemver() {
    ensureInitialized();
    const cString = dittoffi_get_sdk_semver();
    return boxCStringIntoString(cString);
}
/** @internal */
function dittoPresenceV1(self) {
    ensureInitialized();
    const cString = ditto_presence_v1(self);
    return boxCStringIntoString(cString);
}
/** @internal */
function dittoPresenceV3(self) {
    ensureInitialized();
    const cString = ditto_presence_v3(self);
    return boxCStringIntoString(cString);
}
/** @internal */
async function dittoShutdown(dittoPointer) {
    ensureInitialized();
    return await ditto_shutdown(dittoPointer);
}
/** @internal */
async function dittoRunGarbageCollection(dittoPointer) {
    ensureInitialized();
    const statusCode = await ditto_run_garbage_collection(dittoPointer);
    if (statusCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_run_garbage_collection() failed with error code: ${statusCode}`);
    }
}
/** @internal */
async function dittoDisableSyncWithV3(dittoPointer) {
    ensureInitialized();
    const errorCode = await ditto_disable_sync_with_v3(dittoPointer);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_disable_sync_with_v3() failed with error code: ${errorCode}`);
    }
}
// ------------------------------------------------------ Hash & Mnemonic ------
/** @internal */
function documentsHash(documents) {
    ensureInitialized();
    const { status_code: errorCode, u64: hash } = ditto_documents_hash(documents);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `\`ditto_documents_hash()\` failed with error code: ${errorCode}`);
    }
    // `hash` is of type `number | BigInt`, let's unify it to `BigInt` to keep it simple.
    return BigInt(hash);
}
/** @internal */
function documentsHashMnemonic(documents) {
    ensureInitialized();
    const { status_code: errorCode, c_string } = ditto_documents_hash_mnemonic(documents);
    if (errorCode !== 0) {
        throw new Error(errorMessage() ||
            `\`ditto_documents_hash_mnemonic()\` failed with error code: ${errorCode}`);
    }
    return boxCStringIntoString(c_string);
}
// ------------------------------------------------------------- base64 --------
/** @internal */
function base64encode(bytes, paddingMode) {
    const base64CString = dittoffi_base64_encode(bytes, paddingMode);
    return boxCStringIntoString(base64CString);
}
/**
 * @throws {@link DittoFFIError} if the base64 string is invalid
 * @internal
 */
function tryBase64Decode(base64, paddingMode) {
    const base64BytesPointer = bytesFromString(base64);
    const result = dittoffi_try_base64_decode(base64BytesPointer, paddingMode);
    throwOnErrorResult(result.error, 'dittoffi_try_base64_decode');
    return boxCBytesIntoBuffer(result.success);
}
/** @internal */
async function dittoAuthSetLoginProvider(ditto, loginProvider) {
    ensureInitialized();
    return await ditto_auth_set_login_provider(ditto, loginProvider);
}
/** @internal */
function dittoAuthClientMakeLoginProvider(expiringCb, 
// Cb may be called in parallel at any point, so let's use an optional error handler
onError) {
    ensureInitialized();
    return ditto_auth_client_make_login_provider(wrapBackgroundCbForFFI(onError, expiringCb));
}
// ----------------------------------------------------------- Transports ------
/** @internal */
function transportsInit() {
    ensureInitialized();
    const { output: wasInitialized, errorType } = withTransportsError(ditto_sdk_transports_init);
    if (wasInitialized === false)
        throw new Error(`Failed to initialize transports (${errorType} error)`);
}
/**
 * Calls the given FFI function with the passed in arguments and a newly
 * allocated `transportsErrorPointer` as the last argument, then returns its
 * result.
 *
 * The given function MUST take a `transportsErrorPointer` as its last argument.
 *
 * @param ffiFunction The FFI function to wrap.
 * @param args The arguments to pass to the FFI function, excluding the
 * `transportsErrorPointer`.
 * @returns An object with two properties: `output` and `errorType`. `output` is
 * the return value of the FFI function, and `errorType` is the value of the
 * `transportsErrorPointer` after the FFI function has been called.
 */
function withTransportsError(ffiFunction, ...args) {
    const transportsErrorPointer = ditto_sdk_transports_error_new();
    const output = ffiFunction(...args, transportsErrorPointer);
    const errorType = ditto_sdk_transports_error_value(transportsErrorPointer);
    ditto_sdk_transports_error_free(transportsErrorPointer);
    return { output, errorType };
}
// ---------------------------------------------------------------- Other ------
/** @internal */
let isInitialized$1 = false;
isInitialized$1 = true;
/** @internal */
function initSDKVersion(platform, language, semVer) {
    ensureInitialized();
    bytesFromString(platform);
    bytesFromString(language);
    const semVerCString = bytesFromString(semVer);
    const errorCode = ditto_init_sdk_version(platform, language, semVerCString);
    if (typeof errorCode !== 'undefined' && errorCode !== 0) {
        throw new Error(errorMessage() ||
            `ditto_init_sdk_version() failed with error code: ${errorCode}`);
    }
}
/** @internal */
function tryVerifyLicense(ditto, license) {
    ensureInitialized();
    const licenseBuffer = bytesFromString(license);
    const result = dittoffi_try_verify_license(ditto, licenseBuffer);
    throwOnErrorResult(result.error, 'dittoffi_try_verify_license');
}
/**
 * Returns the platform-dependent default device name.
 *
 * @internal
 */
// FIXME: Move this to Ditto core.
function defaultDeviceName() {
    // FIXME: Check if device name stays the same on sdk and core levels (AR-5950).
    {
        const os = require('os');
        return os.hostname();
    }
}
// -------------------------------------------------------------- Private ------
// HACK: this is a left-over error code still in use which will be removed
// in the near future. Until then, we hard-code it here, just like the
// ObjC/Swift SDK.  See discussion on Slack for details:
// https://dittolive.slack.com/archives/CRRAWK99A/p1616065662069800
/** @internal */
const NOT_FOUND_ERROR_CODE = -30798;
/** @internal */
function wrapBackgroundCbForFFI(onError, cb) {
    const errorHandler = onError !== null && onError !== void 0 ? onError : ((err) => log('Error', `The registered callback failed with ${err}`));
    return (ret_sender, ...args) => {
        let ret;
        try {
            ret = cb(...args);
        }
        catch (err) {
            try {
                errorHandler(err);
            }
            catch (nested_error) {
                log('Error', `Internal error: \`onError()\` handler oughtn't throw, but it did throw ${nested_error}`);
            }
        }
        return ret_sender(ret);
    };
}
/** @internal */
function wrapAsyncBackgroundCbForFFI(onError, cb) {
    const errorHandler = onError !== null && onError !== void 0 ? onError : ((err) => log('Error', `The registered callback failed with ${err}`));
    return async (ret_sender, ...args) => {
        let ret;
        try {
            ret = await cb(...args);
        }
        catch (err) {
            try {
                errorHandler(err);
            }
            catch (nested_error) {
                log('Error', `Internal error: \`onError()\` handler oughtn't throw, but it did throw ${nested_error}`);
            }
        }
        return ret_sender(ret);
    };
}
/** @internal */
function bytesFromString(jsString) {
    if (typeof jsString === 'undefined')
        return undefined;
    if (jsString === null)
        return null;
    if (typeof jsString !== 'string') {
        throw new Error(`Can't convert string to Uint8Array, not a string: ${jsString}`);
    }
    const textEncoder = new TextEncoder();
    return textEncoder.encode(`${jsString}\0`);
}
/**
 * This is the legacy error-message retrieving function, using thread-local
 * storage.
 *
 * @internal
 */
function errorMessage() {
    ensureInitialized();
    // eslint-disable-next-line
    const errorMessageCString = ditto_error_message();
    return boxCStringIntoString(errorMessageCString);
}
/** @internal */
function ensureInitialized() {
    if (!isInitialized$1) {
        throw new Error('Ditto needs to be initialized before using any of its API, please make sure to call `await init()` first.');
    }
}

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
/**
 * Error code and default error message for all Ditto error messages.
 *
 * Keys of this object define _error codes_ with each value containing the
 * accompanying error description that is set as the default error message for
 * errors instantiated with this code.
 *
 * Error codes may start with an error domain and a slash to group categories of
 * errors together.
 */
const ERROR_CODES = {
    /** Internal error for unexpected system states */
    internal: 'An unexpected internal error occurred. Please get in touch with Ditto customer service to report this incident.',
    /** Internal error with an unknown error cause */
    // REFACTOR: May be replaced by `unknown` in v5. Tracked in #12755.
    'internal/unknown-error': 'An unexpected internal error occurred. Please get in touch with Ditto customer service to report this incident.',
    //
    // Errors originating in the SDK
    //
    /** Error when using a feature not supported by the current environment */
    // REFACTOR: May be replaced by `unsupported` in v5. Tracked in #12755.
    'sdk/unsupported': 'The feature is not supported by the current environment.',
    //
    // Authentication errors
    //
    /** Error when authentication failed */
    'authentication/failed-to-authenticate': 'Ditto failed to authenticate.',
    /** Error when the required expiration handler is not set before starting sync. */
    'authentication/expiration-handler-missing': 'The expiration handler must be set before starting sync.',
    //
    // IO errors
    //
    /** Error when a file or directory already exists */
    'io/already-exists': 'A file or directory already exists.',
    /** Error when a file or directory could not be found */
    'io/not-found': 'A file or directory could not be found.',
    /** Error when permission is denied for a file operation */
    'io/permission-denied': 'The operation failed due to insufficient permissions.',
    /** Error when an IO operation failed for an unspecified reason. See error message for details. */
    'io/operation-failed': 'The operation failed.',
    //
    // Query errors
    //
    /** Error for invalid DQL query arguments. */
    'query/arguments-invalid': 'The query arguments were invalid.',
    /** Errors that occur during evaluation of a query */
    'query/evaluation': 'The query could not be evaluated.',
    /** Errors that occur during execution of a query */
    'query/execution': 'The query could not be executed.',
    /** Error for an invalid DQL query. */
    'query/invalid': 'The query was invalid.',
    /** Error for a query that uses DQL features not supported in this version or not supported by the currently used API. */
    'query/unsupported': 'The query contains unsupported features.',
    /** Error for a failed query updating system parameters */
    'query/parameter': 'The query to update system parameters failed.',
    //
    // Store errors
    //
    /** Error in the storage backend. */
    'store/backend': 'An error occurred with the storage backend.',
    /** Error for an invalid CRDT. */
    'store/crdt': 'An error occurred processing a CRDT.',
    /** Error for a document not found. */
    'store/document-not-found': 'The document with the provided ID could not be found.',
    /** Error for writing to a read-only transaction. */
    'store/transaction-read-only': 'A mutating DQL query was attempted using a read-only transaction.',
    /** Error for an invalid document ID. */
    'store/document-id': 'The document ID is invalid.',
    /** Error when the chosen persistence directory is already in use by another Ditto instance. */
    'store/persistence-directory-locked': 'The chosen persistence directory is already in use by another Ditto instance.',
    /** Permission has been denied for a file operation when working with attachments. */
    'store/attachment-file-permission-denied': 'Permission has been denied for a file operation when working with attachments.',
    /** The source file for an attachment does not exist. */
    'store/attachment-file-not-found': 'The source file for the attachment does not exist.',
    /** Attachment could not be found. */
    'store/attachment-not-found': 'The attachment could not be found.',
    /** Attachment token is invalid. */
    'store/attachment-token-invalid': 'The attachment token is invalid.',
    /** An unclassified error while creating an attachment. */
    'store/failed-to-create-attachment': 'The attachment could not be created.',
    /** An unclassified error while fetching an attachment. */
    'store/failed-to-fetch-attachment': 'The attachment could not be fetched.',
    //
    // Activation errors
    //
    /** An error representing an invalid license token. */
    'activation/license-token-verification-failed': 'Please provide a valid license token.',
    /** An error representing an expired license token.  */
    'activation/license-token-expired': 'The license token expired. Please renew it.',
    /** An error representing a token is in an unsupported future format. */
    'activation/license-token-unsupported-future-version': 'The provided license token is in an unsupported future format.',
    /** The operation failed because it requires an activated Ditto instance. */
    'activation/not-activated': 'The operation failed because the Ditto instance has not yet been activated.',
    /** Activation is unnecessary for this Ditto instance, because of its identity. */
    'activation/unnecessary': 'Activation is unnecessary for this Ditto instance, because of its identity.',
    /** A validation error where the maximum depth limit was exceeded. */
    'validation/depth-limit-exceeded': 'The maximum depth limit has been exceeded.',
    /** A validation error where the value is not valid CBOR. */
    'validation/invalid-cbor': 'The value provided is not valid CBOR.',
    /** A validation error where the value is not valid JSON. */
    'validation/invalid-json': 'The value provided is not valid JSON.',
    /** A validation error where the TransportConfig is invalid for the active platform. */
    'validation/invalid-transport-config': 'The TransportConfig is invalid for the active platform.',
    /** A validation error where the {@link DittoConfig} is invalid. */
    'validation/invalid-ditto-config': 'The DittoConfig provided is invalid.',
    /** A validation error where a value is required to be a JavaScript object */
    'validation/not-an-object': 'The value provided is not of type object.',
    /** The value provided can not be serialized as JSON. */
    'validation/not-json-compatible': 'Value is not serializable as JSON.',
    /** A validation error where a size limit was exceeded. */
    'validation/size-limit-exceeded': 'The size limit has been exceeded.',
    //
    // Encryption errors
    //
    /**
     * Error when a passphrase was provided but the store is not encrypted.
     *
     * This error is not in use for the JavaScript SDK, which currently does not
     * support encrypted stores.
     */
    'encryption/extraneous-passphrase-given': 'Unexpected passphrase provided for the currently unencrypted store.',
    //
    // Differ errors
    //
    /** */
    'differ/identity-key-path-invalid': 'A provided identity key path is invalid.',
};

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
/** @see {@link FFIErrorMapping} */
const DEFAULT_STATUS_CODE_MAPPING = {
    //
    // Activation errors
    //
    ActivationLicenseTokenExpired: ['activation/license-token-expired'],
    ActivationLicenseTokenInvalid: [
        'activation/license-token-verification-failed',
    ],
    ActivationLicenseUnsupportedFutureVersion: [
        'activation/license-token-unsupported-future-version',
    ],
    ActivationNotActivated: ['activation/not-activated'],
    ActivationUnnecessary: ['activation/unnecessary'],
    //
    // Authenticaion errors
    //
    AuthenticationExpirationHandlerMissing: [
        'authentication/expiration-handler-missing',
    ],
    //
    // Input/output errors
    //
    IoAlreadyExists: ['io/already-exists'],
    IoNotFound: ['io/not-found'],
    IoPermissionDenied: ['io/permission-denied'],
    IoOperationFailed: ['io/operation-failed'],
    //
    // SDK-specific errors
    //
    JsFloatingStoreOperation: [
        'internal',
        'Internal inconsistency, an outstanding store operation was not awaited.',
    ],
    //
    // DQL errors
    //
    DqlEvaluationError: ['query/evaluation'],
    DqlQueryCompilation: ['query/invalid'],
    DqlInvalidQueryArgs: ['query/arguments-invalid'],
    DqlUnsupported: ['query/unsupported'],
    StoreQuery: ['query/execution'],
    ParameterQuery: ['query/parameter'],
    //
    // Encryption errors
    //
    EncryptionExtraneousPassphraseGiven: [
        'encryption/extraneous-passphrase-given',
    ],
    //
    // Store errors
    //
    StoreDatabase: ['store/backend'],
    StoreDocumentId: ['store/document-id'],
    StoreDocumentNotFound: ['store/document-not-found'],
    StoreTransactionReadOnly: ['store/transaction-read-only'],
    Crdt: ['store/crdt'],
    LockedDittoWorkingDirectory: ['store/persistence-directory-locked'],
    //
    // Validation errors
    //
    // This gets mapped to `internal` by default but depending on the context,
    // it should be mapped to a more specific error code.
    Base64Invalid: ['internal', 'Invalid base64 encoding.'],
    CborInvalid: ['internal', 'Invalid CBOR encoding.'],
    CborUnsupported: ['internal', 'Unsupported CBOR encoding.'],
    ValidationDepthLimitExceeded: ['validation/depth-limit-exceeded'],
    ValidationInvalidCbor: ['validation/invalid-cbor'],
    ValidationInvalidDittoConfig: ['validation/invalid-ditto-config'],
    ValidationInvalidJson: ['validation/invalid-json'],
    ValidationInvalidTransportConfig: ['validation/invalid-transport-config'],
    ValidationNotAMap: ['validation/not-an-object'],
    ValidationSizeLimitExceeded: ['validation/size-limit-exceeded'],
    //
    // Differ errors
    //
    DifferIdentityKeyPathInvalid: ['differ/identity-key-path-invalid'],
    //
    // Lifecycle errors
    //
    Transport: ['internal', 'Transport error.'],
    Unsupported: ['sdk/unsupported'],
    Unknown: ['internal/unknown-error'], // May be updated in v5, c.f. #12755
    default: ['internal/unknown-error'],
};
/**
 * `DittoError` is a subclass of the default Javascript `Error`. You can
 * identify specific errors programatically using the
 * {@link DittoError.code | code} property.
 *
 * Please reference {@link ERROR_CODES} for a comprehensive list of
 * possible error codes in this SDK version.
 *
 * @example
 * Handling a specific error code:
 * ```typescript
 * import { Attachment, DittoError } from '@dittolive/ditto'
 *
 * let attachment: Attachment
 * try {
 *   attachment = await ditto.store.newAttachment(filePath)
 * } catch (error) {
 *   if (error instanceof DittoError && error.code === 'store/attachment-file-not-found') {
 *     // Handle a non-existing file
 *   }
 *   throw error // Rethrow any other error
 * }
 * ```
 */
class DittoError extends Error {
    // --------------------------------------- Internal ------------------------
    /**
     * @internal
     * @param code string error code, see {@link ERROR_CODES}
     * @param message optional error message that replace's the message for the given error code
     * @param context optional object containing data that can help debug this error
     * @throws {@link DittoError} `internal`: when supplied with an invalid error code
     */
    constructor(code, message, context = {}) {
        if (ERROR_CODES[code] == null)
            throw new DittoError('internal', `Invalid error code: ${code}`);
        super(message || ERROR_CODES[code]);
        /**
         * Use the error code to identify a specific error programatically.
         *
         * @see {@link ERROR_CODES} for a comprehensive list of possible
         * error codes in this SDK version.
         */
        this.code = 'internal';
        this.code = code;
        this.context = Object.freeze({ ...context });
    }
    /**
     * Create a {@link DittoError} from a {@link DittoFFIError}.
     *
     * The error message will be set to the optional `messageOverride` parameter
     * if supplied, otherwise it will be taken from the `message` property of the
     * given {@link DittoFFIError}. In any case, the details of the underlying FFI
     * error are made available in the error context of the returned {@link DittoError}.
     *
     * @internal
     * @param code string error code from {@link ERROR_CODES}
     * @param messageOverride optional string that will be used as the error
     * message even if a thread-local error message has been retrieved from the
     * FFI
     * @param context optional object containing data that can help debug this error
     * @returns {@link DittoError}
     */
    static fromFFIError(ffiError, code, messageOverride, context) {
        const message = messageOverride || ffiError.message;
        const errorContext = {
            coreError: ffiError.code,
            coreErrorMessage: ffiError.message,
            ...context,
        };
        const err = new DittoError(code, message, errorContext);
        if (ffiError.stack != null) {
            // @ts-expect-error assigning to a readonly property
            err.stack = ffiError.stack;
        }
        return err;
    }
}
/**
 * Wraps the given function to catch any {@link DittoFFIError} and rethrow it as
 * a {@link DittoError}, mapping status codes of the {@link DittoFFIError} to
 * error codes of the {@link DittoError} using the given `statusCodeMapping`.
 *
 * Use either this function or {@link mapFFIErrorsAsync} to wrap all calls into
 * the FFI that can fail.
 *
 * If the given status code mapping contains error messages, they will replace
 * any error message that is returned by the FFI.
 *
 * @internal
 * @param closure function that can throw a {@link DittoFFIError}
 * @param statusCodeMapping optional mapping of status codes of the
 * {@link DittoFFIError} to error codes of the {@link DittoError}
 * @param context optional object containing data that can help debug this error
 * @throws {@link DittoError} when the wrapped function throws a {@link DittoFFIError}
 */
function mapFFIErrors(closure, statusCodeMapping, context) {
    try {
        return closure();
    }
    catch (error) {
        if (error instanceof DittoFFIError)
            throw translateFFIError(error, statusCodeMapping, context);
        throw error;
    }
}
/**
 * Wraps the given async function to catch any {@link DittoFFIError} and rethrow
 * it as a {@link DittoError}, mapping status codes of the {@link DittoFFIError}
 * to error codes of the {@link DittoError} using the given `statusCodeMapping`.
 *
 * Use either this function or {@link mapFFIErrors} to wrap any calls into the
 * FFI that can fail.
 *
 * If the given status code mapping contains error messages, they will replace
 * any error message that is returned by the FFI.
 *
 * @internal
 * @param closure async function that can throw a {@link DittoFFIError}
 * @param statusCodeMapping optional mapping of status codes of the
 * {@link DittoFFIError} to error codes of the {@link DittoError}.
 * @param context optional object containing data that can help debug this error
 * @throws {@link DittoError} when the wrapped function throws a {@link DittoFFIError}
 */
async function mapFFIErrorsAsync(closure, statusCodeMapping, context) {
    try {
        return await closure();
    }
    catch (error) {
        if (error instanceof DittoFFIError)
            throw translateFFIError(error, statusCodeMapping, context);
        throw error;
    }
}
const translateFFIError = (ffiError, customStatusCodeMapping, context) => {
    var _a;
    // Convert the status code to a string because it may be a negative number,
    // which can't be used as an index into an object.
    const statusCode = ffiError.code.toString();
    let code, message;
    if (customStatusCodeMapping != null &&
        customStatusCodeMapping[statusCode] != null) {
        [code, message] = customStatusCodeMapping[statusCode];
    }
    else {
        [code, message] =
            (_a = DEFAULT_STATUS_CODE_MAPPING[statusCode]) !== null && _a !== void 0 ? _a : DEFAULT_STATUS_CODE_MAPPING.default;
    }
    return DittoError.fromFFIError(ffiError, code, message, context);
};

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/**
 * Serves as a token for a specific attachment that you can pass to a call to
 * {@link Store.fetchAttachment | ditto.store.fetchAttachment()}.
 */
class AttachmentToken {
    // -------------------------------------------------------------------------
    /** @internal */
    constructor(jsObj) {
        // There are two representations of attachment tokens:
        // 1. The legacy typed representation is an internal format that is used by
        //    the query builder API. It can be identified by the presence of the
        //    [FFI.DittoCRDTTypeKey] field.
        // 2. The untyped representation is used in our public API and was first
        //    introduced in the HTTP API. It is now used by the DQL API as well. It
        //    uses a non-padded base64-encoded ID.
        let id, len, meta;
        if (jsObj[DittoCRDTTypeKey] != null) {
            ({ id, len, meta } = AttachmentToken.validateTypedInput(jsObj));
        }
        else {
            ({ id, len, meta } = AttachmentToken.validateUntypedInput(jsObj));
        }
        // base64-encode string and remove padding
        this.id = mapFFIErrors(() => base64encode(id, 'Unpadded'));
        this.idBytes = id;
        this.len = len;
        this.metadata = meta;
    }
    /**
     * Validate an input value that has a field `[FFI.DittoCRDTTypeKey]` and
     * return its contents.
     *
     * @throws {Error} If the input is invalid.
     * @returns {object} binary id, len and metadata of the attachment token
     */
    static validateTypedInput(jsObj) {
        const type = jsObj[DittoCRDTTypeKey];
        if (type !== DittoCRDTType.attachment)
            throw new Error('Invalid attachment token');
        const id = jsObj['_id'];
        if (!(id instanceof Uint8Array))
            throw new Error('Invalid attachment token id');
        const len = jsObj['_len'];
        if ((typeof len !== 'number' && typeof len !== 'bigint') || len < 0) {
            throw new Error('Invalid attachment token length, must be a non-negative number or bigint');
        }
        const meta = jsObj['_meta'];
        if (typeof meta !== 'object')
            throw new Error('Invalid attachment token meta');
        return { id, len, meta };
    }
    /**
     * Validate an untyped input value and return its contents.
     *
     * Converts _unpadded_ base64-encoded ID in input to _padded_ base64-encoded
     * ID before returning it as `Uint8Array`.
     *
     * @throws {@link DittoError} `store/attachment-token-invalid` If the input id
     * is not a valid base64 string.
     * @returns {object} binary id, len and metadata of the attachment token
     */
    static validateUntypedInput(jsObj) {
        const idBase64 = jsObj['id'];
        if (typeof idBase64 !== 'string')
            throw new Error('Invalid attachment token id');
        const id = mapFFIErrors(() => tryBase64Decode(idBase64, 'Unpadded'), {
            Base64Invalid: [
                'store/attachment-token-invalid',
                'Failed to decode attachment token id from base64 input',
            ],
        }, {
            attachmentTokenID: idBase64,
        });
        const len = jsObj['len'];
        if ((typeof len !== 'number' && typeof len !== 'bigint') || len < 0) {
            throw new Error('Invalid attachment token length, must be a non-negative number or bigint');
        }
        const meta = jsObj['metadata'];
        if (typeof meta !== 'object')
            throw new Error('Invalid attachment token meta');
        return { id, len, meta };
    }
}

// NOTE: this is patched up with the actual build version by Jake task
// build:package and has to be a valid semantic version as defined here: https://semver.org.
const fullBuildVersionString = '4.12.1';

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
let isInitialized = false;
let initPromise = null;
// Replacing {custom-sdk-name} with any string that doesn't contain '{' in the
// final build output switches the SDK_NAME to the custom name.
const SDK_NAME = '{custom-sdk-name}'.includes('{')
    ? 'JavaScript'
    : '{custom-sdk-name}';
/**
 * Initializes the whole Ditto module. Needs to be called and complete before
 * any of the Ditto API is used.
 *
 * @param options - Dictionary with global {@link InitOptions | initialization options}.
 */
function init(options = {}) {
    // If we have already completed initialization just return the resolved Promise
    if (isInitialized)
        return initPromise;
    // If initialization is in flight return the already created promise
    if (initPromise)
        return initPromise;
    initPromise = (async () => {
        isInitialized = true;
    })();
    return initPromise;
}
{
    switch (process.platform) {
        case 'android':
            initSDKVersion('Android', SDK_NAME, fullBuildVersionString);
            break;
        case 'darwin':
            initSDKVersion('Mac', SDK_NAME, fullBuildVersionString);
            break;
        case 'linux':
            initSDKVersion('Linux', SDK_NAME, fullBuildVersionString);
            break;
        case 'win32':
            initSDKVersion('Windows', SDK_NAME, fullBuildVersionString);
            break;
        default:
            initSDKVersion('Unknown', SDK_NAME, fullBuildVersionString);
            break;
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/**
 * Class with static methods to customize the logging behavior from Ditto and
 * log messages with the Ditto logging infrastructure.
 *
 * Currently, Ditto uses the persistence directory of the Ditto instance that
 * was most recently created to store a limited amount of logs. Ditto may
 * continue writing logs to a persistence directory even after the associated
 * Ditto instance is {@link Ditto.close | closed}. If this is a concern,
 * consider either disabling logging by setting {@link Logger.enabled} to
 * `false`, or instantiating a new Ditto instance. After either of these
 * actions, it is safe to remove the persistence directory. Please refer to
 * {@link Logger.exportToFile | `exportToFile()`} for further details on locally
 * collected logs.
 */
class Logger {
    /**
     * Registers a file path where logs will be written to, whenever Ditto wants
     * to issue a log (on _top_ of emitting the log to the console).
     */
    static get logFile() {
        return this._logFile;
    }
    /**
     * On Node, registers a file path where logs will be written to, whenever
     * Ditto wants to issue a log (on _top_ of emitting the log to the console).
     * In the browser, this method has no effect.
     *
     * @param path can be `null`, in which case the current logging file, if any,
     * is unregistered, otherwise, the file path must be within an already
     * existing directory.
     * @deprecated this mehod is deprecated and will be removed in a future version.
     */
    static setLogFile(path) {
        if (path) {
            loggerSetLogFile(path);
            this._logFile = path;
        }
        else {
            loggerSetLogFile(undefined);
            delete this._logFile;
        }
    }
    /**
     * Convenience method, takes the path part of the URL and calls
     * {@link setLogFile | setLogFile()} with it.
     *
     * @deprecated this method is deprecated and will be removed in a future version.
     */
    static setLogFileURL(url) {
        var _a;
        this.setLogFile((_a = url === null || url === void 0 ? void 0 : url.pathname) !== null && _a !== void 0 ? _a : null);
    }
    /**
     * Whether the logger is currently enabled.
     *
     * Logs exported through {@link exportToFile | exportToFile()} are not
     * affected by this setting and will also include logs emitted while
     * {@link enabled} is `false`.
     */
    static get enabled() {
        return loggerEnabledGet();
    }
    /** Enables or disables logging. */
    static set enabled(enabled) {
        loggerEnabled(enabled);
    }
    /**
     * Represents whether or not emojis should be used as the log level
     * indicator in the logs.
     *
     * @deprecated This property is deprecated and will be removed in a future version.
     */
    static get emojiLogLevelHeadingsEnabled() {
        return loggerEmojiHeadingsEnabledGet();
    }
    /**
     * Represents whether or not emojis should be used as the log level
     * indicator in the logs.
     */
    static set emojiLogLevelHeadingsEnabled(emojiLogLevelHeadingsEnabled) {
        loggerEmojiHeadingsEnabled(emojiLogLevelHeadingsEnabled);
    }
    /**
     * The minimum log level at which logs will be logged.
     *
     * For example if this is set to `Warning`, then only logs that are logged
     * with the `Warning` or `Error` log levels will be shown.
     *
     * Logs exported through {@link exportToFile | exportToFile()} are not
     * affected by this setting and include all logs at `Debug` level and above.
     */
    static get minimumLogLevel() {
        return loggerMinimumLogLevelGet();
    }
    /**
     * The minimum log level at which logs will be logged.
     *
     * For example if this is set to `Warning`, then only logs that are logged
     * with the `Warning` or `Error` log levels will be shown.
     */
    static set minimumLogLevel(minimumLogLevel) {
        loggerMinimumLogLevel(minimumLogLevel);
    }
    /**
     * Returns the current custom log callback, `undefined` by default. See
     * {@link setCustomLogCallback | setCustomLogCallback()} for a detailed
     * description.
     */
    static get customLogCallback() {
        return this._customLogCallback;
    }
    /**
     * Registers a custom callback that will be called to report each log entry.
     *
     * @param callback function called for each log entry. `undefined` will
     * unregister any previous callback and stop reporting log entries through
     * callbacks.
     *
     * @throws {TypeError} if `callback` is not a function or `undefined`.
     * @throws {Error} when called in a React Native environment.
     */
    static async setCustomLogCallback(callback) {
        if (callback != null && typeof callback !== 'function') {
            throw new TypeError(`Expected parameter 'callback' to be a function or undefined, but got ${typeof callback}.`);
        }
        if (callback != null) {
            await loggerSetCustomLogCb(callback);
            this._customLogCallback = callback;
        }
        else {
            await loggerSetCustomLogCb(null);
            delete this._customLogCallback;
        }
    }
    /**
     * Exports collected logs to a compressed and JSON-encoded file on the local
     * file system.
     *
     * Ditto's logger locally collects a limited amount of logs at `Debug` level
     * and above, periodically discarding older logs. This internal logger is
     * always enabled and works independently of the {@link Logger.enabled}
     * setting and the configured {@link Logger.minimumLogLevel}. Its logs can be
     * requested and downloaded from any peer that is active in a Ditto app using
     * the portal's device dashboard. This method provides an alternative way of
     * accessing those logs by exporting them to the local file system.
     *
     * The logs will be written as a gzip compressed file at the path specified by
     * the `path` parameter. When uncompressed, the file contains one JSON value
     * per line with the oldest entry on the first line (JSON lines format).
     *
     * Ditto limits the amount of logs it retains on disk to 15 MB and a maximum
     * age of three days. Older logs are periodically discarded once one of these
     * limits is reached.
     *
     * This method currently only exports logs from the most recently created
     * Ditto instance, even when multiple instances are running in the same
     * process.
     *
     * Not supported in browser environments.
     *
     * @param path The path of the file to write the logs to. The file must not
     * already exist, and the containing directory must exist. It is recommended
     * for the `path` to have the `.jsonl.gz` file extension but Ditto won't
     * enforce it, nor correct it.
     *
     * @returns The number of bytes written to the file.
     *
     * @throws `TypeError` if `path` is not a string.
     *
     * @throws {@link DittoError} `io/*` when the file cannot be written to disk.
     * Prevent this by ensuring that no file exists at the provided `path`, all
     * parent directories exists, sufficient permissions are granted, and that the
     * disk is not full.
     *
     * @throws {@link DittoError} `sdk/unsupported` when called in a browser
     * environment.
     */
    static async exportToFile(path) {
        if (typeof path !== 'string') {
            throw new TypeError(`Expected parameter 'path' to be a string, but got ${typeof path}.`);
        }
        let normalizedPath = path;
        if (process.platform === 'win32' &&
            !path.startsWith('\\\\?\\')) {
            if (path.length === 0)
                throw new DittoError('io/not-found', 'The path must not be empty.');
            // Normalize the path on Windows to prevent issues with long paths.
            // Windows has a hard limit of 260 characters for paths.
            // c.f. httpes://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation
            normalizedPath = `\\\\?\\${path}`;
        }
        return mapFFIErrorsAsync(() => loggerTryExportToFile(normalizedPath));
    }
    /**
     * Logs the message for the given `level`.
     *
     * @see {@link error | error()}
     * @see {@link warning | warning()}
     * @see {@link info | info()}
     * @see {@link debug | debug()}
     * @see {@link verbose | verbose()}
     */
    static log(level, message) {
        log(level, message);
    }
    /**
     * Convenience method, same as calling {@link log | log()} with
     * {@link LogLevel} `Error`.
     */
    static error(message) {
        this.log('Error', message);
    }
    /**
     * Convenience method, same as calling {@link log | log()} with
     * {@link LogLevel} `Warning`.
     */
    static warning(message) {
        this.log('Warning', message);
    }
    /**
     * Convenience method, same as calling {@link log | log()} with
     * {@link LogLevel} `Info`.
     */
    static info(message) {
        this.log('Info', message);
    }
    /**
     * Convenience method, same as calling {@link log | log()} with
     * {@link LogLevel} `Debug`.
     */
    static debug(message) {
        this.log('Debug', message);
    }
    /**
     * Convenience method, same as calling {@link log | log()} with
     * {@link LogLevel} `Verbose`.
     */
    static verbose(message) {
        this.log('Verbose', message);
    }
    constructor() {
        throw new Error("Logger can't be instantiated, use its static properties & methods directly instead.");
    }
}

const CBOR_OPTIONS = Object.freeze({
    dictionary: "object",
    mode: "strict",
});
/** A symbol which is emitted by the `reviver` and `replacer` functions when a value is not associated with a key or CBOR label.
 * In JSON, a value with no key simply emits an empty string; this would be indistinguishable from a valid CBOR data sequence.
 * Using a symbol acheives emitting a comparable value without the value being a valid CBOR data type.
 *
 * ```typescript
 * const encoded = encode('Plain string', (key, value) => {
 *   console.log(key)
 *   return value
 * })
 * // Expected: Symbol(EMPTY_KEY)
 * decode(encoded, (key, value) => {
 *   console.log(key)
 *   return value
 * })
 * // Expected: Symbol(EMPTY_KEY)
 * ```
 */
const EMPTY_KEY = Symbol("EMPTY_KEY");
/** A symbol which may be returned by the user in the encoder's `replacer` function to omit values. Just like detecting an empty
 * key, using a symbol acheives emitting a comparable value without the value being a valid CBOR data type. Use this in a custom
 * replacer function as the return value to indicate to the encoder that the value is to be skipped from arrays and dictionaries.
 *
 * ```typescript
 * const map = new Map<any, any>([[1, 2], ["1", 3000]])
 * const encoded = encode(map, (key, value) => key === "1" ? OMIT_VALUE : value)
 * console.log(new Uint8Array(encoded)) // Expect: Uint8Array(8) [ 161, 1, 2 ]
 * ```
 */
const OMIT_VALUE = Symbol("OMIT_VALUE");
const POW_2_24 = 5.960464477539063e-8;
const POW_2_32 = 4294967296;
const POW_2_53 = 9007199254740992;
const MAX_SAFE_INTEGER = 18446744073709551616n;
const DECODE_CHUNK_SIZE = 8192;
// CBOR defined tag values
const kCborTag = 6;
// RFC8746 Tag values for typed little endian arrays
const kCborTagUint8 = 64;
const kCborTagUint16 = 69;
const kCborTagUint32 = 70;
const kCborTagInt8 = 72;
const kCborTagInt16 = 77;
const kCborTagInt32 = 78;
const kCborTagFloat32 = 85;
const kCborTagFloat64 = 86;

// deno-lint-ignore-file no-explicit-any
function objectIs(x, y) {
    if (typeof Object.is === "function")
        return Object.is(x, y);
    // SameValue algorithm
    // Steps 1-5, 7-10
    if (x === y) {
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
    }
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
}
function options(options) {
    function isDictionary(value) {
        return typeof value === "string" && ["object", "map"].includes(value);
    }
    function isMode(value) {
        return typeof value === "string" &&
            ["loose", "strict", "sequence"].includes(value);
    }
    const bag = { ...CBOR_OPTIONS };
    if (typeof options === "object") {
        bag.dictionary = isDictionary(options.dictionary)
            ? options.dictionary
            : CBOR_OPTIONS.dictionary;
        bag.mode = isMode(options.mode) ? options.mode : CBOR_OPTIONS.mode;
    }
    return Object.freeze(bag);
}
function lexicographicalCompare(left, right) {
    const minLength = Math.min(left.byteLength, right.byteLength);
    for (let i = 0; i < minLength; i++) {
        const result = left[i] - right[i];
        if (result !== 0)
            return result;
    }
    return left.byteLength - right.byteLength;
}

var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Sequence_instances, _Sequence_toInspectString;
class Sequence {
    static from(iterable) {
        return new Sequence(Array.from(iterable));
    }
    constructor(data) {
        _Sequence_instances.add(this);
        Object.defineProperty(this, "_data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (data)
            this._data = data;
        else
            this._data = [];
    }
    /** Add data to the sequence and return the index of the item. */
    add(item) {
        return this._data.push(item) - 1;
    }
    /** Removes an item from the sequence, returning the value. */
    remove(index) {
        return this._data.splice(index, 1)[0];
    }
    /** Get an item from the sequence by index. */
    get(index) {
        return this._data[index];
    }
    /** Get a shallow clone of this CBOR Sequence. */
    clone() {
        return new Sequence(this.data);
    }
    /** Get a copy of the CBOR sequence data array. */
    get data() {
        return Array.from(this._data);
    }
    get size() {
        return this._data.length;
    }
    [(_Sequence_instances = new WeakSet(), Symbol.toStringTag)]() {
        return "Sequence";
    }
    [(_Sequence_toInspectString = function _Sequence_toInspectString(inspect) {
        return `${this[Symbol.toStringTag]()}(${this.size}) ${inspect(this._data)}`;
    }, Symbol.for("Deno.customInspect"))](inspect) {
        return __classPrivateFieldGet(this, _Sequence_instances, "m", _Sequence_toInspectString).call(this, inspect);
    }
    [Symbol.for("nodejs.util.inspect.custom")](_depth, _opts, inspect) {
        return __classPrivateFieldGet(this, _Sequence_instances, "m", _Sequence_toInspectString).call(this, inspect);
    }
}

// deno-lint-ignore-file no-explicit-any
/** Class for structuring a simple value. Unassigned or reserved simple values
 * are emitted as an instance of this class during decoding. This allows an
 * application to handle custom decoding in the `reviver` function of the decoder.
 *
 * ```typescript
 * const { buffer } = new Uint8Array([0x81,0xf8,0x64])
 * const decoded = decode(buffer, (key, value) => {
 *   // Let's pretend that a simple value of 100 stands for JavaScript NaN
 *   if (value instanceof SimpleValue && value.value === 100) return NaN
 *   return value
 * })
 * console.log(decoded) // Expect: [ NaN ]
 * ```
 *
 * Simple values can alsoe be encoded.
 *
 * ```typescript
 * const example = [NaN]
 * const encoded = encode(example, (key, value) => {
 *   if (Number.isNaN(value)) return new SimpleValue(100)
 *   return value
 * })
 * console.log(new Uint8Array(encoded)) // Expect: Uint8Array(3) [ 129, 248, 100 ]
 * ```
 */
class SimpleValue {
    static create(value) {
        if (value === undefined)
            return new SimpleValue(23);
        if (value === null)
            return new SimpleValue(22);
        if (value === true)
            return new SimpleValue(21);
        if (value === false)
            return new SimpleValue(20);
        if (typeof value === "number" && value >= 0 && value <= 255) {
            return new SimpleValue(value);
        }
        throw new Error("CBORError: Value out of range or not a simple value.");
    }
    constructor(value) {
        Object.defineProperty(this, "semantic", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        switch (true) {
            case value === 20:
                this.semantic = "false";
                break;
            case value === 21:
                this.semantic = "true";
                break;
            case value === 22:
                this.semantic = "null";
                break;
            case value === 23:
                this.semantic = "undefined";
                break;
            case value > 23 && value < 32:
                this.semantic = "reserved";
                break;
            default:
                this.semantic = "unassigned";
                break;
        }
        this.value = value;
    }
    toPrimitive() {
        switch (this.semantic) {
            case "false":
                return false;
            case "true":
                return true;
            case "null":
                return null;
            case "undefined":
            default:
                return undefined;
        }
    }
}

// deno-lint-ignore-file no-explicit-any
/** Class for structuring a tagged value. Tags which are not JavaScript typed
 * arrays are emitted as an instance of this class during decoding. This allows
 * an application to handle tagged values in the `reviver` function of the
 * decoder. Values which are a valid CBOR type will be decoded and assigned to
 * the `TaggedValue.value` property.
 *
 * ```typescript
 * const { buffer } = new Uint8Array([
 *   0xa1,0x63,0x75,0x72,0x6c,0xd8,0x20,0x70,
 *   0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x73,
 *   0x69,0x74,0x65,0x2e,0x63,0x6f,0x6d,0x2f
 * ])
 * const decoded = decode(buffer, (key, value) => {
 *   if (value instanceof TaggedValue && value.tag === 32) return new URL(value.value)
 *   return value
 * })
 * console.log(decoded) // Expect: { url: URL { href: "http://site.com/" } }
 * ```
 *
 * Use this class when encoding custom tags.
 *
 * ```typescript
 * const tagged = new Map([["url", new URL("http://site.com/")]])
 * const encoded = encode(tagged, (key, value) => {
 *   if (value instanceof URL) return new TaggedValue(value.toString(), 32)
 *   return value
 * })
 * ```
 */
class TaggedValue {
    constructor(value, tag) {
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tag", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.value = value;
        this.tag = tag;
    }
}

// deno-lint-ignore-file no-explicit-any
function decode(data, reviver, cborOptions = {}) {
    const { dictionary, mode } = options(cborOptions);
    const isStrict = mode === "sequence" || mode === "strict";
    const dataView = new DataView(data);
    const ta = new Uint8Array(data);
    let offset = 0;
    let reviverFunction = function (_key, value) {
        return value;
    };
    if (typeof reviver === "function")
        reviverFunction = reviver;
    function commitRead(length, value) {
        offset += length;
        return value;
    }
    function readArrayBuffer(length) {
        return commitRead(length, new Uint8Array(data, offset, length));
    }
    function readFloat16() {
        const tempArrayBuffer = new ArrayBuffer(4);
        const tempDataView = new DataView(tempArrayBuffer);
        const value = readUint16();
        const sign = value & 0x8000;
        let exponent = value & 0x7c00;
        const fraction = value & 0x03ff;
        if (exponent === 0x7c00)
            exponent = 0xff << 10;
        else if (exponent !== 0)
            exponent += (127 - 15) << 10;
        else if (fraction !== 0)
            return (sign ? -1 : 1) * fraction * POW_2_24;
        tempDataView.setUint32(0, (sign << 16) | (exponent << 13) | (fraction << 13));
        return tempDataView.getFloat32(0);
    }
    function readFloat32() {
        return commitRead(4, dataView.getFloat32(offset));
    }
    function readFloat64() {
        return commitRead(8, dataView.getFloat64(offset));
    }
    function readUint8() {
        return commitRead(1, ta[offset]);
    }
    function readUint16() {
        return commitRead(2, dataView.getUint16(offset));
    }
    function readUint32() {
        return commitRead(4, dataView.getUint32(offset));
    }
    function readUint64() {
        return commitRead(8, dataView.getBigUint64(offset));
    }
    function readBreak() {
        if (ta[offset] !== 0xff)
            return false;
        offset += 1;
        return true;
    }
    function readLength(additionalInformation) {
        if (additionalInformation < 24)
            return additionalInformation;
        if (additionalInformation === 24)
            return readUint8();
        if (additionalInformation === 25)
            return readUint16();
        if (additionalInformation === 26)
            return readUint32();
        if (additionalInformation === 27) {
            const integer = readUint64();
            if (integer < POW_2_53)
                return Number(integer);
            return integer;
        }
        if (additionalInformation === 31)
            return -1;
        throw new Error("CBORError: Invalid length encoding");
    }
    function readIndefiniteStringLength(majorType) {
        const initialByte = readUint8();
        if (initialByte === 0xff)
            return -1;
        const length = readLength(initialByte & 0x1f);
        if (length < 0 || initialByte >> 5 !== majorType) {
            throw new Error("CBORError: Invalid indefinite length element");
        }
        return Number(length);
    }
    function appendUtf16Data(utf16data, length) {
        for (let i = 0; i < length; ++i) {
            let value = readUint8();
            if (value & 0x80) {
                if (value < 0xe0) {
                    value = ((value & 0x1f) << 6) | (readUint8() & 0x3f);
                    length -= 1;
                }
                else if (value < 0xf0) {
                    value = ((value & 0x0f) << 12) | ((readUint8() & 0x3f) << 6) |
                        (readUint8() & 0x3f);
                    length -= 2;
                }
                else {
                    value = ((value & 0x0f) << 18) | ((readUint8() & 0x3f) << 12) |
                        ((readUint8() & 0x3f) << 6) | (readUint8() & 0x3f);
                    length -= 3;
                }
            }
            if (value < 0x10000) {
                utf16data.push(value);
            }
            else {
                value -= 0x10000;
                utf16data.push(0xd800 | (value >> 10));
                utf16data.push(0xdc00 | (value & 0x3ff));
            }
        }
    }
    function decodeItem() {
        const initialByte = readUint8();
        const majorType = initialByte >> 5;
        const additionalInformation = initialByte & 0x1f;
        let i;
        let length;
        if (majorType === 7) {
            switch (additionalInformation) {
                case 25:
                    return readFloat16();
                case 26:
                    return readFloat32();
                case 27:
                    return readFloat64();
            }
        }
        length = readLength(additionalInformation);
        if (length < 0 && (majorType < 2 || 6 < majorType)) {
            throw new Error("CBORError: Invalid length");
        }
        switch (majorType) {
            case 0:
                return reviverFunction(EMPTY_KEY, length);
            case 1:
                if (typeof length === "number") {
                    return reviverFunction(EMPTY_KEY, -1 - length);
                }
                return reviverFunction(EMPTY_KEY, -1n - length);
            case 2: {
                if (length < 0) {
                    const elements = [];
                    let fullArrayLength = 0;
                    while ((length = readIndefiniteStringLength(majorType)) >= 0) {
                        fullArrayLength += length;
                        elements.push(readArrayBuffer(length));
                    }
                    const fullArray = new Uint8Array(fullArrayLength);
                    let fullArrayOffset = 0;
                    for (i = 0; i < elements.length; ++i) {
                        fullArray.set(elements[i], fullArrayOffset);
                        fullArrayOffset += elements[i].length;
                    }
                    return reviverFunction(EMPTY_KEY, fullArray);
                }
                return reviverFunction(EMPTY_KEY, readArrayBuffer(length));
            }
            case 3: {
                const utf16data = [];
                if (length < 0) {
                    while ((length = readIndefiniteStringLength(majorType)) >= 0) {
                        appendUtf16Data(utf16data, length);
                    }
                }
                else {
                    appendUtf16Data(utf16data, length);
                }
                let string = "";
                for (i = 0; i < utf16data.length; i += DECODE_CHUNK_SIZE) {
                    string += String.fromCharCode.apply(null, utf16data.slice(i, i + DECODE_CHUNK_SIZE));
                }
                return reviverFunction(EMPTY_KEY, string);
            }
            case 4: {
                let retArray;
                if (length < 0) {
                    retArray = [];
                    let index = 0;
                    while (!readBreak()) {
                        retArray.push(reviverFunction(index++, decodeItem()));
                    }
                }
                else {
                    retArray = new Array(length);
                    for (i = 0; i < length; ++i) {
                        retArray[i] = reviverFunction(i, decodeItem());
                    }
                }
                return reviverFunction(EMPTY_KEY, retArray);
            }
            case 5: {
                if (dictionary === "map") {
                    const retMap = new Map();
                    for (i = 0; i < length || (length < 0 && !readBreak()); ++i) {
                        const key = decodeItem();
                        if (isStrict && retMap.has(key)) {
                            throw new Error("CBORError: Duplicate key encountered");
                        }
                        retMap.set(key, reviverFunction(key, decodeItem()));
                    }
                    return reviverFunction(EMPTY_KEY, retMap);
                }
                const retObject = {};
                for (i = 0; i < length || (length < 0 && !readBreak()); ++i) {
                    const key = decodeItem();
                    if (isStrict &&
                        Object.prototype.hasOwnProperty.call(retObject, key)) {
                        throw new Error("CBORError: Duplicate key encountered");
                    }
                    retObject[key] = reviverFunction(key, decodeItem());
                }
                return reviverFunction(EMPTY_KEY, retObject);
            }
            case 6: {
                const value = decodeItem();
                const tag = length;
                if (value instanceof Uint8Array) {
                    // Handles round-trip of typed arrays as they are a built-in JS language feature.
                    // Similar decision was made for built-in JS language primitives with SimpleValue.
                    const buffer = value.buffer.slice(value.byteOffset, value.byteLength + value.byteOffset);
                    switch (tag) {
                        case kCborTagUint8:
                            return reviverFunction(EMPTY_KEY, new Uint8Array(buffer));
                        case kCborTagInt8:
                            return reviverFunction(EMPTY_KEY, new Int8Array(buffer));
                        case kCborTagUint16:
                            return reviverFunction(EMPTY_KEY, new Uint16Array(buffer));
                        case kCborTagInt16:
                            return reviverFunction(EMPTY_KEY, new Int16Array(buffer));
                        case kCborTagUint32:
                            return reviverFunction(EMPTY_KEY, new Uint32Array(buffer));
                        case kCborTagInt32:
                            return reviverFunction(EMPTY_KEY, new Int32Array(buffer));
                        case kCborTagFloat32:
                            return reviverFunction(EMPTY_KEY, new Float32Array(buffer));
                        case kCborTagFloat64:
                            return reviverFunction(EMPTY_KEY, new Float64Array(buffer));
                    }
                }
                return reviverFunction(EMPTY_KEY, new TaggedValue(value, tag));
            }
            case 7:
                switch (length) {
                    case 20:
                        return reviverFunction(EMPTY_KEY, false);
                    case 21:
                        return reviverFunction(EMPTY_KEY, true);
                    case 22:
                        return reviverFunction(EMPTY_KEY, null);
                    case 23:
                        return reviverFunction(EMPTY_KEY, undefined);
                    default:
                        return reviverFunction(EMPTY_KEY, new SimpleValue(length));
                }
        }
    }
    const ret = decodeItem();
    if (offset !== data.byteLength) {
        if (mode !== "sequence")
            throw new Error("CBORError: Remaining bytes");
        const seq = new Sequence([ret]);
        while (offset < data.byteLength) {
            seq.add(reviverFunction(EMPTY_KEY, decodeItem()));
        }
        return seq;
    }
    return mode === "sequence" ? new Sequence([ret]) : ret;
}
function parse(data, reviver, cborOptions) {
    return decode(data, reviver, cborOptions);
}

// deno-lint-ignore-file no-explicit-any
/**
 * Converts a JavaScript value to a Concise Binary Object Representation (CBOR) buffer.
 *
 * ```typescript
 * const map = new Map<any, any>([[1, 2], ["1", 3000]])
 * const encoded = encode(map)
 * console.log(new Uint8Array(encoded)) // Expect: Uint8Array(8) [ 162,  1,  2,  97, 49, 25, 11, 184 ]
 * ```
 *
 * Add a replacer function - just like `JSON.stringify`.
 *
 * ```typescript
 * const map = new Map<any, any>([[1, 2], ["1", 3000]])
 * const encoded = encode(map, (key, value) => key === "1" ? OMIT_VALUE : value)
 * console.log(new Uint8Array(encoded)) // Expect: Uint8Array(8) [ 161, 1, 2 ]
 * ```
 *
 * @param value - A JavaScript value, usually an object or array, to be converted.
 * @param replacer - A function that alters the behavior of the encoding process,
 * or an array of strings or numbers naming properties of value that should be included
 * in the output. If replacer is null or not provided, all properties of the object are
 * included in the resulting CBOR buffer.
 * @returns The JavaScript value converted to CBOR format.
 */
function encode(value, replacer) {
    let data = new ArrayBuffer(256);
    let dataView = new DataView(data);
    let byteView = new Uint8Array(data);
    let lastLength;
    let offset = 0;
    let replacerFunction = (_key, value) => value;
    if (typeof replacer === "function")
        replacerFunction = replacer;
    if (Array.isArray(replacer)) {
        const exclusive = replacer.slice();
        replacerFunction = (key, value) => {
            if (key === EMPTY_KEY || exclusive.includes(key))
                return value;
            return OMIT_VALUE;
        };
    }
    function prepareWrite(length) {
        let newByteLength = data.byteLength;
        const requiredLength = offset + length;
        while (newByteLength < requiredLength)
            newByteLength <<= 1;
        if (newByteLength !== data.byteLength) {
            const oldDataView = dataView;
            data = new ArrayBuffer(newByteLength);
            dataView = new DataView(data);
            byteView = new Uint8Array(data);
            const uint32count = (offset + 3) >> 2;
            for (let i = 0; i < uint32count; ++i) {
                dataView.setUint32(i << 2, oldDataView.getUint32(i << 2));
            }
        }
        lastLength = length;
        return dataView;
    }
    function commitWrite(..._args) {
        offset += lastLength;
    }
    function writeFloat64(val) {
        commitWrite(prepareWrite(8).setFloat64(offset, val));
    }
    function writeUint8(val) {
        commitWrite(prepareWrite(1).setUint8(offset, val));
    }
    function writeUint8Array(val) {
        prepareWrite(val.length);
        byteView.set(val, offset);
        commitWrite();
    }
    function writeUint16(val) {
        commitWrite(prepareWrite(2).setUint16(offset, val));
    }
    function writeUint32(val) {
        commitWrite(prepareWrite(4).setUint32(offset, val));
    }
    function writeUint64(val) {
        const low = val % POW_2_32;
        const high = (val - low) / POW_2_32;
        const view = prepareWrite(8);
        view.setUint32(offset, high);
        view.setUint32(offset + 4, low);
        commitWrite();
    }
    function writeBigUint64(val) {
        commitWrite(prepareWrite(8).setBigUint64(offset, val));
    }
    function writeVarUint(val, mod) {
        if (val <= 0xff) {
            if (val < 24) {
                writeUint8(Number(val) | mod);
            }
            else {
                writeUint8(0x18 | mod);
                writeUint8(Number(val));
            }
        }
        else if (val <= 0xffff) {
            writeUint8(0x19 | mod);
            writeUint16(Number(val));
        }
        else if (val <= 0xffffffff) {
            writeUint8(0x1a | mod);
            writeUint32(Number(val));
        }
        else {
            writeUint8(0x1b | mod);
            if (typeof val === "number")
                writeUint64(val);
            else
                writeBigUint64(val);
        }
    }
    function writeTypeAndLength(type, length) {
        if (length < 24) {
            writeUint8((type << 5) | length);
        }
        else if (length < 0x100) {
            writeUint8((type << 5) | 24);
            writeUint8(length);
        }
        else if (length < 0x10000) {
            writeUint8((type << 5) | 25);
            writeUint16(length);
        }
        else if (length < 0x100000000) {
            writeUint8((type << 5) | 26);
            writeUint32(length);
        }
        else {
            writeUint8((type << 5) | 27);
            writeUint64(length);
        }
    }
    function writeArray(val) {
        const startOffset = offset;
        const length = val.length;
        let total = 0;
        writeTypeAndLength(4, length);
        const typeLengthOffset = offset;
        for (let i = 0; i < length; i += 1) {
            const result = replacerFunction(i, val[i]);
            if (result === OMIT_VALUE)
                continue;
            encodeItem(result);
            total += 1;
        }
        if (length > total) {
            const encoded = byteView.slice(typeLengthOffset, offset);
            offset = startOffset;
            writeTypeAndLength(4, total);
            writeUint8Array(encoded);
        }
    }
    function writeDictionary(val) {
        const encodedMap = [];
        const startOffset = offset;
        let typeLengthOffset = offset;
        let keyCount = 0;
        let keyTotal = 0;
        if (val instanceof Map) {
            keyCount = val.size;
            writeTypeAndLength(5, keyCount);
            typeLengthOffset = offset;
            for (const [key, value] of val.entries()) {
                const result = replacerFunction(key, value);
                if (result === OMIT_VALUE)
                    continue;
                let cursor = offset;
                encodeItem(key);
                const keyBytes = byteView.slice(cursor, offset);
                cursor = offset;
                encodeItem(result);
                const valueBytes = byteView.slice(cursor, offset);
                keyTotal += 1;
                encodedMap.push([keyBytes, valueBytes]);
            }
        }
        else {
            const keys = Object.keys(val);
            keyCount = keys.length;
            writeTypeAndLength(5, keyCount);
            typeLengthOffset = offset;
            for (let i = 0; i < keyCount; i += 1) {
                const key = keys[i];
                const result = replacerFunction(key, val[key]);
                if (result === OMIT_VALUE)
                    continue;
                let cursor = offset;
                encodeItem(key);
                const keyBytes = byteView.slice(cursor, offset);
                cursor = offset;
                encodeItem(result);
                const valueBytes = byteView.slice(cursor, offset);
                keyTotal += 1;
                encodedMap.push([keyBytes, valueBytes]);
            }
        }
        function sortEncodedKeys(length) {
            offset = startOffset;
            writeTypeAndLength(5, keyTotal);
            encodedMap.sort(([keyA], [keyB]) => lexicographicalCompare(keyA, keyB));
            for (let i = 0; i < length; i += 1) {
                const [encodedKey, encodedValue] = encodedMap[i];
                writeUint8Array(encodedKey);
                writeUint8Array(encodedValue);
            }
        }
        if (keyCount > keyTotal) {
            const encodedMapLength = encodedMap.length;
            if (encodedMapLength > 1) {
                sortEncodedKeys(encodedMapLength);
            }
            else {
                const encoded = byteView.slice(typeLengthOffset, offset);
                offset = startOffset;
                writeTypeAndLength(5, keyTotal);
                writeUint8Array(encoded);
            }
        }
        else {
            const encodedMapLength = encodedMap.length;
            if (encodedMapLength > 1) {
                sortEncodedKeys(encodedMapLength);
            }
        }
    }
    function writeBigInteger(val) {
        let type = 0;
        if (0 <= val && val <= MAX_SAFE_INTEGER) {
            type = 0;
        }
        else if (-MAX_SAFE_INTEGER <= val && val < 0) {
            type = 1;
            val = -(val + 1n);
        }
        else {
            throw new Error("CBORError: Encountered unsafe integer outside of valid CBOR range.");
        }
        if (val < 0x100000000n) {
            return writeTypeAndLength(type, Number(val));
        }
        else {
            writeUint8((type << 5) | 27);
            writeBigUint64(val);
        }
    }
    function encodeItem(val) {
        if (val === OMIT_VALUE)
            return;
        if (val === false)
            return writeUint8(0xf4);
        if (val === true)
            return writeUint8(0xf5);
        if (val === null)
            return writeUint8(0xf6);
        if (val === undefined)
            return writeUint8(0xf7);
        if (objectIs(val, -0))
            return writeUint8Array([0xf9, 0x80, 0x00]);
        switch (typeof val) {
            case "bigint":
                return writeBigInteger(val);
            case "number":
                if (Math.floor(val) === val) {
                    if (0 <= val && val <= POW_2_53)
                        return writeTypeAndLength(0, val);
                    if (-POW_2_53 <= val && val < 0) {
                        return writeTypeAndLength(1, -(val + 1));
                    }
                }
                writeUint8(0xfb);
                return writeFloat64(val);
            case "string": {
                const utf8data = [];
                const strLength = val.length;
                for (let i = 0; i < strLength; ++i) {
                    let charCode = val.charCodeAt(i);
                    if (charCode < 0x80) {
                        utf8data.push(charCode);
                    }
                    else if (charCode < 0x800) {
                        utf8data.push(0xc0 | (charCode >> 6));
                        utf8data.push(0x80 | (charCode & 0x3f));
                    }
                    else if (charCode < 0xd800 || charCode >= 0xe000) {
                        utf8data.push(0xe0 | (charCode >> 12));
                        utf8data.push(0x80 | ((charCode >> 6) & 0x3f));
                        utf8data.push(0x80 | (charCode & 0x3f));
                    }
                    else {
                        charCode = (charCode & 0x3ff) << 10;
                        charCode |= val.charCodeAt(++i) & 0x3ff;
                        charCode += 0x10000;
                        utf8data.push(0xf0 | (charCode >> 18));
                        utf8data.push(0x80 | ((charCode >> 12) & 0x3f));
                        utf8data.push(0x80 | ((charCode >> 6) & 0x3f));
                        utf8data.push(0x80 | (charCode & 0x3f));
                    }
                }
                writeTypeAndLength(3, utf8data.length);
                return writeUint8Array(utf8data);
            }
            default: {
                let converted;
                if (Array.isArray(val)) {
                    writeArray(val);
                } // RFC8746 CBOR Tags
                else if (val instanceof Uint8Array) {
                    writeVarUint(kCborTagUint8, kCborTag << 5);
                    writeTypeAndLength(2, val.length);
                    writeUint8Array(val);
                }
                else if (val instanceof Int8Array) {
                    writeVarUint(kCborTagInt8, kCborTag << 5);
                    writeTypeAndLength(2, val.byteLength);
                    writeUint8Array(new Uint8Array(val.buffer));
                }
                else if (val instanceof Uint16Array) {
                    writeVarUint(kCborTagUint16, kCborTag << 5);
                    writeTypeAndLength(2, val.byteLength);
                    writeUint8Array(new Uint8Array(val.buffer));
                }
                else if (val instanceof Int16Array) {
                    writeVarUint(kCborTagInt16, kCborTag << 5);
                    writeTypeAndLength(2, val.byteLength);
                    writeUint8Array(new Uint8Array(val.buffer));
                }
                else if (val instanceof Uint32Array) {
                    writeVarUint(kCborTagUint32, kCborTag << 5);
                    writeTypeAndLength(2, val.byteLength);
                    writeUint8Array(new Uint8Array(val.buffer));
                }
                else if (val instanceof Int32Array) {
                    writeVarUint(kCborTagInt32, kCborTag << 5);
                    writeTypeAndLength(2, val.byteLength);
                    writeUint8Array(new Uint8Array(val.buffer));
                }
                else if (val instanceof Float32Array) {
                    writeVarUint(kCborTagFloat32, kCborTag << 5);
                    writeTypeAndLength(2, val.byteLength);
                    writeUint8Array(new Uint8Array(val.buffer));
                }
                else if (val instanceof Float64Array) {
                    writeVarUint(kCborTagFloat64, kCborTag << 5);
                    writeTypeAndLength(2, val.byteLength);
                    writeUint8Array(new Uint8Array(val.buffer));
                }
                else if (ArrayBuffer.isView(val)) {
                    converted = new Uint8Array(val.buffer);
                    writeTypeAndLength(2, converted.length);
                    writeUint8Array(converted);
                }
                else if (val instanceof ArrayBuffer ||
                    (typeof SharedArrayBuffer === "function" &&
                        val instanceof SharedArrayBuffer)) {
                    converted = new Uint8Array(val);
                    writeTypeAndLength(2, converted.length);
                    writeUint8Array(converted);
                }
                else if (val instanceof TaggedValue) {
                    writeVarUint(val.tag, 0b11000000);
                    encodeItem(val.value);
                }
                else if (val instanceof SimpleValue) {
                    writeTypeAndLength(7, val.value);
                }
                else if (val instanceof Sequence) {
                    if (offset !== 0) {
                        throw new Error("CBORError: A CBOR Sequence may not be nested.");
                    }
                    const length = val.size;
                    for (let i = 0; i < length; i += 1)
                        encodeItem(val.get(i));
                }
                else {
                    writeDictionary(val);
                }
            }
        }
    }
    encodeItem(replacerFunction(EMPTY_KEY, value));
    if ("slice" in data)
        return data.slice(0, offset);
    const ret = new ArrayBuffer(offset);
    const retView = new DataView(ret);
    for (let i = 0; i < offset; ++i)
        retView.setUint8(i, dataView.getUint8(i));
    return ret;
}
/**
 * Alias of `encode`. Converts a JavaScript value to a Concise Binary Object Representation (CBOR) buffer.
 * @param value - A JavaScript value, usually an object or array, to be converted.
 * @param replacer - A function that alters the behavior of the encoding process,
 * or an array of strings or numbers naming properties of value that should be included
 * in the output. If replacer is null or not provided, all properties of the object are
 * included in the resulting CBOR buffer.
 * @returns The JavaScript value converted to CBOR format.
 */
function binarify(value, replacer) {
    return encode(value, replacer);
}

/**
 * An intrinsic object that provides functions to convert JavaScript values
 * to and from the Concise Binary Object Representation (CBOR) format.
 *
 * ```typescript
 * // Simply a conveniently named-export.
 * CBOR.binarify(...)
 * CBOR.decode(...)
 * CBOR.encode(...)
 * CBOR.parse(...)
 * ```
 */
const CBOR$1 = {
    binarify,
    decode,
    encode,
    parse,
};

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/** @internal */
class CBOR {
    /** @internal */
    static encode(data) {
        const arrayBuffer = CBOR$1.encode(data);
        return new Uint8Array(arrayBuffer);
    }
    /** @internal */
    static decode(data, reviver) {
        const arrayBuffer = data.buffer;
        return CBOR$1.decode(arrayBuffer, reviver);
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/**
 * Represents a unique identifier for a {@link Document}.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class DocumentID {
    /**
     * Returns the value of the receiver, lazily decoded from its CBOR
     * representation if needed.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get value() {
        let value = this['@ditto.value'];
        if (typeof value === 'undefined') {
            value = CBOR.decode(this['@ditto.cbor']);
            this['@ditto.value'] = value;
        }
        return value;
    }
    /**
     * Creates a new `DocumentID`.
     *
     * A document ID can be created from any of the following:
     *
     * - `string`
     * - `number` (integer)
     * - `boolean`
     * - `null`
     * - raw data in the form of a JS [Typed Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays)
     * - `Array` (containing any of the items in this list)
     * - Map (a raw JS `object`, where the keys must be strings and the values
     *   can be made up of any of the items in this list)
     *
     * Note that you cannot use floats or other custom types to create a document
     * ID.
     *
     * Document IDs are also limited in size, based on their serialized
     * representation, to 256 bytes. You will receive an error if you try to
     * create a document ID that exceeds the size limit.
     *
     * @param value The value that represents the document identifier.
     * @param skipCBOREncoding If `true, skips CBOR encoding and assumes
     * the passed in `value` is already CBOR encoded. You shouldn't need to ever
     * pass this parameter, it's only used internally for certain edge cases.
     * @param skipValidation If `true, skips validation of the passed in value or
     * CBOR. You shouldn't need to ever pass this parameter, it's only used
     * internally for certain edge cases.
     */
    constructor(value, skipCBOREncoding = false, skipValidation = false) {
        const cbor = skipCBOREncoding ? value : CBOR.encode(value);
        const validatedCBOR = skipValidation ? cbor : validateDocumentIDCBOR(cbor);
        if (!validatedCBOR) {
            throw new Error(`Can't create DocumentID, passed in value is not valid: ${value}`);
        }
        this.isValidated = !skipValidation;
        this['@ditto.cbor'] = validatedCBOR;
    }
    /**
     * Returns `true` if passed in `documentID` is equal to the receiver,
     * otherwise returns `false`.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    equals(documentID) {
        const left = this['@ditto.cbor'];
        const right = documentID['@ditto.cbor'];
        if (left === right)
            return true;
        if (!(left instanceof Uint8Array))
            return false;
        if (!(right instanceof Uint8Array))
            return false;
        if (left.length !== right.length)
            return false;
        for (let i = 0; i < left.length; i += 1)
            if (left[i] !== right[i])
                return false;
        return true;
    }
    /**
     * Returns a string representation of the receiver.
     *
     * If you need a string representation to be used directly in a query,
     * please use `toQueryCompatibleString()` instead.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    toString() {
        return documentIDQueryCompatible(this['@ditto.cbor'], 'WithoutQuotes');
    }
    /**
     * Returns the base64-encoded CBOR representation of this document ID.
     *
     * @deprecated
     */
    toBase64String() {
        return mapFFIErrors(() => base64encode(this['@ditto.cbor'], 'Padded'));
    }
    /**
     * Returns a query compatible string representation of the receiver.
     *
     * The returned string can be used directly in queries that you use with other
     * Ditto functions. For example you could create a query that was like this:
     *
     *  ``` TypeScript
     *  collection.find(`_id == ${documentID.toQueryCompatibleString()}`)
     *  ```
     *
     * @deprecated use document IDs in queries by embedding them in the query
     * arguments parameter.
     */
    toQueryCompatibleString() {
        return documentIDQueryCompatible(this['@ditto.cbor'], 'WithQuotes');
    }
    /** @internal */
    toCBOR() {
        return this['@ditto.cbor'];
    }
}
// -----------------------------------------------------------------------------
/** @internal */
function validateDocumentIDValue(id) {
    if (typeof id === 'undefined')
        throw new Error(`Invalid document ID: ${id}`);
    return id;
}
/** @internal */
function validateDocumentIDCBOR(idCBOR) {
    const validatedIDCBOROrNull = validateDocumentID(idCBOR);
    return validatedIDCBOROrNull !== null && validatedIDCBOROrNull !== void 0 ? validatedIDCBOROrNull : idCBOR;
}

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
var _a;
// REFACTOR: tweak the API to use Rust concepts of ownership. For example,
// register() could be named something like yieldOwnership() while unregister()
// be named takeOwnership() and return the taken pointer. See discussion here:
// https://dittolive.slack.com/archives/C01NLL95095/p1618311222027700?thread_ts=1618308918.024500&cid=C01NLL95095
// Add bridged type name to debug, for example 'Ditto'.
const DEBUG_TYPE_NAMES = [];
const DEBUG_ALL_TYPES = false;
/**
 * A handle serves as a safe wrapper around a pointer to a native object.
 *
 * A bridge keeps track of all handles that have been created on its
 * {@link Bridge.handlesByAddress | `handlesByAddress`} property, which allows
 * enumerating all objects that are currently managed by the bridge.
 *
 * @internal */
class Handle {
    /**
     * Warning: Do not call this constructor directly. Use
     * {@link Bridge.handleFor | `Bridge.<type>.handleFor()`} instead.
     *
     * @internal
     */
    constructor(bridge, object, pointer) {
        this.isClosed = false;
        this.isFinalized = false;
        this.isUnregistered = false;
        this.bridge = bridge;
        this.objectWeakRef = new WeakRef(object);
        this.pointer = pointer;
    }
    /** The type of this handle's bridge */
    get type() {
        return this.bridge.type;
    }
    /**
     * Returns the pointer associated with this handle.
     *
     * @throws {Error} if the object has already been closed, garbage collected,
     * or unregistered from the bridge.
     */
    deref() {
        if (this.isClosed) {
            throw new Error(`Bridging error: can't get pointer for an object that has been closed.`);
        }
        if (this.isFinalized) {
            throw new Error(`Bridging error: can't get pointer for an object that has been finalized.`);
        }
        if (this.isUnregistered) {
            throw new Error(`Bridging error: can't get pointer for an object that has been unregistered.`);
        }
        return this.pointer;
    }
    /**
     * Returns the pointer associated with this handle or `null` if the object
     * has been closed, garbage collected, or unregistered.
     */
    derefOrNull() {
        var _b;
        if (this.isClosed)
            return null;
        if (this.isFinalized)
            return null;
        if (this.isUnregistered)
            return null;
        return (_b = this.pointer) !== null && _b !== void 0 ? _b : null;
    }
    /**
     * Returns the object associated with this handle.
     *
     * @throws {Error} if the object has been closed, unregistered, or garbage collected,
     * closed or unregistered.
     */
    object() {
        const object = this.objectWeakRef.deref();
        if (object == null) {
            throw new Error(`Bridging error: ${this.bridge.type.name} object has been garbage collected.`);
        }
        if (this.isClosed) {
            throw new Error(`Bridging error: ${this.bridge.type.name} object has been closed.`);
        }
        if (this.isUnregistered) {
            throw new Error(`Bridging error: ${this.bridge.type.name} object has been unregistered.`);
        }
        return object;
    }
    /**
     * Returns the object associated with this handle or `null` if the object
     * has been closed, unregistered, or garbage collected.
     */
    objectOrNull() {
        var _b;
        return (_b = this.objectWeakRef.deref()) !== null && _b !== void 0 ? _b : null;
    }
    /** @internal */
    toString() {
        const pointer = this.derefOrNull();
        return `{ Handle | type: ${this.bridge.type}, object: ${this.objectWeakRef.deref()}, FFI address: ${pointer === null || pointer === void 0 ? void 0 : pointer.addr}, FFI type: ${pointer === null || pointer === void 0 ? void 0 : pointer.type} }`;
    }
    /** @internal */
    bridgeWillClose() {
        // @ts-expect-error setting readonly property
        this.isClosed = true;
    }
    /** @internal */
    bridgeDidClose() {
        // @ts-expect-error setting readonly property
        this.pointer = null;
    }
    /** @internal */
    bridgeWillFinalize() {
        // @ts-expect-error setting readonly property
        this.isFinalized = true;
    }
    /** @internal */
    bridgeDidFinalize() {
        // @ts-expect-error setting readonly property
        this.pointer = null;
    }
    /** @internal */
    bridgeWillUnregister() {
        // @ts-expect-error setting readonly property
        this.isUnregistered = true;
    }
    /** @internal */
    bridgeDidUnregister() {
        // @ts-expect-error setting readonly property
        this.pointer = null;
    }
}
/**
 * Use this for passing arrays of pointers to the FFI.
 */
// REFACTOR: Use an iterator instead of an array to deref handles lazily.
class Handles {
    /**
     * @throws {Error} if any of the objects are not registered in the bridge.
     * @throws {Error} if any of the objects have already been garbage collected.
     */
    constructor(bridge, objects) {
        this.handles = objects.map((object) => bridge.handleFor(object));
    }
    deref() {
        return this.handles.map((handle) => handle.deref());
    }
}
/**
 * A bridge manages memory allocated by the FFI that is used in the JS SDK.
 *
 * The main purpose of a bridge is keeping track of JavaScript objects that
 * require access to memory allocated by the FFI. When such objects are
 * garbage collected in JavaScript, the bridge instructs the FFI to free the
 * corresponding memory. Every managed memory pointer corresponds to exactly
 * one JS Object.
 *
 * There is a static `Bridge` instance for every class of objects that can be
 * managed:
 *
 * - {@link Attachment}: `Bridge.attachment`
 * - {@link Ditto}: `Bridge.ditto`
 * - {@link Document}: `Bridge.document`
 * - {@link MutableDocument}: `Bridge.mutableDocument`
 *
 * Use `Bridge.<type>.handleFor()` to obtain a handle, which is a wrapper around
 * the raw pointer, and `Bridge.<type>.bridge()` to get or create the matching
 * object for a memory address.
 *
 * @internal */
class Bridge {
    /**
     * Creates a new bridge for objects of `type`. Requires a `release` function
     * that is called whenever a registered object is garbage collected, passing
     * the associated `pointer` to it. The release function is then responsible
     * to free or drop the corresponding native object.
     *
     * **IMPORTANT**: The `type` of all bridges needs to be set in `epilogue.ts`
     * after initiating the bridge instance. This helps avoid import cycles
     * (otherwise anything importing the bridge instance, would also have to
     * import the type, which usually leads to import cycles).
     *
     * @private
     */
    constructor(release) {
        // ------ Private ------
        this.internalType = null;
        this.release = release;
        this.handlesByAddress = {};
        this.handlesByObject = new WeakMap();
        this.finalizationRegistry = new FinalizationRegistry(this.finalize.bind(this));
        _a.all.push(new WeakRef(this));
    }
    /**
     * The type of a bridge is the JavaScript `Class` of objects it represents.
     *
     * @internal */
    get type() {
        if (this.internalType == null)
            throw new Error('Bridge type has not been registered yet.');
        return this.internalType;
    }
    /**
     * All bridges' types have to be registered in `epilogue.ts` before using
     * them.
     *
     * @internal */
    registerType(value) {
        if (this.internalType === value) {
            // Nothing to do.
            return;
        }
        if (this.internalType) {
            throw new Error(`Can't register bridged type '${value.name}', another type was already registered: ${this.internalType}`);
        }
        this.internalType = value;
    }
    /**
     * Returns the handle for a bridged object.
     *
     * Use `handle.deref()` to get the pointer for the object at the time of use.
     *
     * @throws {Error} if the object is not registered.
     *
     * @internal
     */
    handleFor(object) {
        const handle = this.handlesByObject.get(object);
        if (handle == null) {
            throw new Error(`Bridging error: ${this.type.name} object is not currently registered in this bridge.`);
        }
        return handle;
    }
    /**
     * Returns a `Handles` instance for an array of objects.
     *
     * @internal
     */
    handlesFor(objects) {
        return new Handles(this, objects);
    }
    /**
     * Convenience method, returns the object for the FFI `pointer` if registered,
     * otherwise returns `undefined`. If the object associated with the `pointer`
     * has been unregistered before, returns `undefined`, too.
     *
     * @internal
     */
    objectFor(pointer) {
        const handle = this.handlesByAddress[pointer.addr];
        if (!handle)
            return undefined;
        if (handle.type !== this.type) {
            throw new Error(`Can't return object for pointer, pointer is associated with an object of type ${handle.type} but this bridge is configured for ${this.type}`);
        }
        // This throws an error if the object has been garbage collected but the
        // finalizer has not been called yet.
        return handle.object();
    }
    /**
     * Returns the object for the FFI `pointer` if registered. Otherwise, calls
     * the passed in `create` function to create a new object, which it then
     * returns after registering. If no `create` function is given, uses the
     * type of the bridge as a constructor and creates a new instance of it
     * without passing any parameters.
     *
     * @param pointer reference to the FFi instance for the object
     * @param objectOrCreate can either be the JS object, or a function that returns the instance when called. If undefined, an object is created based on the Bridge type.
     * @throws {Error} if `objectOrCreate` is a function that returns an object that is not an instance of the bridge's type.
     * @internal
     */
    bridge(pointer, objectOrCreate) {
        const existingObject = this.objectFor(pointer);
        if (existingObject)
            return existingObject;
        if (!objectOrCreate) {
            objectOrCreate = () => {
                return Reflect.construct(this.type, []);
            };
        }
        let object;
        if (typeof objectOrCreate === 'function') {
            object = objectOrCreate();
            if (!(object instanceof this.type)) {
                throw new Error(`Can't bridge, expected passed in create function to return a ${this.type.name} object but got: ${object}`);
            }
        }
        else {
            object = objectOrCreate;
        }
        this.register(object, pointer);
        return object;
    }
    /**
     * Registers an instance in this bridge's {@link FinalizationRegistry}.
     *
     * This causes the FFI to drop the memory linked to the object as soon as it
     * is garbage collected in JavaScript.
     *
     * If you want to control the order with which a number of objects' memory is
     * dropped, use {@link Bridge.unregister | Bridge.unregister()}
     *
     * @private */
    register(object, pointer) {
        const objectType = object.constructor;
        if (objectType !== this.type) {
            throw new Error(`Can't register, bridge is configured for type ${this.type.name} but passed in object is of type ${objectType.name}`);
        }
        const existingHandle = this.handlesByObject.get(object);
        const existingPointer = existingHandle ? existingHandle.pointer : null;
        // Check that both pointer and handle are undefined at this point.
        if (existingPointer != null && existingHandle != null) {
            throw new Error(`Can't register, an object for the passed in pointer has previously been registered: ${existingHandle.object()}`);
        }
        if (existingPointer != null && existingHandle == null) {
            throw new Error(`Internal inconsistency, trying to register an object which has an associated pointer but no handle entry: ${objectType.name} at ${existingPointer.type} ${existingPointer.addr}`);
        }
        if (existingPointer == null && existingHandle != null) {
            throw new Error(`Internal inconsistency, trying to register an object which has a handle entry but no associated pointer: ${objectType.name} ${object}`);
        }
        const handle = new Handle(this, object, pointer);
        this.handlesByAddress[pointer.addr] = handle;
        this.handlesByObject.set(object, handle);
        this.finalizationRegistry.register(object, handle, object);
        if (DEBUG_TYPE_NAMES.includes(this.type.name) || DEBUG_ALL_TYPES) {
            Logger.debug(`[VERBOSE] Bridge REGISTERED a new instance of ${this.type.name}, current count: ${Object.keys(this.handlesByAddress).length}`);
        }
    }
    /**
     * Removes an instance from this bridge's {@link FinalizationRegistry}.
     *
     * This lets you control the order with which memory is dropped in the FFI.
     * After calling this function, manually call the FFI function to drop the
     * memory then finally delete the JavaScript instance.
     *
     * @internal */
    unregister(object) {
        const objectType = object.constructor;
        const bridgeType = this.type;
        if (objectType !== bridgeType) {
            throw new Error(`Can't unregister, bridge is configured for type ${bridgeType.name} but passed in object is of type ${objectType.name}`);
        }
        const handle = this.handlesByObject.get(object);
        if (handle == null) {
            throw new Error(`Can't unregister, object has not been registered before: ${object}`);
        }
        if (handle.type !== bridgeType) {
            throw new Error(`Internal inconsistency, trying to unregister an object that has a handle with a different type than that of the bridge: ${handle}`);
        }
        if (handle.objectOrNull() !== object) {
            throw new Error(`Internal inconsistency, trying to unregister an object whose associated handle holds a different object: ${handle}`);
        }
        if (handle.isClosed) {
            throw new Error(`Can't unregister, object has been closed before: ${object}`);
        }
        if (handle.isFinalized) {
            throw new Error(`Can't unregister, object has been finalized before: ${object}`);
        }
        if (handle.isUnregistered) {
            throw new Error(`Can't unregister, object has been unregistered already: ${object}`);
        }
        handle.bridgeWillUnregister();
        this.finalizationRegistry.unregister(object);
        delete this.handlesByAddress[handle.pointer.addr];
        this.handlesByObject.delete(object);
        handle.bridgeDidUnregister();
        if (DEBUG_TYPE_NAMES.includes(this.type.name) || DEBUG_ALL_TYPES) {
            Logger.debug(`[VERBOSE] Bridge UNREGISTERED an instance of ${this.type.name}, current count: ${Object.keys(this.handlesByAddress).length}`);
        }
    }
    /** @internal */
    unregisterAll() {
        if (DEBUG_TYPE_NAMES.includes(this.type.name) || DEBUG_ALL_TYPES) {
            Logger.debug(`[VERBOSE] Unregistering ALL bridged instances of type ${this.type.name}.`);
        }
        for (const handle of Object.values(this.handlesByAddress)) {
            const object = handle.object();
            if (object)
                this.unregister(object);
        }
    }
    /**
     * Closes the object by calling `release()` and `null`-ing its pointer, such
     * that its handle can't be `deref()`-ed afterwards.
     *
     * @internal */
    async close(object) {
        const objectType = object.constructor;
        const bridgeType = this.type;
        if (objectType !== bridgeType) {
            throw new Error(`Can't close, bridge is configured for type ${bridgeType.name} but passed in object is of type ${objectType.name}`);
        }
        const handle = this.handlesByObject.get(object);
        if (handle == null) {
            throw new Error(`Can't close an object that has not been registered before: ${object}`);
        }
        if (handle.type !== bridgeType) {
            throw new Error(`Internal inconsistency, trying to close an object that has a handle with a different type than that of the bridge: ${handle}`);
        }
        if (handle.isUnregistered)
            throw new Error(`Can't close object, object has been unregistered.`);
        if (handle.isFinalized) {
            throw new Error(`Internal inconsistency, trying to close an object that has already been finalized.`);
        }
        if (handle.isClosed)
            return;
        const pointer = handle.pointer;
        if (!pointer) {
            throw new Error(`Internal inconsistency, trying to close an object whose pointer is null.`);
        }
        handle.bridgeWillClose();
        delete this.handlesByAddress[pointer.addr];
        await this.release(pointer);
        handle.bridgeDidClose();
        if (DEBUG_TYPE_NAMES.includes(this.type.name) || DEBUG_ALL_TYPES) {
            Logger.debug(`[VERBOSE] Bridge CLOSED an instance of ${this.type.name}, current count: ${Object.keys(this.handlesByAddress).length}`);
        }
    }
    /** @internal */
    get count() {
        return Object.keys(this.handlesByAddress).length;
    }
    async finalize(handle) {
        if (handle.isFinalized) {
            throw new Error(`Internal inconsistency, trying to finalize an object that has already been finalized.`);
        }
        if (handle.isUnregistered) {
            throw new Error(`Internal inconsistency, trying to finalize an object that has been unregistered before.`);
        }
        handle.bridgeWillFinalize();
        if (!handle.isClosed) {
            const pointer = handle.pointer;
            if (!pointer) {
                throw new Error(`Internal inconsistency, trying to finalize an object whose pointer is null.`);
            }
            delete this.handlesByAddress[pointer.addr];
            await this.release(pointer);
        }
        handle.bridgeDidFinalize();
        if (DEBUG_TYPE_NAMES.includes(this.type.name) || DEBUG_ALL_TYPES) {
            Logger.debug(`[VERBOSE] Bridge FINALIZED an instance of ${this.type.name}, current count: ${Object.keys(this.handlesByAddress).length}`);
        }
    }
}
_a = Bridge;
/**
 * Keeps track of all bridges for debugging and test purposes. With this, we
 * can iterate over all bridges and make sure everything is deallocated after
 * a test, or a suite of tests, has run.
 *
 * @internal */
Bridge.all = [];
/** @internal */
Bridge.attachment = new _a(freeAttachmentHandle);
/** @internal */
Bridge.connectionRequest = new _a(connectionRequestFree);
/** @internal */
Bridge.document = new _a(documentFree);
/** @internal */
Bridge.mutableDocument = new _a(documentFree);
/** @internal */
Bridge.queryResult = new _a(queryResultFree);
/** @internal */
Bridge.queryResultItem = new _a(queryResultItemFree);
/** @internal */
Bridge.transaction = new _a(transactionFree);
/** @internal */
Bridge.differ = new _a(differFree);
/** @internal */
Bridge.ditto = new _a(async (dittoPointer) => {
    // HACK: quick and dirty, clear all presence callbacks. This covers presence
    // v1 and v2 callbacks. v3 should be cleared properly by the `Presence`
    // class itself.
    await dittoClearPresenceCallback(dittoPointer);
    await dittoShutdown(dittoPointer);
    dittoFree(dittoPointer);
});

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/**
 * Represents an attachment and can be used to insert the associated attachment
 * into a document at a specific key-path. You can't instantiate an attachment
 * directly, please use the
 * {@link Store.newAttachment | ditto.store.newAttachment()} method instead.
 */
class Attachment {
    /** The attachment's ID. */
    get id() {
        return this.token.id;
    }
    /** The attachment's size given as number of bytes. */
    get len() {
        return this.token.len;
    }
    /** The attachment's metadata. */
    get metadata() {
        return this.token.metadata;
    }
    /**
     * Returns the attachment's data.
     */
    data() {
        return this.ditto.deferCloseAsync(async (dittoHandle) => {
            {
                const attachmentHandle = Bridge.attachment.handleFor(this);
                const attachmentPath = dittoGetCompleteAttachmentPath(dittoHandle.deref(), attachmentHandle.deref());
                const fs = require('fs').promises;
                return await fs.readFile(attachmentPath);
            }
        });
    }
    /**
     * Returns the attachment's data.
     *
     * @deprecated Use `data()` instead.
     */
    getData() {
        return this.data();
    }
    /**
     * Copies the attachment to the specified file path.
     *
     * **React Native:**
     * - **Relative paths** (e.g., `"data/file.txt"`) are automatically prefixed with
     *   `ditto.absolutePersistenceDirectory`, resulting in `${persistenceDir}/data/file.txt`
     * - **Absolute paths** (e.g., `"/Users/me/file.txt"`) are used as-is without modification
     *
     * **Node.js:**
     * - Relative paths are resolved relative to the current working directory
     *
     * This method throws an error when running in the browser.
     *
     * @param path The path where the attachment should be copied.
     */
    copyToPath(path) {
        return this.ditto.deferCloseAsync(async (dittoHandle) => {
            {
                const attachmentHandle = Bridge.attachment.handleFor(this);
                const attachmentPath = dittoGetCompleteAttachmentPath(dittoHandle.deref(), attachmentHandle.deref());
                const fs = require('fs').promises;
                // If the file already exists, we fail. This is the same behavior as
                // for the Swift/ObjC SDK.
                await fs.copyFile(attachmentPath, path, fs.COPYFILE_EXCL);
            }
        });
    }
    /** @internal */
    constructor(ditto, token) {
        this.ditto = ditto;
        this.token = token;
    }
}
/**
 * Validates the given attachment metadata. Metadata must be a flat object with
 * string values.
 *
 * This should really happen in core to make sure we use the same validation
 * logic across SDKs but we decided to postpone that for the next iteration on
 * attachments.
 *
 * @throws {@link DittoError} 'store/failed-to-create-attachment'
 * @internal
 */
function validateAttachmentMetadata(metadata) {
    if (typeof metadata !== 'object') {
        throw new DittoError('store/failed-to-create-attachment', `Invalid attachment metadata: expected a value of type object but got ${typeof metadata}.`);
    }
    for (const key in metadata) {
        if (typeof metadata[key] !== 'string') {
            throw new DittoError('store/failed-to-create-attachment', `Invalid attachment metadata: metadata values must be strings but key '${key}' has a value of type ${typeof metadata[key]}.`);
        }
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
// NOTE: proxy was originally written in pure JS rather than TypeScript. We'll
// gradually port it to TypeScript and until done, we've renamed the pure JS
// file to proxy.raw.js and introduced proxy.ts that'll contain all parts ported
// to TypeScript or type declarations for the JS parts.
// import * as proxyRaw from './proxy.raw'
// Takes an annotated JSON representation of a document (see CRDT's Document
// class for more info about what an annotated representation is) and turns it
// into a JavaScript-appropriate version. This means that counters get
// represented by `Counter` objects and attachments get represented by
// `Attachment` objects.
function augmentJSONValue(json, mutDoc, workingPath) {
    if (json && typeof json === 'object') {
        if (Array.isArray(json)) {
            return json.map((v, idx) => augmentJSONValue(v, mutDoc, `${workingPath}[${idx}]`));
        }
        else if (json[DittoCRDTTypeKey] === DittoCRDTType.counter) {
            return Counter['@ditto.create'](mutDoc, workingPath, json[DittoCRDTValueKey]);
        }
        else if (json[DittoCRDTTypeKey] === DittoCRDTType.register) {
            return Register['@ditto.create'](mutDoc, workingPath, json[DittoCRDTValueKey]);
        }
        else if (json[DittoCRDTTypeKey] === DittoCRDTType.attachment) {
            return new AttachmentToken(json);
        }
        else {
            for (const [key, value] of Object.entries(json))
                json[key] = augmentJSONValue(value, mutDoc, `${workingPath}['${key}']`);
            return json;
        }
    }
    else {
        return json;
    }
}
/**
 * Converts objects that may contain instances of classes of this SDK, i.e.
 * `DocumentID`, `Counter`, `Register` and `Attachment`, into plain JS objects
 * that can be passed to the FFI layer.
 *
 * WARNING: For attachments in the input, the output can contain `BigInt`
 * values, which are not JSON-compatible.
 *
 * @throws {Error} If `jsObj` contains a non-finite float value.
 */
function desugarJSObject(jsObj) {
    if (jsObj && typeof jsObj === 'object') {
        if (Array.isArray(jsObj)) {
            return jsObj.map((v, idx) => desugarJSObject(v));
        }
        else if (jsObj instanceof DocumentID) {
            return jsObj.value;
        }
        else if (jsObj instanceof Counter) {
            const counterJSON = {};
            counterJSON[DittoCRDTTypeKey] = DittoCRDTType.counter;
            counterJSON[DittoCRDTValueKey] = jsObj.value;
            return counterJSON;
        }
        else if (jsObj instanceof Register) {
            const registerJSON = {};
            registerJSON[DittoCRDTTypeKey] = DittoCRDTType.register;
            registerJSON[DittoCRDTValueKey] = jsObj.value;
            return registerJSON;
        }
        else if (jsObj instanceof Attachment) {
            const attachmentJSON = {
                _id: jsObj.token.idBytes,
                _len: jsObj.token.len, // may be a BigInt
                _meta: jsObj.token.metadata,
            };
            attachmentJSON[DittoCRDTTypeKey] = DittoCRDTType.attachment;
            return attachmentJSON;
        }
        else {
            // Create a copy to not mutate the original object
            const jsObjJSON = {};
            for (const [key, value] of Object.entries(jsObj))
                jsObjJSON[key] = desugarJSObject(value);
            return jsObjJSON;
        }
    }
    else {
        checkForUnsupportedValues(jsObj);
        return jsObj;
    }
}
/**
 * Throws an error if input is a non-finite float value.
 *
 * Workaround while we don't have a reliable way of receiving error messages
 * from `dittoCore.ditto_collection_insert_value()`.
 *
 * See https://github.com/getditto/ditto/issues/8657 for details.
 *
 * @param jsObj The object to check.
 * @throws {Error} If `jsObj` is a non-finite float value.
 */
function checkForUnsupportedValues(jsObj) {
    if (Number.isNaN(jsObj) || jsObj === Infinity || jsObj === -Infinity)
        throw new Error('Non-finite float values are not supported');
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/**
 * Provides information about a successful update operation on a document.
 *
 * The update result can be one of the following types:
 *   - `set`
 *   - `removed`
 *   - `incremented`
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class UpdateResult {
    // ----------------------------------------------------------- Internal ------
    /** @internal */
    static set(docID, path, value) {
        return new UpdateResult('set', docID, path, value, undefined);
    }
    /** @internal */
    static incremented(docID, path, amount) {
        return new UpdateResult('incremented', docID, path, undefined, amount);
    }
    /** @internal */
    static removed(docID, path) {
        return new UpdateResult('removed', docID, path, undefined, undefined);
    }
    /** @internal */
    constructor(type, docID, path, value, amount) {
        this.type = type;
        this.docID = docID;
        this.path = path;
        if (value !== undefined)
            this.value = value;
        if (amount !== undefined)
            this.amount = amount;
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
// ------------------------------------------------------------ Constants ------
const defaultDittoCloudDomain = `cloud.ditto.live`;
// ------------------------------------------------------------- Defaults ------
/** @internal */
function defaultAuthURL(appID) {
    return `https://${appID}.${defaultDittoCloudDomain}`;
}
// ---------------------------------------------------------- Validations ------
/**
 * Validates a number and returns it as-is if all requirements are met,
 * otherwise throws an exception. Options:
 *
 * - `integer`: if `true`, requires the number to be an integer
 *
 * - `min`: if given, requires the number to be >= `min`
 * - `max`: if given, requires the number to be <= `max`
 *
 * - `minX`: if given, requires the number to be > `minX` (x stands for "exclusive")
 * - `maxX`: if given, requires the number to be < `maxX` (x stands for "exclusive")
 *
 * You can also customize the error message by providing a prefix via
 * `errorMessagePrefix`, which defaults to `"Number validation failed:"`.
 *
 * @internal
 * @deprecated
 */
function validateNumber(value, options = {}) {
    var _a;
    const errorMessagePrefix = (_a = options['errorMessagePrefix']) !== null && _a !== void 0 ? _a : 'Number validation failed:';
    const integer = !!options['integer'];
    const min = options['min'];
    const max = options['max'];
    const minX = options['minX'];
    const maxX = options['maxX'];
    if (typeof value !== 'number')
        throw new Error(`${errorMessagePrefix} '${value}' is not a number.`);
    if (integer && Math.floor(value) !== value)
        throw new Error(`${errorMessagePrefix} '${value}' is not an integer.`);
    if (typeof min !== 'undefined' && value < min)
        throw new Error(`${errorMessagePrefix} '${value}' must be >= ${min}.`);
    if (typeof max !== 'undefined' && value > max)
        throw new Error(`${errorMessagePrefix} '${value}' must be <= ${max}.`);
    if (typeof minX !== 'undefined' && value <= minX)
        throw new Error(`${errorMessagePrefix} '${value}' must be > ${minX}.`);
    if (typeof maxX !== 'undefined' && value >= maxX)
        throw new Error(`${errorMessagePrefix} '${value}' must be < ${maxX}.`);
    return value;
}
/** @deprecated */
function validateQuery(query, options = {}) {
    var _a;
    const errorMessagePrefix = (_a = options['errorMessagePrefix']) !== null && _a !== void 0 ? _a : 'Query validation failed,';
    if (typeof query !== 'string')
        throw new Error(`${errorMessagePrefix} query is not a string: ${query}`);
    if (query === '')
        throw new Error(`${errorMessagePrefix} query is an empty string.`);
    const validatedQuery = query.trim();
    if (validatedQuery === '') {
        throw new Error(`${errorMessagePrefix} query contains only whitespace characters.`);
    }
    return validatedQuery;
}
// -------------------------------------------------------------- Helpers ------
/**
 * Can be used to implement a custom Node.js `inspect` representation for
 * objects that have a `value` property.
 *
 * Node.js < 16.14.0 and Electron < 19.0.0 do not provide the `inspect`
 * parameter used below, which is when we fall back to `JSON.stringify`.
 *
 * See https://nodejs.org/api/util.html#custom-inspection-functions-on-objects
 */
function customInspectRepresentation(documentLike, inspect) {
    if (inspect === undefined)
        return `${documentLike.constructor.name} ${JSON.stringify({ value: documentLike.value }, null, 2)}`;
    return `${documentLike.constructor.name} ${inspect({ value: documentLike.value })}`;
}
// --------------------------------------------------------------- System ------
/** @internal */
function sleep(milliseconds) {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, milliseconds);
    });
}
/** @internal use this to asyncify chunks of code. */
async function step(closure) {
    await sleep(0);
    return closure();
}
/** @internal */
// WORKAROUND: the corresponding FFI function(s) is not async at the
// moment, we therefore artificially make it async via step() until an
// async variant becomes available.
//
// Why? Any function marked as async that isn't under the hood appears to be
// yield-ing on the use site but isn't. This may lead to blocking the
// event loop for a long time, which in turn can lead to excessive memory
// consumption and other side-effects. Plus, WebAssembly limitations may
// lead to deadlocks and other crashes.
//
// The function alias here is to be able to easily see that its use is
// a workaround, plus easily finding all of those workarounds to fix
// them all once the FFI API is properly asyncified.
//
// See PR #4833 for details:
// https://github.com/getditto/ditto/pull/4833
const performAsyncToWorkaroundNonAsyncFFIAPI = step;
function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
const regularKeyPattern = /\.([A-Za-z_]\w*)/.source;
const subscriptIndexPattern = /\[(\d+)\]/.source;
const subscriptSingleQuoteKeyPattern = /\[\'(.+?)\'\]/.source;
const subscriptDoubleQuoteKeyPattern = /\[\"(.+?)\"\]/.source;
const validKeyPathPattern = `((${regularKeyPattern})|(${subscriptIndexPattern})|(${subscriptSingleQuoteKeyPattern})|(${subscriptDoubleQuoteKeyPattern}))*`;
const regularKeyRegExp = new RegExp(`^${regularKeyPattern}`);
const subscriptIndexRegExp = new RegExp(`^${subscriptIndexPattern}`);
const subscriptSingleQuoteKeyRegExp = new RegExp(`^${subscriptSingleQuoteKeyPattern}`);
const subscriptDoubleQuoteKeyRegExp = new RegExp(`^${subscriptDoubleQuoteKeyPattern}`);
const validKeyPathRegExp = new RegExp(`^${validKeyPathPattern}$`);
/**
 * Namespace for key-path related functions.
 * @internal
 */
class KeyPath {
    /**
     * Returns the key-path by prefixing it with a leading dot if first key
     * starts with a character or an underscore.
     */
    static withLeadingDot(keyPath) {
        if (typeof keyPath === 'number')
            return keyPath;
        if (typeof keyPath !== 'string') {
            throw new Error(`Key-path must be a string or a number but is ${typeof keyPath}: ${keyPath}`);
        }
        const needsLeadingDot = typeof keyPath === 'string' && !!keyPath.match(/^[A-Za-z_]/);
        return needsLeadingDot ? `.${keyPath}` : keyPath;
    }
    /**
     * Returns the key-path by removing the leading dot if it starts with one.
     */
    static withoutLeadingDot(keyPath) {
        if (typeof keyPath === 'number')
            return keyPath;
        if (typeof keyPath !== 'string') {
            throw new Error(`Key-path must be a string or a number but is ${typeof keyPath}: ${keyPath}`);
        }
        const hasLeadingDot = typeof keyPath === 'string' && !!keyPath.match(/^\./);
        return hasLeadingDot ? keyPath.slice(1) : keyPath;
    }
    /**
     * Validates a key-path by adding a leading dot if appropriate and checking
     * its syntax. Throws if syntax is invalid.
     */
    static validate(keyPath, options = {}) {
        var _a;
        const isInitial = (_a = options.isInitial) !== null && _a !== void 0 ? _a : false;
        if (typeof keyPath === 'number')
            return Math.floor(Math.abs(keyPath));
        if (typeof keyPath !== 'string') {
            throw new Error(`Key-path must be a string or a number but is ${typeof keyPath}: ${keyPath}`);
        }
        const keyPathWithLeadingDot = this.withLeadingDot(keyPath);
        if (!validKeyPathRegExp.test(keyPathWithLeadingDot))
            throw new Error(`Key-path is not valid: ${keyPath}`);
        return isInitial ? keyPath : keyPathWithLeadingDot;
    }
    /**
     * Follows the `keyPath`, boring down through `object` recursively until the
     * final key-path is reached. Implemented as a free function to help ensure it's
     * purely functional in nature and that no modifications are made to a
     * `Document{ID}` or `DocumentPath` where similarly named variables are at play.
     * @internal
     */
    static evaluate(keyPath, object, options = {}) {
        var _a;
        const stopAtLastContainer = (_a = options.stopAtLastContainer) !== null && _a !== void 0 ? _a : false;
        const evaluationResult = {
            keyPath: keyPath,
            object: object,
            options: { ...options },
            coveredPath: null,
            nextPathComponent: null,
            remainingPath: keyPath,
            value: object,
        };
        function advance(keyPath) {
            if (typeof keyPath === 'number') {
                return {
                    nextPathComponentRaw: keyPath,
                    nextPathComponent: keyPath,
                    remainingPath: '',
                };
            }
            if (typeof keyPath !== 'string') {
                throw new Error(`Can't return value at given keyPath, expected keyPath to be a string or a number but got ${typeof keyPath}: ${keyPath}`);
            }
            // NOTE: `nextPathComponentRaw` represents next path component plus all
            // of its surrounding delimiters, i.e. given a path `["abc"].blah.blub`,
            // `nextPathComponentRaw` would be `["abc"]` while nextPathComponent
            // would just yield 'abc'.
            const regularKeyMatch = keyPath.match(regularKeyRegExp);
            if (regularKeyMatch !== null) {
                const nextPathComponentRaw = regularKeyMatch[0];
                const nextPathComponent = regularKeyMatch[1];
                const remainingPath = keyPath.slice(nextPathComponent.length + /* stripped out . */ 1);
                return { nextPathComponentRaw, nextPathComponent, remainingPath };
            }
            const subscriptIndexMatch = keyPath.match(subscriptIndexRegExp);
            if (subscriptIndexMatch !== null) {
                const nextPathComponentRaw = subscriptIndexMatch[0];
                const nextPathComponentString = subscriptIndexMatch[1];
                const nextPathComponent = parseInt(nextPathComponentString);
                const remainingPath = keyPath.slice(nextPathComponentString.length + /* stripped out [] */ 2);
                return { nextPathComponentRaw, nextPathComponent, remainingPath };
            }
            const subscriptSingleQuoteMatch = keyPath.match(subscriptSingleQuoteKeyRegExp);
            if (subscriptSingleQuoteMatch !== null) {
                const nextPathComponentRaw = subscriptSingleQuoteMatch[0];
                const nextPathComponent = subscriptSingleQuoteMatch[1];
                const remainingPath = keyPath.slice(nextPathComponent.length + /* stripped out [''] */ 4);
                return { nextPathComponentRaw, nextPathComponent, remainingPath };
            }
            const subscriptDoubleQuoteMatch = keyPath.match(subscriptDoubleQuoteKeyRegExp);
            if (subscriptDoubleQuoteMatch !== null) {
                const nextPathComponentRaw = subscriptDoubleQuoteMatch[0];
                const nextPathComponent = subscriptDoubleQuoteMatch[1];
                const remainingPath = keyPath.slice(nextPathComponent.length + /* stripped out [""] */ 4);
                return { nextPathComponentRaw, nextPathComponent, remainingPath };
            }
            throw new Error(`Can't return value at keyPath because the following part of the keyPath is invalid: ${keyPath}`);
        }
        function recurse(object, keyPath) {
            if (keyPath === '') {
                evaluationResult.value = object;
                return evaluationResult;
            }
            const { nextPathComponentRaw, nextPathComponent, remainingPath } = advance(keyPath);
            evaluationResult.nextPathComponent = nextPathComponent;
            evaluationResult.remainingPath = remainingPath;
            if (evaluationResult.coveredPath === null ||
                typeof nextPathComponentRaw === 'number')
                evaluationResult.coveredPath = nextPathComponentRaw;
            else
                evaluationResult.coveredPath += nextPathComponentRaw;
            if (remainingPath === '' && stopAtLastContainer) {
                evaluationResult.value = object;
                return evaluationResult;
            }
            const nextObject = object[nextPathComponent];
            return recurse(nextObject, remainingPath);
        }
        const keyPathWithLeadingDot = this.withLeadingDot(keyPath);
        return recurse(object, keyPathWithLeadingDot);
    }
    constructor() { }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
// -----------------------------------------------------------------------------
/**
 * Represents a portion of the document at a specific key-path.
 *
 * Provides an interface to specify a path to a key in a document that you can
 * then call a function on to get the value at the specified key as a specific
 * type. You don't create a `DocumentPath` directly but obtain one via the
 * {@link Document.path | path} property or the {@link Document.at | at()}
 * method of {@link Document}.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class DocumentPath {
    /**
     * Returns a new document path instance with the passed in key-path or index
     * appended.
     *
     * A key-path can be a single property name or multiple property names
     * separated by a dot. Indexes can also be specified as part of the key path
     * using the square bracket syntax. The empty string returns a document path
     * representing the same portion of the document as the receiver. If a
     * key-path starts with a property name and is prefixed by a dot, the dot is
     * ignored.
     *
     * Examples:
     *
     *    - `documentPath.at('mileage')`
     *    - `documentPath.at('driver.name')`
     *    - `documentPath.at('passengers[2]')`
     *    - `documentPath.at('passengers[2].belongings[1].kind')`
     *    - `documentPath.at('.mileage')`
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    at(keyPathOrIndex) {
        if (typeof keyPathOrIndex === 'string') {
            const keyPath = keyPathOrIndex;
            const validatedKeyPath = KeyPath.validate(keyPath);
            // this.path can be an empty string.
            const absoluteKeyPath = KeyPath.withoutLeadingDot(`${this.path}${validatedKeyPath}`);
            return new DocumentPath(this.document, absoluteKeyPath, false);
        }
        if (typeof keyPathOrIndex === 'number') {
            const index = keyPathOrIndex;
            const validatedIndex = validateNumber(index, {
                integer: true,
                min: 0,
                errorMessagePrefix: 'DocumentPath.at() validation failed index:',
            });
            return new DocumentPath(this.document, `${this.path}[${validatedIndex.toString()}]`, false);
        }
        throw new Error(`Can't return document path at key-path or index, string or number expected but got ${typeof keyPathOrIndex}: ${keyPathOrIndex}`);
    }
    /**
     * Traverses the document with the key-path represented by the receiver and
     * returns the corresponding object or value.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get value() {
        return this.underlyingValueForPathType('Any');
    }
    /**
     * Returns the value at the previously specified key in the document as a
     * {@link Counter} if possible, otherwise returns `null`.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get counter() {
        const underlyingValue = this.underlyingValueForPathType('Counter');
        return typeof underlyingValue !== 'undefined'
            ? Counter['@ditto.create'](null, this.path, underlyingValue)
            : null;
    }
    /**
     * Returns the value at the previously specified key in the document as a
     * {@link Register} if possible, otherwise returns `null`.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get register() {
        const underlyingValue = this.underlyingValueForPathType('Register');
        return typeof underlyingValue !== 'undefined'
            ? Register['@ditto.create'](null, this.path, underlyingValue)
            : null;
    }
    /**
     * Returns the value at the previously specified key in the document as an
     * {@link AttachmentToken} if possible, otherwise returns `null`.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get attachmentToken() {
        const underlyingValue = this.underlyingValueForPathType('Attachment');
        return typeof underlyingValue !== 'undefined'
            ? new AttachmentToken(underlyingValue)
            : null;
    }
    /** @internal */
    constructor(document, path, validate) {
        this.document = document;
        this.path = validate ? KeyPath.validate(path, { isInitial: true }) : path;
    }
    /** @internal */
    underlyingValueForPathType(pathType) {
        const path = this.path;
        const document = this.document;
        const documentHandle = Bridge.document.handleFor(document);
        const cborPathResult = documentGetCBORWithPathType(documentHandle.deref(), path, pathType);
        return cborPathResult.cbor !== null
            ? CBOR.decode(cborPathResult.cbor)
            : undefined;
    }
}
// -----------------------------------------------------------------------------
/**
 * Mutable version of {@link DocumentPath} allowing you to mutate a document at
 * a specific key-path. You don't create a `MutableDocumentPath` directly but
 * obtain one via the {@link MutableDocument.path | path} property or the
 * {@link MutableDocument.at | at()} method of {@link MutableDocument}.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class MutableDocumentPath {
    /**
     * Returns a new mutable document path instance with the passed in key-path or
     * index appended.
     *
     * A key-path can be a single property name or multiple property names
     * separated by a dot. Indexes can also be specified as part of the key path
     * using square brackets syntax. The empty string returns a document path
     * representing the same portion of the document as the receiver. If a key
     * path starts with a property name and is prefixed by a dot, the dot is
     * ignored.
     *
     * Examples:
     *
     *    - `mutableDocumentPath.at('mileage')`
     *    - `mutableDocumentPath.at('driver.name')`
     *    - `mutableDocumentPath.at('passengers[2]')`
     *    - `mutableDocumentPath.at('passengers[2].belongings[1].kind')`
     *    - `mutableDocumentPath.at('.mileage')`
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    at(keyPathOrIndex) {
        if (typeof keyPathOrIndex === 'string') {
            const keyPath = keyPathOrIndex;
            const validatedKeyPath = KeyPath.validate(keyPath);
            // this.path can be an empty string.
            const absoluteKeyPath = KeyPath.withoutLeadingDot(`${this.path}${validatedKeyPath}`);
            return new MutableDocumentPath(this.mutableDocument, absoluteKeyPath, false);
        }
        if (typeof keyPathOrIndex === 'number') {
            const index = keyPathOrIndex;
            const validatedIndex = validateNumber(index, {
                integer: true,
                min: 0,
                errorMessagePrefix: 'MutableDocumentPath.at() validation failed index:',
            });
            return new MutableDocumentPath(this.mutableDocument, `${this.path}[${validatedIndex.toString()}]`, false);
        }
        throw new Error(`Can't return mutable document path at key-path or index, string or number expected but got ${typeof keyPathOrIndex}: ${keyPathOrIndex}`);
    }
    /**
     * Traverses the document with the key-path represented by the receiver and
     * returns the corresponding object or value.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get value() {
        return this.underlyingValueForPathType('Any');
    }
    /**
     * Returns the value at the previously specified key in the document as a
     * {@link MutableCounter} if possible, otherwise returns `null`.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get counter() {
        const underlyingValue = this.underlyingValueForPathType('Counter');
        return typeof underlyingValue !== 'undefined'
            ? Counter['@ditto.create'](this.mutableDocument, this.path, underlyingValue)
            : null;
    }
    /**
     * Returns the value at the previously specified key in the document as a
     * {@link MutableRegister} if possible, otherwise returns `null`.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get register() {
        const underlyingValue = this.underlyingValueForPathType('Register');
        return typeof underlyingValue !== 'undefined'
            ? Register['@ditto.create'](this.mutableDocument, this.path, underlyingValue)
            : null;
    }
    /**
     * Returns the value at the previously specified key in the document as a
     * {@link AttachmentToken} if possible, otherwise returns `null`.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get attachmentToken() {
        const underlyingValue = this.underlyingValueForPathType('Attachment');
        return typeof underlyingValue !== 'undefined'
            ? new AttachmentToken(underlyingValue)
            : null;
    }
    /**
     * Sets a value at the document's key-path defined by the receiver.
     *
     * @param isDefault Represents whether or not the value should be set as a
     * default value. Set this to `true` if you want to set a default value that
     * you expect to be overwritten by other devices in the network. The default
     * value is `false`.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    set(value, isDefault) {
        return this['@ditto.set'](value, isDefault);
    }
    /**
     * Removes a value at the document's key-path defined by the receiver.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    remove() {
        return this['@ditto.remove']();
    }
    /** @internal */
    constructor(mutableDocument, path, validate) {
        this.mutableDocument = mutableDocument;
        this.path = validate ? KeyPath.validate(path, { isInitial: true }) : path;
    }
    /** @internal */
    underlyingValueForPathType(pathType) {
        const path = this.path;
        const document = this.mutableDocument;
        const documentHandle = Bridge.mutableDocument.handleFor(document);
        const cborPathResult = documentGetCBORWithPathType(documentHandle.deref(), path, pathType);
        return cborPathResult.cbor !== null
            ? CBOR.decode(cborPathResult.cbor)
            : undefined;
    }
    /** @internal */
    '@ditto.increment'(amount) {
        // REFACTOR: this body should probably move to
        // `MutableCounter.incrementBy()`. Keeping as-is for now until we implement
        // more explicit CRDT types.
        const documentHandle = Bridge.mutableDocument.handleFor(this.mutableDocument);
        documentIncrementCounter(documentHandle.deref(), this.path, amount);
        const updateResult = UpdateResult.incremented(this.mutableDocument.id, this.path, amount);
        this.recordUpdateResult(updateResult);
    }
    /** @internal */
    '@ditto.set'(value, isDefault) {
        const documentHandle = Bridge.mutableDocument.handleFor(this.mutableDocument);
        const valueJSON = desugarJSObject(value);
        const valueCBOR = CBOR.encode(valueJSON);
        if (isDefault) {
            documentSetCBORWithTimestamp(documentHandle.deref(), this.path, valueCBOR, 0);
        }
        else {
            documentSetCBOR(documentHandle.deref(), this.path, valueCBOR);
        }
        // HACK: we need a copy of value because the original value can be mutated
        // later on and an update result needs the state of the value at this
        // particular point in time. Decoding from CBOR might be a bit inefficient
        // but good enough for now.
        const valueJSONCopy = CBOR.decode(valueCBOR);
        const valueCopy = augmentJSONValue(valueJSONCopy, this.mutableDocument, this.path);
        const updateResult = UpdateResult.set(this.mutableDocument.id, this.path, valueCopy);
        this.recordUpdateResult(updateResult);
    }
    /** @internal */
    '@ditto.remove'() {
        const documentHandle = Bridge.mutableDocument.handleFor(this.mutableDocument);
        documentRemove(documentHandle.deref(), this.path);
        this.updateInMemory((container, lastPathComponent) => {
            if (Array.isArray(container) && typeof lastPathComponent === 'number')
                container.splice(lastPathComponent, 1);
            else
                delete container[lastPathComponent];
        });
        const updateResult = UpdateResult.removed(this.mutableDocument.id, this.path);
        this.recordUpdateResult(updateResult);
    }
    /** @private */
    updateInMemory(block) {
        const mutableDocumentValue = this.mutableDocument.value;
        const evaluationResult = KeyPath.evaluate(this.path, mutableDocumentValue, {
            stopAtLastContainer: true,
        });
        block(evaluationResult.value, evaluationResult.nextPathComponent);
    }
    /** @private */
    recordUpdateResult(updateResult) {
        // OPTIMIZE: not sure how much of a performance hit this clone-modify-freeze
        // dance implies. Investigate and fix.
        const updateResults = this.mutableDocument['@ditto.updateResults'].slice();
        updateResults.push(updateResult);
        Object.freeze(updateResults);
        this.mutableDocument['@ditto.updateResults'] = updateResults;
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
// Used to define a custom inspect function for Node.js that will be used when
// the object is inspected with console.log() or util.inspect().
const CUSTOM_INSPECT_SYMBOL$1 = Symbol.for('nodejs.util.inspect.custom');
// -----------------------------------------------------------------------------
/**
 * A document belonging to a {@link Collection} with an inner value.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class Document {
    /**
     * Returns a hash that represents the passed in document(s).
     *
     * @throws {Error} when called in a React Native environment.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    static hash(documentOrMany) {
        const documents = documentsFrom(documentOrMany);
        const documentHandles = documents.map((doc) => Bridge.document.handleFor(doc));
        return documentsHash(documentHandles.map((handle) => handle.deref()));
    }
    /**
     * Returns a pattern of words that together create a mnemonic, which
     * represents the passed in document(s).
     *
     * @throws {Error} when called in a React Native environment.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    static hashMnemonic(documentOrMany) {
        const documents = documentsFrom(documentOrMany);
        const documentHandles = Bridge.document.handlesFor(documents);
        return documentsHashMnemonic(documentHandles.deref());
    }
    /**
     * Returns the document ID.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get id() {
        let id = this['@ditto.id'];
        if (typeof id === 'undefined') {
            const documentHandle = Bridge.document.handleFor(this);
            const documentIDCBOR = documentID(documentHandle.deref());
            id = new DocumentID(documentIDCBOR, true);
            this['@ditto.id'] = id;
        }
        return id;
    }
    /**
     * Returns the document path at the root of the document.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get path() {
        return new DocumentPath(this, '', false);
    }
    /**
     * Convenience property, same as calling `path.value`. The value is cached on
     * first access and returned on subsequent calls without calling `path.value`
     * again.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get value() {
        let value = this['@ditto.value'];
        if (typeof value === 'undefined') {
            value = this.path.value;
            this['@ditto.value'] = value;
        }
        return value;
    }
    /**
     * Convenience method, same as calling `path.at()`.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    at(keyPathOrIndex) {
        return this.path.at(keyPathOrIndex);
    }
    /** @internal */
    constructor() { }
    // TEMPORARY: helpers to deal with non-canonical IDs.
    /** @internal */
    static idCBOR(document) {
        const documentHandle = Bridge.document.handleFor(document);
        return documentID(documentHandle.deref());
    }
    /** @internal */
    static canonicalizedIDCBOR(idCBOR) {
        return validateDocumentIDCBOR(idCBOR);
    }
    /** @internal */
    static isIDCBORCanonical(idCBOR) {
        const canonicalIDCBOR = this.canonicalizedIDCBOR(idCBOR);
        return idCBOR === canonicalIDCBOR;
    }
    /** @internal */
    toString() {
        return `${this.constructor.name}(${this.id})`;
    }
    /**
     * Defines a custom inspect function for Node.js that will be used when the
     * object is inspected with console.log() or util.inspect().
     *
     * @internal
     */
    [CUSTOM_INSPECT_SYMBOL$1](_depth, _inspectOptions, inspect) {
        return customInspectRepresentation(this, inspect);
    }
}
// -----------------------------------------------------------------------------
// REFACTOR: adapt the mutable document proxying to the way it is done for
// Document, i.e. only use the proxy to dispatch and delegate to actual methods
// on the corresponding classes. The way it is right now is that most of the
// code of this code is duplicated within the MutableDocument, the
// MutableDocumentPath classes and the proxy implementation. Also make sure to
// proxy the mutable document right within its constructor. Same for mutable and
// immutable document path.
/**
 * A representation of a {@link Document} that can be mutated via
 * {@link MutableDocumentPath}. You don't create or interact with a
 * `MutableDocument` directly but rather through the `update()` methods of
 * {@link PendingCursorOperation.update | PendingCursorOperation} and
 * {@link PendingIDSpecificOperation.update | PendingIDSpecificOperation}.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class MutableDocument {
    /**
     * Returns the ID of the document.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get id() {
        let id = this['@ditto.id'];
        if (typeof id === 'undefined') {
            const documentHandle = Bridge.mutableDocument.handleFor(this);
            const documentIDCBOR = documentID(documentHandle.deref());
            id = new DocumentID(documentIDCBOR, true);
            this['@ditto.id'] = id;
        }
        return id;
    }
    /**
     * Returns the document path at the root of the document.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get path() {
        return new MutableDocumentPath(this, '', false);
    }
    /**
     * Convenience property, same as `path.value`.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get value() {
        return this.path.value;
    }
    /**
     * Convenience method, same as calling `path.at()`.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    at(keyPathOrIndex) {
        return this.path.at(keyPathOrIndex);
    }
    /** @internal */
    constructor() {
        /** @internal */
        this['@ditto.updateResults'] = [];
    }
    // TEMPORARY: helpers to deal with non-canonical IDs.
    /** @internal */
    static idCBOR(mutableDocument) {
        const documentHandle = Bridge.mutableDocument.handleFor(mutableDocument);
        return documentID(documentHandle.deref());
    }
    /** @internal */
    toString() {
        return `${this.constructor.name}(${this.id})`;
    }
    /**
     * Defines a custom inspect function for Node.js that will be used when the
     * object is inspected with console.log() or util.inspect().
     *
     * @internal */
    [CUSTOM_INSPECT_SYMBOL$1](_depth, _inspectOptions, inspect) {
        return customInspectRepresentation(this, inspect);
    }
}
/** @internal */
MutableDocument.canonicalizedIDCBOR = Document.canonicalizedIDCBOR;
/** @internal */
MutableDocument.isIDCBORCanonical = Document.isIDCBORCanonical;
// -----------------------------------------------------------------------------
/** @private */
function documentsFrom(documentOrMany) {
    if (!documentOrMany)
        return [];
    if (documentOrMany instanceof Document)
        return [documentOrMany];
    if (documentOrMany instanceof Array)
        return documentOrMany;
    throw new Error(`Expected null, a single document, or an array of documents but got value of type ${typeof documentOrMany}: ${documentOrMany}`);
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/**
 * Maps a {@link DocumentID} to an array of
 * {@link UpdateResult | update results}. This is the data structure you get
 * when {@link PendingCursorOperation.update | updating} a set of documents with
 * detailed info about the performed updates.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class UpdateResultsMap {
    /**
     * Returns an array of {@link UpdateResult | update results} associated with
     * the `documentID` or undefined if not found.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
  
     */
    get(documentIDOrValue) {
        const documentID = documentIDOrValue instanceof DocumentID
            ? documentIDOrValue
            : new DocumentID(documentIDOrValue);
        const documentIDString = documentID.toString();
        return this.updateResultsByDocumentIDString[documentIDString];
    }
    /**
     * Returns all contained keys, i.e. {@link DocumentID | document IDs}
     * contained in this map.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
  
     */
    keys() {
        return this.documentIDs.slice();
    }
    // ----------------------------------------------------------- Internal ------
    /** @internal */
    constructor(documentIDs, updateResultsByDocumentIDString) {
        // REFACTOR: this quick & dirty implementation assumes Document.toString()
        // to be isomorphic, i.e. id1.equals(id2) <==> id1.toString() == id2.toString(),
        // which isn't the case in certain edge cases. Fix by implementing a proper
        // data structure ensuring correctness. One idea would be to use toString()
        // as a hash value and add a check plus conflict resolution after lookup.
        // Another idea would be to check for isomorphism for the particular subset
        // that is passed in and fallback to O(n) linear array search if not.
        const documentIDStrings = documentIDs
            .map((documentID) => documentID.toString())
            .sort()
            .join(', ');
        const updateResultsKeys = Object.keys(updateResultsByDocumentIDString)
            .sort()
            .join(', ');
        if (documentIDStrings !== updateResultsKeys) {
            throw new Error("Internal inconsistency, can't construct update results map, documentIDs must all be keys in update results (by document ID string)");
        }
        this.documentIDs = documentIDs.slice();
        this.updateResultsByDocumentIDString = {
            ...updateResultsByDocumentIDString,
        };
    }
}

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
/**
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information
 * see: https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class BasePendingCursorOperation {
    /**
     * Sorts the documents that match the query provided in the preceding
     * `find`-like function call.
     *
     * Documents that are missing the field to sort by will appear at the
     * beginning of the results when sorting in ascending order.
     *
     * @param query Name or path of the field to sort by.
     *
     * @param direction Specify whether you want the sorting order to be
     * `ascending` or `descending`. Defaults to `ascending`.
     *
     * @throws {Error} when called in a React Native environment.
     * @return A cursor that you can chain further function calls and then either
     * get the matching documents immediately or get updates about them over time.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    sort(query, direction = 'ascending') {
        this.orderBys.push({
            query,
            direction: direction === 'ascending' ? 'Ascending' : 'Descending',
        });
        return this;
    }
    /**
     * Offsets the resulting set of matching documents.
     *
     * This is useful if you aren't interested in the first N matching documents
     * for one reason or another. For example, you might already have queried the
     * collection and obtained the first 20 matching documents and so you might
     * want to run the same query as you did previously but ignore the first 20
     * matching documents, and that is when you would use `offset`.
     *
     * @param offset The number of matching documents that you want the eventual
     * resulting set of matching documents to be offset by (and thus not include).
     *
     * @throws {Error} when called in a React Native environment.
     * @return A cursor that you can chain further function calls and then either
     * get the matching documents immediately or get updates about them over time.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    offset(offset) {
        // REFACTOR: factor out parameter validation.
        if (offset < 0)
            throw new Error(`Can't offset by '${offset}', offset must be >= 0`);
        if (!Number.isFinite(offset)) {
            throw new Error(`Can't offset by '${offset}', offset must be a finite number`);
        }
        if (Number.isNaN(offset)) {
            throw new Error(`Can't offset by '${offset}', offset must be a valid number`);
        }
        const integerOffset = Math.round(offset);
        if (offset !== integerOffset) {
            throw new Error(`Can't offset by '${offset}', offset must be an integer number`);
        }
        this.currentOffset = offset;
        return this;
    }
    /**
     * Limits the number of documents that get returned when querying a collection
     * for matching documents.
     *
     * @param limit The maximum number of documents that will be returned.
     *
     * @throws {Error} when called in a React Native environment.
     * @return A cursor that you can chain further function calls and then either
     * get the matching documents immediately or get updates about them over time.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    limit(limit) {
        // REFACTOR: factor out parameter validation.
        if (limit < -1) {
            throw new Error(`Can't limit to '${limit}', limit must be >= -1 (where -1 means unlimited)`);
        }
        if (!Number.isFinite(limit)) {
            throw new Error(`Can't limit to '${limit}', limit must be a finite number`);
        }
        if (Number.isNaN(limit)) {
            throw new Error(`Can't limit to '${limit}', limit must be a valid number`);
        }
        const integerLimit = Math.round(limit);
        if (limit !== integerLimit) {
            throw new Error(`Can't limit to '${limit}', limit must be an integer number`);
        }
        this.currentLimit = limit;
        return this;
    }
    /**
     * Executes the query generated by the preceding function chaining and return
     * the list of matching documents.
     *
     * @throws {Error} when called in a React Native environment.
     * @returns An array promise containing {@link Document | documents} matching
     * the query generated by the preceding function chaining.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    async exec() {
        const ditto = this.collection.store.ditto;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            const query = this.query;
            const documentPointers = await performAsyncToWorkaroundNonAsyncFFIAPI(async () => {
                return await collectionExecQueryStr(dittoHandle.deref(), this.collection.name, null, query, this.queryArgsCBOR, this.orderBys, this.currentLimit, this.currentOffset);
            });
            return documentPointers.map((documentPointer) => {
                return Bridge.document.bridge(documentPointer);
            });
        });
    }
    // ----------------------------------------------------------- Internal ------
    /**
     * Updates documents that match the query generated by the preceding function
     * chaining.
     *
     * @param closure A closure that gets called with all of the documents
     *   matching the query. The documents are instances of
     *   {@link MutableDocument} so you can call update-related functions on them.
     * @param publicAPIName the name of the public API function that was called
     *   to perform the operation. Used in error messages and warnings.
     * @param writeTransactionPointer a transaction to perform the operation in.
     *   If not provided, a new transaction will be created.
     *
     * @returns An {@link UpdateResultsMap} promise mapping document IDs to lists
     *   of {@link UpdateResult | update results} that describe the updates that
     *   were performed for each document.
     *
     * @internal
     */
    async updateWithClosure(closure, publicAPIName, writeTransactionPointer) {
        const ditto = this.collection.store.ditto;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            return await performAsyncToWorkaroundNonAsyncFFIAPI(async () => {
                const query = this.query;
                const transactionPointer = writeTransactionPointer !== null && writeTransactionPointer !== void 0 ? writeTransactionPointer : (await writeTransaction(dittoHandle.deref()));
                const documentsX = await collectionExecQueryStr(dittoHandle.deref(), this.collection.name, transactionPointer, query, this.queryArgsCBOR, this.orderBys, this.currentLimit, this.currentOffset);
                const mutableDocuments = documentsX.map((documentX) => {
                    return Bridge.mutableDocument.bridge(documentX, () => new MutableDocument());
                });
                if (closure(mutableDocuments) instanceof Promise) {
                    Logger.warning(`Expected ${publicAPIName} to be called with a synchronous closure but ` +
                        'it was called with an async closure.');
                }
                const updateResultsDocumentIDs = [];
                const updateResultsByDocumentIDString = {};
                for (const mutableDocument of mutableDocuments) {
                    const documentID = mutableDocument.id;
                    const documentIDString = documentID.toString();
                    const updateResults = mutableDocument['@ditto.updateResults'];
                    if (updateResultsByDocumentIDString[documentIDString]) {
                        // HACK: in theory, 2 different document IDs can have the exact
                        // same string representation at the time of this writing. There is
                        // already a REFACTOR comment in `UpdateResultsMap` to implement a
                        // proper and correct data structure for holding these update results.
                        // Until then, we'll leave this check here to see how often we hit
                        // this edge case.
                        throw new Error(`Internal inconsistency, update results for document ID as string already exist: ${documentIDString}`);
                    }
                    updateResultsDocumentIDs.push(documentID);
                    updateResultsByDocumentIDString[documentIDString] = updateResults;
                    Bridge.mutableDocument.unregister(mutableDocument);
                }
                // NOTE: ownership of documentsX (and contained documents)
                // is transferred to Rust at this point.
                await collectionUpdateMultiple(dittoHandle.deref(), this.collection.name, transactionPointer, documentsX);
                if (!writeTransactionPointer) {
                    await writeTransactionCommit(dittoHandle.deref(), transactionPointer);
                }
                return new UpdateResultsMap(updateResultsDocumentIDs, updateResultsByDocumentIDString);
            });
        });
    }
    /** @internal */
    constructor(query, queryArgs, collection) {
        /** @internal */
        this.currentLimit = -1;
        /** @internal */
        this.currentOffset = 0;
        /** @internal */
        this.orderBys = [];
        this.query = validateQuery(query);
        this.queryArgs = queryArgs ? Object.freeze({ ...queryArgs }) : null;
        this.collection = collection;
        if (queryArgs == null) {
            this.queryArgsCBOR = null;
        }
        else {
            const queryArgsJSON = desugarJSObject(queryArgs);
            this.queryArgsCBOR = CBOR.encode(queryArgsJSON);
        }
    }
    /** @internal */
    then(onfulfilled, onrejected) {
        return this.exec().then(onfulfilled, onrejected);
    }
}

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
/**
 * These objects are returned when using
 * {@link Collection.findByID | findByID()} functionality on
 * {@link Collection | collections}.
 *
 * You can either call {@link exec | exec()} on the  object to get an immediate
 * return value, or chain calls to update, evict or remove the document.
 *
 * Live queries and subscriptions are only available outside of a transaction.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class BasePendingIDSpecificOperation {
    /**
     * Executes the find operation to return the document with the matching ID.
     *
     * @throws {Error} when called in a React Native environment.
     * @returns The {@link Document} promise with the ID provided in the
     * {@link Collection.findByID | findByID()} call or `undefined` if the document was
     * not found.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    async exec() {
        const ditto = this.collection.store.ditto;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            return await performAsyncToWorkaroundNonAsyncFFIAPI(async () => {
                const readTransactionX = await readTransaction(dittoHandle.deref());
                const documentX = await collectionGet(dittoHandle.deref(), this.collection.name, this.documentIDCBOR, readTransactionX);
                let document = undefined;
                if (documentX)
                    document = Bridge.document.bridge(documentX);
                readTransactionFree(readTransactionX);
                return document;
            });
        });
    }
    // ----------------------------------------------------------- Internal ------
    /** @internal */
    constructor(documentID, collection) {
        this.documentID = documentID;
        this.collection = collection;
        this.documentIDCBOR = documentID.toCBOR();
    }
    /** @internal */
    then(onfulfilled, onrejected) {
        return this.exec().then(onfulfilled, onrejected);
    }
    /** @internal */
    get query() {
        return `_id == ${this.documentID.toQueryCompatibleString()}`;
    }
    /**
     * Commit changes made by the given closure to the current document.
     *
     * @param closure
     * @param throwOnAsyncClosure if true, throw an error when passed an async
     *   closure, otherwise log a warning
     * @param throwOnDocumentNotFound if true, throw an error if the document is
     *   not found, otherwise call the closure with `undefined` and return an
     *   empty array
     * @param publicAPIName the name of the public API that was called, used in
     *   error messages and warnings
     * @param transaction the transaction to use, if not provided a new one will
     *   be created and committed
     * @internal
     */
    async updateWithClosure(closure, throwOnAsyncClosure, throwOnDocumentNotFound, publicAPIName, transaction) {
        const ditto = this.collection.store.ditto;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            var _a;
            let documentPointer = null;
            if (transaction == null) {
                const readTransactionPointer = await readTransaction(dittoHandle.deref());
                try {
                    documentPointer = await collectionGet(dittoHandle.deref(), this.collection.name, this.documentIDCBOR, readTransactionPointer);
                }
                finally {
                    readTransactionFree(readTransactionPointer);
                }
            }
            else {
                documentPointer = await collectionGetWithWriteTransaction(dittoHandle.deref(), this.collection.name, this.documentIDCBOR, transaction.writeTransactionPointer);
            }
            const errorMessageAsyncClosure = `Expected ${publicAPIName} to be called with a synchronous ` +
                'closure but it was called with an async closure';
            if (!documentPointer) {
                if (throwOnDocumentNotFound) {
                    throw new Error(`Can't update, document with ID '${this.documentID.toString()}' not found in collection named '${this.collection.name}'`);
                }
                if (closure() instanceof Promise) {
                    if (throwOnAsyncClosure)
                        throw new TypeError(errorMessageAsyncClosure);
                    else
                        Logger.warning(errorMessageAsyncClosure);
                }
                return [];
            }
            const mutableDocument = Bridge.mutableDocument.bridge(documentPointer, () => new MutableDocument());
            if (closure(mutableDocument) instanceof Promise) {
                if (throwOnAsyncClosure)
                    throw new TypeError(errorMessageAsyncClosure);
                Logger.warning(errorMessageAsyncClosure);
            }
            const writeTransactionPointer = (_a = transaction === null || transaction === void 0 ? void 0 : transaction.writeTransactionPointer) !== null && _a !== void 0 ? _a : (await writeTransaction(dittoHandle.deref()));
            // Ownership is transferred back to the FFI layer via collectionUpdate(),
            // we therefore need to explicitly unregister the instance.
            Bridge.mutableDocument.unregister(mutableDocument);
            await collectionUpdate(dittoHandle.deref(), this.collection.name, writeTransactionPointer, documentPointer);
            if (!transaction) {
                await writeTransactionCommit(dittoHandle.deref(), writeTransactionPointer);
            }
            return mutableDocument['@ditto.updateResults'].slice();
        });
    }
}

//
// Copyright © 2024 DittoLive Incorporated. All rights reserved.
//
/**
 * Contains information about a remote peer that has requested a connection.
 *
 * Connection requests and their authorization are scoped to a specific Ditto
 * peer and connection type.
 */
class ConnectionRequest {
    /**
     * The unique peer key of the remote peer.
     *
     * @see field `peerKeyString` on {@link Peer} for more information on peer
     * keys.
     */
    get peerKeyString() {
        return connectionRequestPeerKeyString(this.deref());
    }
    /**
     * Metadata associated with the remote peer.
     *
     * This is an empty object if the remote peer has not set any metadata.
     *
     * Set peer metadata for the local peer using {@link Presence.peerMetadata} or
     * {@link Presence.peerMetadataJSONString}.
     *
     * This is a convenience property that wraps
     * {@link peerMetadataJSONString | `peerMetadataJSONString()`}.
     */
    get peerMetadata() {
        return JSON.parse(this.peerMetadataJSONString);
    }
    /**
     * JSON-encoded metadata associated with the remote peer.
     *
     * This is a JSON string representing an empty dictionary if the remote peer
     * has not set any metadata.
     *
     * Set peer metadata for the local peer using {@link Presence.peerMetadata} or
     * {@link Presence.peerMetadataJSONString}.
     *
     * Uses UTF-8 encoding.
     */
    get peerMetadataJSONString() {
        return connectionRequestPeerMetadataJSON(this.deref());
    }
    /**
     * Metadata for the remote peer that is provided by the identity service.
     *
     * Use an authentication webhook to set this value. See Ditto's online
     * documentation for more information on how to configure an authentication
     * webhook.
     *
     * Convenience property that wraps {@link identityServiceMetadataJSONString}.
     */
    get identityServiceMetadata() {
        return JSON.parse(this.identityServiceMetadataJSONString);
    }
    /**
     * JSON-encoded metadata for the remote peer that is provided by the
     * identity service.
     *
     * Use an authentication webhook to set this value. See Ditto's online
     * documentation for more information on how to configure an authentication
     * webhook.
     *
     * Uses UTF-8 encoding.
     */
    get identityServiceMetadataJSONString() {
        return connectionRequestIdentityServiceMetadataJSON(this.deref());
    }
    /**
     * The network transport of this connection request.
     *
     * Expect to receive separate connection requests for each network
     * transport that connects the local and remote peer.
     */
    get connectionType() {
        return connectionRequestConnectionType(this.deref());
    }
    /** @internal */
    toString() {
        return `ConnectionRequest(${this.peerKeyString} via ${this.connectionType})`;
    }
    /**
     * Defines a custom inspect function for Node.js that will be used when the
     * object is inspected with console.log() or util.inspect().
     *
     * @internal
     */
    [Symbol.for('nodejs.util.inspect.custom')](_depth, _inspectOptions, inspect) {
        return this.toString();
    }
    // --------------------------------------------------------------------------
    deref() {
        return Bridge.connectionRequest.handleFor(this).deref();
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/** @internal */
class ObserverManager {
    /** @internal */
    constructor(id, options = {}) {
        var _a, _b, _c, _d;
        const keepAlive = (_a = options.keepAlive) !== null && _a !== void 0 ? _a : null;
        const register = (_b = options.register) !== null && _b !== void 0 ? _b : null;
        const unregister = (_c = options.unregister) !== null && _c !== void 0 ? _c : null;
        const process = (_d = options.process) !== null && _d !== void 0 ? _d : null;
        this.id = id;
        this.keepAlive = keepAlive;
        this.isClosed = false;
        this.isRegistered = false;
        this.callbacksByToken = {};
        if (register !== null)
            this.register = register;
        if (unregister !== null)
            this.unregister = unregister;
        if (process !== null)
            this.process = process;
    }
    /** @internal */
    addObserver(callback) {
        var _a;
        if (this.isClosed) {
            // REFACTOR: throw a catchable error here, such that calling code
            // can be more specific when forwarding it to the user.
            throw new Error(`Internal inconsistency, can't add '${this.id}' observer, observer mananger close()-ed.`);
        }
        this.registerIfNeeded();
        const token = cryptoGenerateSecureRandomToken();
        this.callbacksByToken[token] = callback;
        (_a = this.keepAlive) === null || _a === void 0 ? void 0 : _a.retain(`${this.id}.${token}`);
        return token;
    }
    /** @internal */
    removeObserver(token) {
        var _a;
        const callback = this.callbacksByToken[token];
        if (typeof callback === 'undefined') {
            throw new Error(`Can't remove '${this.id}' observer, token '${token}' has never been registered before.`);
        }
        if (callback === null) {
            // Observer has already been removed, no-op.
            return;
        }
        // REFACTOR: not deleting the token here will keep eating up
        // memory over long periods of time. We actually need to track
        // the observer objects themselves and remove it from the table
        // as soon as the observer object is garbage collected.
        // The value is set to null to be able to discern between
        // observers that have been removed and observers that have
        // never been registered before.
        this.callbacksByToken[token] = null;
        (_a = this.keepAlive) === null || _a === void 0 ? void 0 : _a.release(`${this.id}.${token}`);
        this.unregisterIfNeeded();
    }
    hasObserver(token) {
        return typeof this.callbacksByToken[token] != 'undefined';
    }
    /** @internal */
    notify(...args) {
        if (this.isClosed) {
            // NOTE: we don't notify observers after closing and just swallow
            // the event.
            return;
        }
        const processedArgs = this.process(...args);
        for (const token in this.callbacksByToken) {
            const callback = this.callbacksByToken[token];
            if (callback)
                callback(...processedArgs);
        }
    }
    /** @internal */
    close() {
        this.isClosed = true;
        for (const token in this.callbacksByToken)
            this.removeObserver(token);
    }
    /**
     * Can be injected and replaced via constructor options.
     *
     * @abstract
     */
    register(callback) {
        // No-op, subclasses may override and register.
    }
    /**
     * Can be injected and replaced via constructor options.
     *
     * @abstract
     */
    unregister() {
        // No-op, subclasses may override and unregister.
    }
    /**
     * Can be injected and replaced via constructor options.
     *
     * @abstract
     */
    process(...args) {
        // No-op, subclasses may override and process/transform the callback parameters.
        return args;
    }
    hasObservers() {
        return Object.keys(this.callbacksByToken).length > 0;
    }
    registerIfNeeded() {
        const needsToRegister = !this.isRegistered;
        if (needsToRegister) {
            const weakThis = new WeakRef(this);
            this.isRegistered = true;
            this.register(function (...args) {
                const strongThis = weakThis.deref();
                if (!strongThis)
                    return;
                strongThis.notify(...args);
            });
        }
    }
    unregisterIfNeeded() {
        const needsToUnregister = !this.hasObservers() && this.isRegistered;
        if (needsToUnregister) {
            this.isRegistered = false;
            this.unregister();
        }
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
function authenticationStatusFromFFI(ffiAuthenticationStatus) {
    const isAuthenticated = authenticationStatusIsAuthenticated(ffiAuthenticationStatus);
    const userID = authenticationStatusUserID(ffiAuthenticationStatus);
    authenticationStatusFree(ffiAuthenticationStatus);
    return {
        isAuthenticated,
        userID,
    };
}
// -----------------------------------------------------------------------------
/**
 * Log in to a remote authentication service, using an
 * `OnlineWithAuthentication` or an `Online` identity.
 */
class Authenticator {
    /**
     * The built-in development authentication provider to be used together with
     * development authentication tokens.
     *
     * This API is in **preview** as part of the new configuration APIs that replace
     * the legacy {@link Identity}-based initialization.
     *
     * @see {@link Authenticator.login | Authenticator.login()} for more information
     * about the `provider` parameter.
     */
    static get DEVELOPMENT_PROVIDER() {
        return DITTO_DEVELOPMENT_PROVIDER();
    }
    /**
     * The handler that will be called when authentication for this Ditto instance
     * is about to expire.
     *
     * This API is in **preview** and provides a replacement for the phased out
     * {@link AuthenticationHandler} interface.
     *
     * **Important:** If the Ditto instance is configured with a
     * {@link DittoConfigConnectServer} this property **must** be set and the
     * handler **must** properly authenticate when called.
     *
     * @see {@link setExpirationHandler}
     */
    get expirationHandler() {
        throw new Error(`Authenticator.expirationHandler is only available when using a ` +
            `DittoConfig with a ConfigConnectServer.`);
    }
    /**
     * Sets the handler that will be called when authentication for this Ditto
     * instance is about to expire.
     *
     * This API is in **preview** and provides a replacement for the phased out
     * {@link AuthenticationHandler} interface.
     *
     * Assign a handler function to be notified before authentication expires,
     * allowing you to login or perform other necessary actions.
     *
     * @see {@link expirationHandler}
     */
    async setExpirationHandler(handler) {
        throw new Error(`Authenticator.expirationHandler is only available when using a ` +
            `DittoConfig with a ConfigConnectServer.`);
    }
    /**
     Returns the current authentication status.
     */
    get status() {
        return this._status;
    }
    /**
     * Log in to Ditto with a third-party token.
     *
     * Returns a promise that resolves to a `LoginResult` object. When the login
     * attempt is successful, the `error` property of the response will be `null`,
     * otherwise it will contain a {@link DittoError} object with details about
     * the error.
     *
     * If the authentication service provides additional client info, it will be
     * returned in the `clientInfo` property of the response, whether the login
     * attempt was successful or not.
     *
     * @param token The authentication token required to log in.
     * @param provider The name of the authentication provider. Use
     *   {@link Authenticator.DEVELOPMENT_PROVIDER} with development tokens.
     * @throws {@link DittoError} `authentication/failed-to-authenticate` if the
     * Ditto instance is closed.
     * @returns A promise that resolves to a `LoginResult` object.
     */
    async login(token, provider) {
        if (typeof token !== 'string') {
            throw new TypeError(`Expected parameter token to have type string, but got '${typeof token}'`);
        }
        if (typeof provider !== 'string') {
            throw new TypeError(`Expected parameter provider to have type string, but got '${typeof provider}'`);
        }
        throw new Error(`Authenticator.login() is abstract and must be implemented by subclasses.`);
    }
    /**
     * Log in to Ditto with a third-party token. Throws if authentication is not
     * available, which can be checked with {@link loginSupported}.
     *
     * @param token the authentication token required to log in.
     * @param provider the name of the authentication provider.
     * @deprecated Use {@link login} instead, which provides access to client info
     * provided by the authentication service.
     */
    loginWithToken(token, provider) {
        if (typeof token !== 'string') {
            throw new TypeError(`Expected parameter token to have type string, but got '${typeof token}'`);
        }
        if (typeof provider !== 'string') {
            throw new TypeError(`Expected parameter provider to have type string, but got '${typeof provider}'`);
        }
        throw new Error(`Authenticator.loginWithToken() is abstract and must be implemented by subclasses.`);
    }
    /**
     * Log in to Ditto with a username and password. Throws if authentication is
     * not available, which can be checked with {@link loginSupported}.
     *
     * @param username the username component of the credentials used for log in.
     * @param password the password component of the credentials used for log in.
     * @param provider the name of the authentication provider.
     * @deprecated this method is deprecated and will be removed in a future
     * version.
     */
    loginWithUsernameAndPassword(username, password, provider) {
        if (typeof username !== 'string') {
            throw new TypeError(`Expected parameter username to have type string, but got '${typeof username}'`);
        }
        if (typeof password !== 'string') {
            throw new TypeError(`Expected parameter password to have type string, but got '${typeof password}'`);
        }
        if (typeof provider !== 'string') {
            throw new TypeError(`Expected parameter provider to have type string, but got '${typeof provider}'`);
        }
        throw new Error(`Authenticator.loginWithUsernameAndPassword() is abstract and must be implemented by subclasses.`);
    }
    /**
     * Log out of Ditto.
     *
     * This will stop sync, shut down all replication sessions, and remove any
     * cached authentication credentials. Note that this does not remove any data
     * from the store. If you wish to delete data from the store then use the
     * optional `cleanupFn` parameter to perform any required cleanup.
     *
     * @param cleanupFn An optional function that will be called with the relevant
     * [Ditto] instance as the sole argument that allows you to perform any
     * required cleanup of the store as part of the logout process.
     */
    logout(cleanupFn) {
        if (cleanupFn !== undefined && typeof cleanupFn !== 'function') {
            throw new TypeError(`Expected parameter cleanupFn to have type function, but got '${typeof cleanupFn}'`);
        }
        throw new Error(`Authenticator.logout() is abstract and must be implemented by subclasses.`);
    }
    /*
     * Registers a callback that is called whenever the authentication status
     * changes. Returns an `Observer` object that needs to be retained as long as
     * you want to receive the updates.
     */
    observeStatus(callback) {
        if (typeof callback !== 'function') {
            throw new TypeError(`Expected parameter callback to have type function, but got '${typeof callback}'`);
        }
        const token = this.observerManager.addObserver(callback);
        return new Observer(this.observerManager, token, {
            stopsWhenFinalized: true,
        });
    }
    /** @internal */
    constructor(keepAlive) {
        this.keepAlive = keepAlive;
        this._status = { isAuthenticated: false, userID: null };
        this.loginSupported = false;
        this.observerManager = new ObserverManager('AuthenticationStatusObservation', { keepAlive });
    }
    /** @internal */
    '@ditto.authenticationExpiring'(secondsRemaining) {
        throw new Error(`Authenticator['@ditto.authenticationExpiring']() is abstract and must be implemented by subclasses.`);
    }
    /** @internal */
    close() {
        this.observerManager.close();
    }
}
// -----------------------------------------------------------------------------
/** @internal */
class OnlineAuthenticator extends Authenticator {
    async login(token, provider) {
        if (typeof token !== 'string') {
            throw new TypeError(`Expected parameter token to have type string, but got '${typeof token}'`);
        }
        if (typeof provider !== 'string') {
            throw new TypeError(`Expected parameter provider to have type string, but got '${typeof provider}'`);
        }
        const ditto = this.ditto.deref();
        if (!ditto || ditto.isClosed) {
            throw new DittoError('authentication/failed-to-authenticate', 'Ditto instance is closed');
        }
        return ditto.deferCloseAsync(async (dittoHandle) => {
            const { clientInfo, error: ffiError } = await dittoAuthClientLoginWithTokenAndFeedback(dittoHandle.deref(), token, provider);
            const error = ffiError != null
                ? DittoError.fromFFIError(ffiError, 'authentication/failed-to-authenticate')
                : null;
            return { clientInfo, error };
        });
    }
    async loginWithToken(token, provider) {
        if (typeof token !== 'string') {
            throw new TypeError(`Expected parameter token to have type string, but got '${typeof token}'`);
        }
        if (typeof provider !== 'string') {
            throw new TypeError(`Expected parameter provider to have type string, but got '${typeof provider}'`);
        }
        const ditto = this.ditto.deref();
        if (!ditto || ditto.isClosed)
            return;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            await dittoAuthClientLoginWithToken(dittoHandle.deref(), token, provider);
        });
    }
    async loginWithUsernameAndPassword(username, password, provider) {
        if (typeof username !== 'string') {
            throw new TypeError(`Expected parameter username to have type string, but got '${typeof username}'`);
        }
        if (typeof password !== 'string') {
            throw new TypeError(`Expected parameter password to have type string, but got '${typeof password}'`);
        }
        if (typeof provider !== 'string') {
            throw new TypeError(`Expected parameter provider to have type string, but got '${typeof provider}'`);
        }
        const ditto = this.ditto.deref();
        if (!ditto || ditto.isClosed)
            return;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            await dittoAuthClientLoginWithUsernameAndPassword(dittoHandle.deref(), username, password, provider);
        });
    }
    async logout(cleanupFn) {
        if (cleanupFn !== undefined && typeof cleanupFn !== 'function') {
            throw new TypeError(`Expected parameter cleanupFn to have type function, but got '${typeof cleanupFn}'`);
        }
        const ditto = this.ditto.deref();
        if (!ditto || ditto.isClosed)
            return;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            await dittoAuthClientLogout(dittoHandle.deref());
            ditto.stopSync();
            cleanupFn === null || cleanupFn === void 0 ? void 0 : cleanupFn(ditto);
        });
    }
    constructor(keepAlive, ditto, authenticationHandler) {
        super(keepAlive);
        this.loginSupported = true;
        this._status = { isAuthenticated: false, userID: null };
        this.ditto = new WeakRef(ditto);
        this.authenticationHandler = authenticationHandler;
        const weakThis = new WeakRef(this);
        ditto.deferClose((dittoHandle) => {
            dittoSetAuthenticationStatusHandler(dittoHandle.deref(), function (ffiAuthenticationStatus) {
                const authenticator = weakThis.deref();
                if (authenticator == null) {
                    Logger.info('Authenticator is null, ignoring authentication status change');
                    return;
                }
                const authenticationStatus = authenticationStatusFromFFI(ffiAuthenticationStatus);
                authenticator.authenticationStatusUpdated(authenticationStatus);
            });
        });
        this.updateAndNotify(false);
    }
    '@ditto.authenticationExpiring'(secondsRemaining) {
        const ditto = this.ditto.deref();
        const isLegacyIdentity = ditto !== null && ditto.configOrParameters.isParameters;
        // Handle new-style expiration handler first
        if (!isLegacyIdentity) {
            void ditto.deferCloseAsync(async () => {
                try {
                    await this.expirationHandler(ditto, secondsRemaining);
                }
                catch (error) {
                    Logger.error(`Authentication expiration handler failed: ${error.message}`);
                }
            });
            return;
        }
        // Fallback to legacy authentication handler
        const authenticationHandler = this.authenticationHandler;
        if (secondsRemaining > 0)
            authenticationHandler.authenticationExpiringSoon(this, secondsRemaining);
        else
            authenticationHandler.authenticationRequired(this);
    }
    authenticationStatusUpdated(authenticationStatus) {
        var _a;
        const previousStatus = this.status;
        this._status = authenticationStatus;
        const sameStatus = !!previousStatus.isAuthenticated ===
            !!authenticationStatus.isAuthenticated &&
            previousStatus.userID === authenticationStatus.userID;
        if (!sameStatus) {
            (_a = this.authenticationHandler.authenticationStatusDidChange) === null || _a === void 0 ? void 0 : _a.call(this.authenticationHandler, this);
            this.observerManager.notify(authenticationStatus);
        }
    }
    updateAndNotify(shouldNotify) {
        const ditto = this.ditto.deref();
        if (!ditto) {
            Logger.debug('Unable to update auth status and notify, related Ditto object does not exist anymore.');
            return;
        }
        const dittoHandle = Bridge.ditto.handleFor(ditto);
        const dittoPointer = dittoHandle.derefOrNull();
        if (!dittoPointer) {
            Logger.debug('Unable to update auth status and notify, related Ditto object does not exist anymore.');
            return;
        }
        const isAuthenticated = dittoAuthClientIsWebValid(dittoPointer);
        const userID = dittoAuthClientUserID(dittoPointer);
        const status = { isAuthenticated, userID };
        if (shouldNotify) {
            // We don't need to set the `_status` property here because it's done in
            // `authenticationStatusUpdated`.
            this.authenticationStatusUpdated(status);
        }
        else {
            this._status = status;
        }
    }
}
// -----------------------------------------------------------------------------
/**
 * OnlineAuthenticatorV2 exclusively supports the new DittoConfig-based API,
 *
 * @internal
 */
class OnlineAuthenticatorV2 extends Authenticator {
    get expirationHandler() {
        const ditto = this.ditto.deref();
        if (!ditto || ditto.isClosed) {
            Logger.error('Ditto instance is closed, cannot get authentication expiration handler.');
            return null;
        }
        return this._expirationHandler;
    }
    async setExpirationHandler(handler) {
        if (handler !== null && typeof handler !== 'function') {
            throw new TypeError(`Expected parameter handler to have type function or null, but got '${typeof handler}'`);
        }
        const ditto = this.ditto.deref();
        if (!ditto || ditto.isClosed) {
            Logger.error('Ditto instance is closed, cannot set authentication expiration handler.');
        }
        this._expirationHandler = handler;
        // Register the expiration handler with the FFI layer.
        return ditto.deferCloseAsync(async (dittoHandle) => {
            try {
                const providerPointer = dittoAuthClientMakeLoginProvider(this.makeFFFIAuthenticationExpirationHandler());
                await dittoAuthSetLoginProvider(dittoHandle.deref(), providerPointer);
            }
            catch (error) {
                Logger.error(`Failed to set authentication expiration handler: ${error.message}`);
            }
        });
    }
    constructor(keepAlive, ditto) {
        super(keepAlive);
        // -----------------------------------------------------------------------------
        /** @internal */
        this._expirationHandler = null;
        if (ditto.configOrParameters.isParameters) {
            throw new Error('OnlineAuthenticatorV2 can only be used with the new DittoConfig-based API.');
        }
        this.loginSupported = ditto.config.connect.mode === 'server';
        this.ditto = new WeakRef(ditto);
        // Set up authentication status handler like OnlineAuthenticator does
        const weakThis = new WeakRef(this);
        ditto.deferClose((dittoHandle) => {
            dittoSetAuthenticationStatusHandler(dittoHandle.deref(), function (ffiAuthenticationStatus) {
                const authenticator = weakThis.deref();
                if (authenticator == null) {
                    Logger.info('Authenticator is null, ignoring authentication status change');
                    return;
                }
                const authenticationStatus = authenticationStatusFromFFI(ffiAuthenticationStatus);
                authenticator.authenticationStatusUpdated(authenticationStatus);
            });
        });
        // Initialize status by querying current state
        this.updateAndNotify(false);
    }
    async login(token, provider) {
        if (typeof token !== 'string') {
            throw new TypeError(`Expected parameter token to have type string, but got '${typeof token}'`);
        }
        if (typeof provider !== 'string') {
            throw new TypeError(`Expected parameter provider to have type string, but got '${typeof provider}'`);
        }
        const ditto = this.ditto.deref();
        if (!ditto || ditto.isClosed) {
            throw new DittoError('authentication/failed-to-authenticate', 'Ditto instance is closed');
        }
        return ditto.deferCloseAsync(async (dittoHandle) => {
            const { clientInfo, error: ffiError } = await dittoAuthClientLoginWithTokenAndFeedback(dittoHandle.deref(), token, provider);
            const error = ffiError != null
                ? DittoError.fromFFIError(ffiError, 'authentication/failed-to-authenticate')
                : null;
            return { clientInfo, error };
        });
    }
    async loginWithToken(token, provider) {
        if (typeof token !== 'string') {
            throw new TypeError(`Expected parameter token to have type string, but got '${typeof token}'`);
        }
        if (typeof provider !== 'string') {
            throw new TypeError(`Expected parameter provider to have type string, but got '${typeof provider}'`);
        }
        const ditto = this.ditto.deref();
        if (!ditto || ditto.isClosed)
            return;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            await dittoAuthClientLoginWithToken(dittoHandle.deref(), token, provider);
        });
    }
    async loginWithUsernameAndPassword(username, password, provider) {
        if (typeof username !== 'string') {
            throw new TypeError(`Expected parameter username to have type string, but got '${typeof username}'`);
        }
        if (typeof password !== 'string') {
            throw new TypeError(`Expected parameter password to have type string, but got '${typeof password}'`);
        }
        if (typeof provider !== 'string') {
            throw new TypeError(`Expected parameter provider to have type string, but got '${typeof provider}'`);
        }
        const ditto = this.ditto.deref();
        if (!ditto || ditto.isClosed)
            return;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            await dittoAuthClientLoginWithUsernameAndPassword(dittoHandle.deref(), username, password, provider);
        });
    }
    async logout(cleanupFn) {
        if (cleanupFn !== undefined && typeof cleanupFn !== 'function') {
            throw new TypeError(`Expected parameter cleanupFn to have type function, but got '${typeof cleanupFn}'`);
        }
        const ditto = this.ditto.deref();
        if (!ditto || ditto.isClosed)
            return;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            await dittoAuthClientLogout(dittoHandle.deref());
            ditto.stopSync();
            cleanupFn === null || cleanupFn === void 0 ? void 0 : cleanupFn(ditto);
        });
    }
    authenticationStatusUpdated(authenticationStatus) {
        const previousStatus = this.status;
        this._status = authenticationStatus;
        const sameStatus = !!previousStatus.isAuthenticated ===
            !!authenticationStatus.isAuthenticated &&
            previousStatus.userID === authenticationStatus.userID;
        if (!sameStatus)
            this.observerManager.notify(authenticationStatus);
    }
    updateAndNotify(shouldNotify) {
        const ditto = this.ditto.deref();
        if (!ditto) {
            Logger.debug('Unable to update auth status and notify, related Ditto object does not exist anymore.');
            return;
        }
        const dittoHandle = Bridge.ditto.handleFor(ditto);
        const dittoPointer = dittoHandle.derefOrNull();
        if (!dittoPointer) {
            Logger.debug('Unable to update auth status and notify, related Ditto object does not exist anymore.');
            return;
        }
        const isAuthenticated = dittoAuthClientIsWebValid(dittoPointer);
        const userID = dittoAuthClientUserID(dittoPointer);
        const status = { isAuthenticated, userID };
        if (shouldNotify) {
            // We don't need to set the `_status` property here because it's done in
            // `authenticationStatusUpdated`.
            this.authenticationStatusUpdated(status);
        }
        else {
            this._status = status;
        }
    }
    makeFFFIAuthenticationExpirationHandler() {
        const weakAuthenticator = new WeakRef(this);
        return (secondsUntilExpiration) => {
            const authenticator = weakAuthenticator.deref();
            if (!authenticator) {
                // If owning authenticator has gone out of scope, we sure don't need to
                // notify anyone about the expiration.
                return;
            }
            const ditto = authenticator.ditto.deref();
            if (!ditto) {
                // Same if Ditto went out of scope.
                return;
            }
            if (authenticator.expirationHandler != null) {
                // This is being called from FFI so no point in awaiting the
                // deferCloseAsync promise.
                void ditto.deferCloseAsync(async () => {
                    try {
                        await authenticator.expirationHandler(ditto, secondsUntilExpiration);
                    }
                    catch (error) {
                        Logger.error('The authentication handler set via `ditto.auth.setExpirationHandler()` ' +
                            `failed: ${error.message}`);
                    }
                });
            }
            else {
                Logger.error('Authentication required but no expiration handler is set. ' +
                    'Please set an expiration handler using ' +
                    '`ditto.auth.setExpirationHandler()`.');
            }
        };
    }
}
// -----------------------------------------------------------------------------
/** @internal */
class NotAvailableAuthenticator extends Authenticator {
    async login(token, provider) {
        throw new Error(`Can't login, authentication is not supported for the identity in use, please use an onlineWithAuthentication identity.`);
    }
    async loginWithToken(token, provider) {
        throw new Error(`Can't login, authentication is not supported for the identity in use, please use an onlineWithAuthentication identity.`);
    }
    async loginWithUsernameAndPassword(username, password, provider) {
        throw new Error(`Can't login, authentication is not supported for the identity in use, please use an onlineWithAuthentication identity.`);
    }
    logout(cleanupFn) {
        throw new Error(`Can't logout, authentication is not supported for the identity in use, please use an onlineWithAuthentication identity.`);
    }
    '@ditto.authenticationExpiring'(secondsRemaining) {
        throw new Error(`Internal inconsistency, authentication is not available, yet the @ditto.authenticationExpiring() was called on authenticator: ${this}`);
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/** The list of identity types that require activation through an offlineLicenseToken */
const IdentityTypesRequiringOfflineLicenseToken = [
    'manual',
    'sharedKey',
    'offlinePlayground',
];
/**
 * Registers the given identity with Ditto FFI and returns a pointer to the
 * identity configuration.
 *
 * @internal
 * @deprecated
 */
function makeIdentityConfig(identity) {
    var _a, _b, _c;
    if (identity.type === 'offlinePlayground') {
        return dittoIdentityConfigMakeOfflinePlayground(identity.appID, (_a = identity.siteID) !== null && _a !== void 0 ? _a : 0);
    }
    if (identity.type === 'manual') {
        return dittoIdentityConfigMakeManual(identity.certificate);
    }
    if (identity.type === 'sharedKey') {
        return dittoIdentityConfigMakeSharedKey(identity.appID, identity.sharedKey, identity.siteID);
    }
    if (identity.type === 'onlinePlayground') {
        const authURL = (_b = identity.customAuthURL) !== null && _b !== void 0 ? _b : defaultAuthURL(identity.appID);
        return dittoIdentityConfigMakeOnlinePlayground(identity.appID, identity.token, authURL);
    }
    if (identity.type === 'onlineWithAuthentication') {
        const authURL = (_c = identity.customAuthURL) !== null && _c !== void 0 ? _c : defaultAuthURL(identity.appID);
        return dittoIdentityConfigMakeOnlineWithAuthentication(identity.appID, authURL);
    }
}

//
// Copyright © 2025 DittoLive Incorporated. All rights reserved.
//
/**
 * The default identity that is used when no identity is specified while
 * creating a Ditto instance.
 *
 * @internal
 * @deprecated This is used for backward compatibility with the legacy
 * {@link DittoConfig} constructor.
 */
const DEFAULT_IDENTITY = {
    type: 'offlinePlayground',
    appID: '',
};
/**
 * A configuration object for initializing a {@link Ditto} instance.
 *
 * Encapsulates all the parameters required to configure a Ditto instance,
 * including identity, connectivity, and persistence.
 *
 * This API is in **preview** and will become the standard way to initialize
 * Ditto instances in v5, replacing the legacy {@link Identity}-based
 * initialization.
 */
class DittoConfig {
    /**
     * The default database ID, used when no database ID is provided.
     *
     * @see {@link DittoConfig.databaseID | database_id} for more information about the
     * `databaseID` parameter.
     */
    static get DEFAULT_DATABASE_ID() {
        return DEFAULT_DATABASE_ID();
    }
    /**
     * Returns a default {@link DittoConfig} instance with standard settings.
     *
     * This is useful as a starting point or for quickly creating a basic
     * configuration, but for production use you should customize the
     * configuration as needed.
     */
    static get default() {
        const configCBOR = dittoConfigDefault();
        const ffiConfig = CBOR.decode(configCBOR);
        return fromFFICBORData(ffiConfig);
    }
    /**
     * Initializes a new {@link DittoConfig} instance with the new API.
     */
    constructor(id, connect, persistenceDirectory) {
        this._isFrozen = false;
        // The logger is initialized here to ensure that users have a chance to set
        // a minimum log level before the logger starts emitting logs.
        loggerInit();
        // New API: DittoConfig(id, connect, persistenceDirectory?)
        if (typeof id !== 'string')
            throw new TypeError('Expected id to be a string, but got: ' + typeof id);
        if (typeof connect !== 'object') {
            throw new TypeError(`Expected connect to be an object, but got: ` + typeof connect);
        }
        if (persistenceDirectory != null &&
            typeof persistenceDirectory !== 'string') {
            throw new TypeError(`Expected persistenceDirectory to be undefined or a string, but got: ` +
                typeof persistenceDirectory);
        }
        this.databaseID = id;
        this.connect = connect;
        this.persistenceDirectory = persistenceDirectory;
        this.validate();
    }
    /**
     * Returns true if the receiver has been frozen using
     * {@link DittoConfig.freeze | freeze()}.
     */
    get isFrozen() {
        return this._isFrozen;
    }
    /**
     * Deep freezes the receiver such that it can't be modified anymore.
     *
     * Use {@link DittoConfig.copy | copy()} to create a copy of the receiver that
     * is not frozen.
     *
     * Warning: this does not freeze legacy
     * {@link AuthenticationHandler | authentication handlers} referenced by the
     * identity. Changes inside the authentication handlers will be reflected in the
     * frozen {@link DittoConfig}.
     *
     * @see {@link DittoConfig.isFrozen}
     */
    freeze() {
        if (this.isFrozen)
            return this;
        this._isFrozen = true;
        Object.freeze(this.connect);
        Object.freeze(this);
        return this;
    }
    /**
     * Returns a deep copy of the receiver.
     *
     * The copy is not frozen, so it's properties can be modified.
     *
     * Warning: This does not create copies of
     * {@link AuthenticationHandler | authentication handlers} referenced by the
     * identity. Changes inside the authentication handlers will be reflected in the
     * copy.
     */
    copy() {
        // New config structure
        const copy = new DittoConfig(this.databaseID, { ...this.connect }, this.persistenceDirectory);
        return copy;
    }
    /** @internal */
    toCBOR() {
        try {
            const ffiConfig = toFFICBORData(this);
            // Logger.info(
            //   `Converting DittoConfig to CBOR: ${JSON.stringify(ffiConfig, null, 2)}`,
            // );
            return CBOR.encode(ffiConfig);
        }
        catch (error) {
            throw new DittoError('validation/invalid-ditto-config', `Failed to convert DittoConfig to CBOR: ${error.message}`);
        }
    }
    /**
     * Validates the config structure.
     *
     * Only covers type and presence validation as anything beyond that is handled
     * by core.
     */
    validate() {
        if (!this.databaseID) {
            throw new DittoError('validation/invalid-ditto-config', '`id` must be provided for DittoConfig.');
        }
        if (typeof this.databaseID !== 'string') {
            throw new DittoError('validation/invalid-ditto-config', `\`id\` must be of type string, but is of type '${typeof this.databaseID}': ${this.databaseID}`);
        }
        if (!this.connect) {
            throw new DittoError('validation/invalid-ditto-config', '`connect` must be provided for DittoConfig.');
        }
        if (typeof this.connect !== 'object') {
            throw new DittoError('validation/invalid-ditto-config', `\`connect\` must be an object, but is of type '${typeof this.connect}'.`);
        }
    }
}
/**
 * Converts a {@link DittoConfig} into a plain JS object that conforms to the
 * expected shape used in FFI.
 *
 * @internal
 */
function toFFICBORData(config) {
    var _a;
    let connectFFI;
    if (config.connect.mode === 'server') {
        connectFFI = {
            type: 'server',
            url: config.connect.url,
        };
    }
    else if (config.connect.mode === 'smallPeersOnly') {
        connectFFI = {
            type: 'small_peers_only',
        };
        if (config.connect.privateKey)
            connectFFI.private_key = config.connect.privateKey;
    }
    else {
        throw new DittoError('validation/invalid-ditto-config', `Unsupported connect mode: ${config.connect.mode}`);
    }
    const ffiConfig = {
        database_id: config.databaseID,
        connect: connectFFI,
        persistence_directory: (_a = config.persistenceDirectory) !== null && _a !== void 0 ? _a : null, // MUST not be undefined
        experimental: {}, // Currently no experimental features in JS SDK
    };
    return ffiConfig;
}
/**
 * Converts a FFI {@link DittoConfig} into a {@link DittoConfig} instance.
 *
 * @internal
 */
function fromFFICBORData(data) {
    let connect;
    if (data.connect.type === 'server') {
        connect = {
            mode: 'server',
            url: data.connect.url,
        };
    }
    else {
        connect = {
            mode: 'smallPeersOnly',
        };
        if (data.connect.private_key)
            connect.privateKey = data.connect.private_key;
    }
    return new DittoConfig(data.database_id, connect, data.persistence_directory);
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/**
 * Restore a `TransportConfig` from its serializable representation.
 *
 * @internal
 */
function transportConfigFromDeserializable(serialized) {
    const peerToPeerJSON = serialized['peer_to_peer'];
    const bluetoothLEJSON = peerToPeerJSON['bluetooth_le'];
    const bluetoothLEEnabled = bluetoothLEJSON['enabled'];
    const awdlJSON = peerToPeerJSON['awdl'];
    const awdlEnabled = awdlJSON['enabled'];
    const lanJSON = peerToPeerJSON['lan'];
    const lanEnabled = lanJSON['enabled'];
    const lanMdnsEnabled = lanJSON['mdns_enabled'];
    const lanMulticastEnabled = lanJSON['multicast_enabled'];
    const wifiAwareJSON = peerToPeerJSON['wifi_aware'];
    const wifiAwareEnabled = wifiAwareJSON['enabled'];
    const connectJSON = serialized['connect'];
    const connectTcpServers = connectJSON['tcp_servers'];
    const connectWebsocketURLs = connectJSON['websocket_urls'];
    const connectRetryInterval = connectJSON['retry_interval'];
    const listenJSON = serialized['listen'];
    const tcpJSON = listenJSON['tcp'];
    const tcpEnabled = tcpJSON['enabled'];
    const tcpInterfaceIP = tcpJSON['interface_ip'];
    const tcpPort = tcpJSON['port'];
    const httpJSON = listenJSON['http'];
    const httpEnabled = httpJSON['enabled'];
    const httpInterfaceIP = httpJSON['interface_ip'];
    const httpPort = httpJSON['port'];
    const httpStaticContentPath = httpJSON['static_content_path'];
    const httpWebsocketSync = httpJSON['websocket_sync'];
    const httpTLSKeyPath = httpJSON['tls_key_path'];
    const httpTLSCertificatePath = httpJSON['tls_certificate_path'];
    const globalJSON = serialized['global'];
    const globalSyncGroup = globalJSON['sync_group'];
    const globalRoutingHint = globalJSON['routing_hint'];
    const config = new TransportConfig();
    config.peerToPeer.bluetoothLE.isEnabled = bluetoothLEEnabled;
    config.peerToPeer.awdl.isEnabled = awdlEnabled;
    config.peerToPeer.lan.isEnabled = lanEnabled;
    config.peerToPeer.lan.isMdnsEnabled = lanMdnsEnabled;
    config.peerToPeer.lan.isMulticastEnabled = lanMulticastEnabled;
    config.peerToPeer.wifiAware.isEnabled = wifiAwareEnabled;
    config.connect.tcpServers = connectTcpServers;
    config.connect.websocketURLs = connectWebsocketURLs;
    config.connect.retryInterval = connectRetryInterval;
    config.listen.tcp.isEnabled = tcpEnabled;
    config.listen.tcp.interfaceIP = tcpInterfaceIP;
    config.listen.tcp.port = tcpPort;
    config.listen.http.isEnabled = httpEnabled;
    config.listen.http.interfaceIP = httpInterfaceIP;
    config.listen.http.port = httpPort;
    config.listen.http.staticContentPath = httpStaticContentPath;
    config.listen.http.websocketSync = httpWebsocketSync;
    config.listen.http.tlsKeyPath = httpTLSKeyPath;
    config.listen.http.tlsCertificatePath = httpTLSCertificatePath;
    config.global.syncGroup = globalSyncGroup;
    config.global.routingHint = globalRoutingHint;
    return config;
}
/**
 * Convert a `TransportConfig` to a serializable representation.
 *
 * This mainly involves converting the `TransportConfig`'s properties to have the expected key names
 * and casing.
 *
 * @internal
 */
function transportConfigToSerializable(config) {
    const peerToPeer = config.peerToPeer;
    const connect = config.connect;
    const listen = config.listen;
    const global = config.global;
    const serialized = {
        peer_to_peer: {
            bluetooth_le: {
                enabled: peerToPeer.bluetoothLE.isEnabled,
            },
            awdl: {
                enabled: peerToPeer.awdl.isEnabled,
            },
            wifi_aware: {
                enabled: peerToPeer.wifiAware.isEnabled,
            },
            lan: {
                enabled: peerToPeer.lan.isEnabled,
                mdns_enabled: peerToPeer.lan.isMdnsEnabled,
                multicast_enabled: peerToPeer.lan.isMulticastEnabled,
            },
        },
        connect: {
            tcp_servers: connect.tcpServers,
            websocket_urls: connect.websocketURLs,
            retry_interval: connect.retryInterval,
        },
        listen: {
            tcp: {
                enabled: listen.tcp.isEnabled,
                interface_ip: listen.tcp.interfaceIP,
                port: listen.tcp.port,
            },
            http: {
                enabled: listen.http.isEnabled,
                interface_ip: listen.http.interfaceIP,
                port: listen.http.port,
                websocket_sync: listen.http.websocketSync,
            },
        },
        global: {
            sync_group: global.syncGroup,
            routing_hint: global.routingHint,
        },
    };
    // Only set the optional properties if they are not undefined
    if (listen.http.staticContentPath) {
        serialized.listen.http['static_content_path'] =
            listen.http.staticContentPath;
    }
    if (listen.http.tlsKeyPath)
        serialized.listen.http['tls_key_path'] = listen.http.tlsKeyPath;
    if (listen.http.tlsCertificatePath) {
        serialized.listen.http['tls_certificate_path'] =
            listen.http.tlsCertificatePath;
    }
    return serialized;
}
const NO_PREFERRED_ROUTE_HINT = 0;
/**
 * A configuration object specifying which network transports Ditto should
 * use to sync data.
 *
 * A Ditto object comes with a default transport configuration where all
 * available transports are enabled (for example, regarding peer-to-peer transports,
 * Bluetooth LE and LAN on every platform, plus AWDL on Apple platforms or
 * Wi‑Fi Aware on Android). You can customize this by copying that or
 * initializing a new `TransportConfig`, adjusting its properties, and supplying
 * it to `setTransportConfig()` on `Ditto`.
 *
 * When you initialize a new `TransportConfig` instance, all  transports are
 * disabled. You must enable each one explicitly.
 *
 * Platform‑supported transports can also be toggled in a single call with
 * {@link setAvailablePeerToPeerEnabled | setAvailablePeerToPeerEnabled()}.
 *
 * Peer-to-peer transports will automatically discover peers in the vicinity
 * and create connections without any configuration. These are configured via
 * the `peerToPeer` property. To turn each one on, set its `isEnabled` property
 * to `true`.
 *
 * To connect to a peer at a known location, such as a Ditto Big Peer, add its
 * address inside the connect configuration. These are either "host:port"
 * strings for raw TCP sync, or a "wss://…" URL for websockets.
 *
 * The listen configurations are for specific less common data sync scenarios.
 * Please read the documentation on the Ditto website for examples. Incorrect
 * use of listen can result in insecure configurations.
 *
 * **IMPORTANT**: when running in the browser, only the `connect.websocketURLs`
 * part is considered, the rest of the configuration is ignored.
 */
class TransportConfig {
    /**
     * Create a new transport config initialized with the default settings.
     */
    constructor() {
        this._isFrozen = false;
        this.peerToPeer = {
            bluetoothLE: { isEnabled: false },
            awdl: { isEnabled: false },
            lan: { isEnabled: false, isMdnsEnabled: true, isMulticastEnabled: true },
            wifiAware: { isEnabled: false },
        };
        this.connect = {
            tcpServers: [],
            websocketURLs: [],
            retryInterval: 5000,
        };
        this.listen = {
            tcp: {
                isEnabled: false,
                interfaceIP: '[::]',
                port: 4040,
            },
            http: {
                isEnabled: false,
                interfaceIP: '[::]',
                port: 80,
                websocketSync: true,
            },
        };
        this.global = {
            syncGroup: 0,
            routingHint: NO_PREFERRED_ROUTE_HINT,
        };
    }
    /**
     * Enables or disables _every_ peer-to-peer transport protocols defined in
     * {@link peerToPeer} regardless of whether the current platform
     * can actually drive those transport implementations.
     *
     * Throws if receiver is frozen.
     *
     * @deprecated Use {@link setAvailablePeerToPeerEnabled | setAvailablePeerToPeerEnabled()}. instead.
     */
    setAllPeerToPeerEnabled(enabled) {
        this.peerToPeer.bluetoothLE.isEnabled = enabled;
        this.peerToPeer.lan.isEnabled = enabled;
        this.peerToPeer.awdl.isEnabled = enabled;
        this.peerToPeer.wifiAware.isEnabled = enabled;
    }
    /**
     * Enables or disables the peer-to-peer transport protocols defined in
     * {@link TransportConfigPeerToPeer} that are supported on the current platform.
     *
     * You can check the list of available transports for each platform at
     * https://ditto.com/link/sdk-latest-compatibility
     */
    setAvailablePeerToPeerEnabled(enabled) {
        const isNodeMacOS = process.platform === 'darwin';
        const isReactNative = isReactNativeBuild;
        const isReactNativeiOS = isReactNative;
        this.peerToPeer.bluetoothLE.isEnabled = enabled;
        this.peerToPeer.lan.isEnabled = enabled;
        this.peerToPeer.wifiAware.isEnabled = false;
        this.peerToPeer.awdl.isEnabled =
            isNodeMacOS || isReactNativeiOS ? enabled : false;
    }
    /**
     * Returns `true` if the transport configuration is frozen, otherwise
     * returns `false`.
     */
    get isFrozen() {
        return this._isFrozen;
    }
    /**
     * (Deep) freezes the receiver such that it can't be modified anymore.
     */
    freeze() {
        if (this.isFrozen)
            return this;
        this._isFrozen = true;
        Object.freeze(this.peerToPeer.bluetoothLE);
        Object.freeze(this.peerToPeer.awdl);
        Object.freeze(this.peerToPeer.lan);
        Object.freeze(this.peerToPeer.wifiAware);
        Object.freeze(this.peerToPeer);
        Object.freeze(this.connect.tcpServers);
        Object.freeze(this.connect.websocketURLs);
        Object.freeze(this.connect);
        Object.freeze(this.listen.tcp);
        Object.freeze(this.listen.http);
        Object.freeze(this.listen);
        Object.freeze(this.global);
        Object.freeze(this);
        return this;
    }
    /**
     * Returns a (deep) copy of the receiver.
     */
    copy() {
        const copy = new TransportConfig();
        copy.peerToPeer.bluetoothLE.isEnabled =
            this.peerToPeer.bluetoothLE.isEnabled;
        copy.peerToPeer.awdl.isEnabled = this.peerToPeer.awdl.isEnabled;
        copy.peerToPeer.lan.isEnabled = this.peerToPeer.lan.isEnabled;
        copy.peerToPeer.lan.isMdnsEnabled = this.peerToPeer.lan.isMdnsEnabled;
        copy.peerToPeer.lan.isMulticastEnabled =
            this.peerToPeer.lan.isMulticastEnabled;
        copy.peerToPeer.wifiAware.isEnabled = this.peerToPeer.wifiAware.isEnabled;
        copy.connect.tcpServers = this.connect.tcpServers.slice();
        copy.connect.websocketURLs = this.connect.websocketURLs.slice();
        copy.connect.retryInterval = this.connect.retryInterval;
        copy.listen.tcp = { ...this.listen.tcp };
        copy.listen.http = { ...this.listen.http };
        copy.global.syncGroup = this.global.syncGroup;
        copy.global.routingHint = this.global.routingHint;
        return copy;
    }
    /**
     * Returns `true` if passed in TCP configurations are equal, otherwise
     * returns `false`.
     */
    static areListenTCPsEqual(left, right) {
        return (left.isEnabled === right.isEnabled &&
            left.interfaceIP === right.interfaceIP &&
            left.port === right.port);
    }
    /**
     * Returns `true` if passed in HTTP configurations are equal, otherwise
     * returns `false`.
     */
    static areListenHTTPsEqual(left, right) {
        return (left.isEnabled === right.isEnabled &&
            left.interfaceIP === right.interfaceIP &&
            left.port === right.port &&
            // Optional properties
            left.staticContentPath === right.staticContentPath &&
            left.websocketSync === right.websocketSync &&
            left.tlsKeyPath === right.tlsKeyPath &&
            left.tlsCertificatePath === right.tlsCertificatePath);
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/**
 * These objects are returned by calls to
 * {@link Store.fetchAttachment | ditto.store.fetchAttachment()}
 * and allow you to stop an in-flight attachment fetch.
 */
class AttachmentFetcher {
    /**
     * Stops fetching the associated attachment and cleans up any associated
     * resources.
     *
     * Note that you are not required to call `stop()` once your attachment fetch
     * operation has finished. The method primarily exists to allow you to cancel
     * an attachment fetch request while it is ongoing if you no longer wish for
     * the attachment to be made available locally to the device.
     */
    stop() {
        // No need for synchronicity here: we let the "stop promise" float / run in
        // a detached fashion since there is no point in awaiting the "stop
        // signaling" itself.
        if (this.manager == null) {
            // Case where the fetcher was started from `Store.fetchAttachment()`.
            if (!this.isStopped) {
                this.rejectPendingFetch();
                this.rejectPendingFetch = null;
            }
            this.ditto.store.removeAttachmentFetcher(this);
            const dittoHandle = Bridge.ditto.handleFor(this.ditto);
            void this.ditto.deferCloseAsync(async () => {
                // Cancel the fetcher if it is still running.
                const cancelToken = await this.cancelTokenPromise;
                if (cancelToken) {
                    dittoCancelResolveAttachment(dittoHandle.deref(), this.token.idBytes, cancelToken);
                }
            });
        }
        else {
            // Legacy case where the fetcher was started from `Collection.fetchAttachment()`.
            void step(async () => {
                await this.manager.stopAttachmentFetcher(this);
                if (this.rejectPendingFetch != null) {
                    this.rejectPendingFetch();
                    this.rejectPendingFetch = null;
                }
            });
        }
    }
    /** @internal */
    then(onfulfilled, onrejected) {
        return this.attachment.then(onfulfilled, onrejected);
    }
    /** @internal */
    constructor(ditto, token, manager, eventHandler) {
        // --------------------------------------- Internal ------------------------
        /** @internal */
        this.cancelTokenPromise = null;
        /**
         * This function is defined while a fetch is in progress and is used to reject
         * the promise `this.attachment` when the fetch is canceled.
         *
         * @internal
         */
        this.rejectPendingFetch = null;
        this.ditto = ditto;
        this.token = token;
        this.manager = manager;
        this.id = cryptoGenerateSecureRandomToken();
        const eventHandlerOrNoOp = eventHandler || function () { };
        const dittoHandle = Bridge.ditto.handleFor(ditto);
        this.attachment = new Promise((resolve, reject) => {
            // REFACTOR: The callbacks hold quite a bunch of objects with most
            // probably lead to retain cycles and therefore memory leaks. This needs
            // to be
            // fixed.
            const onComplete = (attachmentHandlePointer) => {
                const attachment = new Attachment(this.ditto, this.token);
                Bridge.attachment.bridge(attachmentHandlePointer, () => attachment);
                eventHandlerOrNoOp({ type: 'Completed', attachment });
                this.rejectPendingFetch = null;
                resolve(attachment);
            };
            const onProgress = (downloaded, toDownload) => {
                eventHandlerOrNoOp({
                    type: 'Progress',
                    totalBytes: toDownload,
                    downloadedBytes: downloaded,
                });
            };
            const onDelete = () => {
                eventHandlerOrNoOp({ type: 'Deleted' });
                if (this.manager != null) {
                    // Legacy behavior: when the attachment is deleted while being fetched
                    // the fetcher is stopped and the promise is resolved to `null`.
                    this.rejectPendingFetch = null;
                    resolve(null);
                }
                else {
                    this.rejectPendingFetch = null;
                    reject(new DittoError('store/attachment-not-found', 'The attachment was deleted while being fetched.'));
                }
            };
            const onError = () => {
            };
            // The core doesn't call any of the handlers defined above when a fetch is
            // cancelled through `this.stop()` so we use this function to reject the
            // promise from the outside.
            this.rejectPendingFetch = () => {
                const err = this.manager != null
                    ? new Error('Attachment fetch was canceled')
                    : new DittoError('store/failed-to-fetch-attachment', 'Attachment fetch was canceled');
                reject(err);
            };
            // `cancelTokenPromise` resolves once the fetcher has been initialised in
            // core. This constructor is sync and thus can't await the promise. That
            // only happens when the cancel token is used, either in `stop()` (for
            // fetchers started from `Store.fetchAttachment()`) or in
            // `AttachmentFetcherManager.stopWithContextInfo()` (for fetchers started
            // from `Collection.fetchAttachment()`).
            //
            // In addition, we want to be able to intercept errors that occur after
            // this constructor has returned. For that, the whole creation of the
            // cancel token is wrapped in an inline async function that catches any
            // errors and then doesn't reject the cancel token promise, but the
            // `attachment` promise and through that the `AttachmentFetcher` itself.
            const weakThis = new WeakRef(this);
            // @ts-expect-error setting readonly property
            this.cancelTokenPromise = (async () => {
                try {
                    return await mapFFIErrorsAsync(async () => dittoResolveAttachment(dittoHandle.deref(), token.idBytes, { onComplete, onProgress, onDelete }, onError), {
                        1: [
                            'store/failed-to-fetch-attachment',
                            'Failed to fetch the attachment.',
                        ],
                        2: [
                            'store/attachment-token-invalid',
                            'The attachment token was invalid.',
                        ],
                        3: [
                            'store/attachment-not-found',
                            'The attachment was not found.',
                        ],
                    });
                }
                catch (e) {
                    let isDeleted = false;
                    // Legacy behavior: when the attachment is deleted before the fetch is
                    // started, the fetcher is stopped and the promise is resolved to
                    // `null`.
                    if (e instanceof DittoError &&
                        e.code === 'store/attachment-not-found') {
                        isDeleted = true;
                        eventHandlerOrNoOp({ type: 'Deleted' });
                    }
                    Logger.error(e.message);
                    const strongThis = weakThis.deref();
                    if (strongThis == null) {
                        // The fetcher was already gc'd, so it's not possible to reject the
                        // `attachment` promise anymore. We stop here as the error has been
                        // logged.
                        return null;
                    }
                    // When this is called from legacy `Collection.fetchAttachment()`, we
                    // convert the DittoError to a regular Error.
                    if (strongThis.manager != null && e instanceof DittoError)
                        e = new Error(e.message);
                    strongThis.rejectPendingFetch = null;
                    // Reject the `attachment` promise to signal that the fetch has
                    // failed, unless this is a legacy fetcher and the attachment was
                    // deleted.
                    if (strongThis.manager != null && isDeleted)
                        resolve(null);
                    else
                        reject(e);
                    // Set cancelTokenPromise to null to indicate that there is nothing to
                    // cancel anymore.
                    return null;
                }
            })();
        });
        if (manager == null) {
            // Remove the attachment fetcher once it is done.
            this.attachment
                .then(() => {
                this.rejectPendingFetch = null;
                this.ditto.store.removeAttachmentFetcher(this);
            })
                .catch(() => {
                this.rejectPendingFetch = null;
                this.ditto.store.removeAttachmentFetcher(this);
            });
        }
    }
    /**
     * `true` if the fetcher has completed or was stopped.
     *
     * @internal
     */
    get isStopped() {
        return this.rejectPendingFetch == null;
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/**
 * Used to subscribe to receive updates from remote peers about matching
 * documents.
 *
 * While {@link Subscription} objects remain in scope they ensure that documents
 * in the collection specified and that match the query provided will try to be
 * kept up-to-date with the latest changes from remote peers.
 *
 * This class is used by Ditto's query builder APIs.
 * @see {@link SyncSubscription} for the DQL equivalent.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class Subscription {
    /**
     * Returns `true` if subscription has been explicitly cancelled, `false`
     * otherwise.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get isCancelled() {
        return this._isCancelled;
    }
    /**
     * The name of the collection that the subscription is based on.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get collectionName() {
        return this.collection.name;
    }
    /**
     * Cancels a subscription and releases all associated resources.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    cancel() {
        if (!this.isCancelled) {
            this._isCancelled = true;
            this.manager.remove(this);
        }
    }
    // ----------------------------------------------------------- Internal ------
    /** @internal */
    constructor(collection, query, queryArgsCBOR, orderBys, limit, offset) {
        this._isCancelled = false;
        // Query should be validated at this point.
        this.query = query;
        this.queryArgsCBOR = queryArgsCBOR;
        this.collection = collection;
        this.contextInfo = {
            id: cryptoGenerateSecureRandomToken(),
            collectionName: collection.name,
            query,
            queryArgsCBOR,
            orderBys,
            limit,
            offset,
        };
        this.manager = collection.store.ditto.subscriptionManager;
        this.manager.add(this);
        Logger.warning(`Subscription is deprecated, use ditto.sync.registerSubscription() instead. ` +
            `For more information see: ` +
            `https://ditto.com/link/dql-legacy-to-dql-adoption`);
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
// -----------------------------------------------------------------------------
/**
 * First event fired immediately after registering a live query without any
 * mutations. All subsequent events are of type {@link LiveQueryEventUpdate}.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class LiveQueryEventInitial {
    constructor() {
        /**
         * Whether or not this is the initial event being delivered. Always `true` for
         * `LiveQueryEventInitial`.
         *
         * @deprecated Use DQL (Ditto Query Language) instead. For more information
         * see: https://ditto.com/link/dql-legacy-to-dql-adoption
         */
        this.isInitial = true;
    }
    /**
     * Returns a hash that represents the set of matching documents.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    hash(documents) {
        Logger.warning('Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption');
        const documentHandles = Bridge.document.handlesFor(documents);
        return documentsHash(documentHandles.deref());
    }
    /**
     * Returns a pattern of words that together create a mnemonic, which
     * represents the set of matching documents.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    hashMnemonic(documents) {
        Logger.warning('Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption');
        const documentHandles = Bridge.document.handlesFor(documents);
        return documentsHashMnemonic(documentHandles.deref());
    }
}
// -----------------------------------------------------------------------------
/**
 * Represents an update event describing all changes that occured for documents
 * covered by a (live) query.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class LiveQueryEventUpdate {
    /**
     * Returns a hash that represents the set of matching documents.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    hash(documents) {
        Logger.warning('LiveQueryEventUpdate.hash() is deprecated, use Document.hash() instead');
        const documentHandles = Bridge.document.handlesFor(documents);
        return documentsHash(documentHandles.deref());
    }
    /**
     * Returns a pattern of words that together create a mnemonic, which
     * represents the set of matching documents.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    hashMnemonic(documents) {
        Logger.warning('LiveQueryEventUpdate.hashMnemonic() is deprecated, use Document.hashMnemonic() instead');
        const documentHandles = Bridge.document.handlesFor(documents);
        return documentsHashMnemonic(documentHandles.deref());
    }
    /** @internal */
    constructor(params) {
        /**
         * Whether or not this is the initial event being delivered. Always `false`
         * for `LiveQueryEventUpdate`.
         *
         * @deprecated Use DQL (Ditto Query Language) instead. For more information
         * see: https://ditto.com/link/dql-legacy-to-dql-adoption
         */
        this.isInitial = false;
        this.oldDocuments = params.oldDocuments;
        this.insertions = params.insertions;
        this.deletions = params.deletions;
        this.updates = params.updates;
        this.moves = params.moves;
    }
}
// -----------------------------------------------------------------------------
/**
 * Provides information about a live query event relating to a single document
 * live query.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class SingleDocumentLiveQueryEvent {
    /**
     * Returns a hash that represents the set of matching documents.
     *
     * @deprecated use {@link Document.hash | Document.hash()} instead.
     */
    hash(document) {
        Logger.warning('SingleDocumentLiveQueryEvent.hash() is deprecated, use Document.hash() instead');
        const documentHandles = Bridge.document.handlesFor(document == null ? [] : [document]);
        return documentsHash(documentHandles.deref());
    }
    /**
     * Returns a pattern of words that together create a mnemonic, which
     * represents the set of matching documents.
     *
     * @deprecated use {@link Document.hashMnemonic | Document.hashMnemonic()}
     * instead.
     */
    hashMnemonic(document) {
        Logger.warning('SingleDocumentLiveQueryEvent.hashMnemonic() is deprecated, use Document.hashMnemonic() instead');
        const documentHandles = Bridge.document.handlesFor(document == null ? [] : [document]);
        return documentsHashMnemonic(documentHandles.deref());
    }
    /** @internal */
    constructor(isInitial, oldDocument) {
        this.isInitial = isInitial;
        this.oldDocument = oldDocument;
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/**
 * The type that is returned when calling
 * {@link PendingCursorOperation.observeLocal | observeLocal()} on a
 * {@link PendingCursorOperation} object. It handles the logic for calling the
 * event handler that is provided to `observeLocal()` calls.
 *
 * Ditto will prevent the process from exiting as long as there are active live
 * queries (not relevant when running in the browser).
 *
 * `LiveQuery` objects must be kept in scope for as long as you wish to have
 * your event handler be called when there is an update to a document matching
 * the query you provide. When you no longer want to receive updates about
 * documents matching a query then you must call {@link stop | stop()}.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class LiveQuery {
    /**
     * The name of the collection that the live query is based on.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get collectionName() {
        return this.collection.name;
    }
    /**
     * Returns true if the receiver has been stopped.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get isStopped() {
        return !this.liveQueryManager;
    }
    /**
     * Stop the live query from delivering updates.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    stop() {
        if (!this.isStopped)
            this.liveQueryManager.stopLiveQuery(this);
    }
    /**
     * The ID of this live query.
     * @internal
     */
    get liveQueryID() {
        return this._liveQueryID;
    }
    /** @internal */
    constructor(query, queryArgs, queryArgsCBOR, orderBys, limit, offset, collection, handler) {
        // Query should be validated at this point.
        this.query = query;
        this.queryArgs = queryArgs ? Object.freeze({ ...queryArgs }) : null;
        this.queryArgsCBOR = queryArgsCBOR;
        this.orderBys = orderBys;
        this.limit = limit;
        this.offset = offset;
        this.collection = collection;
        this.handler = handler;
        this.liveQueryManager = null;
        const collectionName = collection.name;
        const weakDitto = new WeakRef(collection.store.ditto);
        Logger.warning(`LiveQuery is deprecated, use ditto.store.registerObserver() instead. ` +
            `For more information see: ` +
            `https://ditto.com/link/dql-legacy-to-dql-adoption`);
        let liveQueryID = undefined;
        const signalNext = async () => {
            const ditto = weakDitto.deref();
            if (!ditto || ditto.isClosed)
                return;
            return ditto.deferCloseAsync(async (dittoHandle) => {
                await liveQuerySignalAvailableNext(dittoHandle.deref(), liveQueryID);
            });
        };
        const ditto = collection.store.ditto;
        ditto.deferClose((dittoHandle) => {
            liveQueryID = liveQueryRegister(dittoHandle.deref(), collectionName, query, queryArgsCBOR, this.orderBys, limit, offset, (cCBParams) => {
                const documents = cCBParams.documents.map((ptr) => Bridge.document.bridge(ptr));
                let event;
                if (cCBParams.is_initial) {
                    event = new LiveQueryEventInitial();
                }
                else {
                    event = new LiveQueryEventUpdate({
                        oldDocuments: cCBParams.old_documents.map((ptr) => Bridge.document.bridge(ptr)),
                        // We don't need to bridge these indices which are returned from FFI
                        // as JS values and not as pointers. c.f.
                        // https://dittolive.slack.com/archives/C01NLL95095/p1720609380387539
                        insertions: cCBParams.insertions,
                        deletions: cCBParams.deletions,
                        updates: cCBParams.updates,
                        moves: cCBParams.moves.map((move) => ({
                            from: move[0],
                            to: move[1],
                        })),
                    });
                }
                // We discard the return promise because error-handling is not supported.
                void handler(documents, event, signalNext);
            });
        });
        if (!liveQueryID) {
            throw new Error("Internal inconsistency, couldn't create a valid live query ID.");
        }
        this._liveQueryID = liveQueryID;
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
// -----------------------------------------------------------------------------
/**
 * These objects are returned when using `find`-like functionality on
 * {@link Collection}.
 *
 * They allow chaining of further query-related functions to do things like add
 * a limit to the number of documents you want returned or specify how you want
 * the documents to be sorted and ordered.
 *
 * You can either call {@link exec | exec()} on the object to get an array of
 * {@link Document | documents} as an immediate return value, or you can
 * establish either a live query or a subscription, which both work over time.
 *
 * A live query, established by calling
 * {@link PendingCursorOperation.observeLocal | observeLocal()}, will notify you
 * every time there's an update to a document that matches the query you
 * provided in the preceding `find`-like call.
 *
 * A subscription, established by calling
 * {@link PendingCursorOperation.subscribe | subscribe()}, will act as a signal
 * to other peers that the device connects to that you would like to receive
 * updates from them about documents that match the query you provided in the
 * preceding `find`-like call.
 *
 * Update and remove functionality is also exposed through this object.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class PendingCursorOperation extends BasePendingCursorOperation {
    sort(propertyPath, direction = 'ascending') {
        return super.sort(propertyPath, direction);
    }
    offset(offset) {
        return super.offset(offset);
    }
    limit(limit) {
        return super.limit(limit);
    }
    async remove() {
        const ditto = this.collection.store.ditto;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            const query = this.query;
            const documentsX = await performAsyncToWorkaroundNonAsyncFFIAPI(async () => {
                const writeTransactionX = await writeTransaction(dittoHandle.deref());
                const results = await collectionRemoveQueryStr(dittoHandle.deref(), this.collection.name, writeTransactionX, query, this.queryArgsCBOR, this.orderBys, this.currentLimit, this.currentOffset);
                await writeTransactionCommit(dittoHandle.deref(), writeTransactionX);
                return results;
            });
            return documentsX.map((idCBOR) => {
                return new DocumentID(idCBOR, true);
            });
        });
    }
    async evict() {
        const ditto = this.collection.store.ditto;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            const query = this.query;
            const documentsX = await performAsyncToWorkaroundNonAsyncFFIAPI(async () => {
                const writeTransactionX = await writeTransaction(dittoHandle.deref());
                const results = await collectionEvictQueryStr(dittoHandle.deref(), this.collection.name, writeTransactionX, query, this.queryArgsCBOR, this.orderBys, this.currentLimit, this.currentOffset);
                await writeTransactionCommit(dittoHandle.deref(), writeTransactionX);
                return results;
            });
            return documentsX.map((idCBOR) => {
                return new DocumentID(idCBOR, true);
            });
        });
    }
    async update(closure) {
        const ditto = this.collection.store.ditto;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            return await performAsyncToWorkaroundNonAsyncFFIAPI(async () => {
                return await super.updateWithClosure(closure, 'cursor operation update()');
            });
        });
    }
    /**
     * Enables you to subscribe to changes that occur in a collection remotely.
     *
     * Having a subscription acts as a signal to other peers that you are
     * interested in receiving updates when local or remote changes are made to
     * documents that match the query generated by the chain of operations that
     * precedes the call to {@link subscribe | subscribe()}.
     *
     * The returned {@link Subscription} object must be kept in scope for as long
     * as you want to keep receiving updates.
     *
     * @throws {Error} when called in a React Native environment.
     *
     * @returns A {@link Subscription} object that must be kept in scope for as
     * long as you want to keep receiving updates for documents that match the
     * query specified in the preceding chain.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    subscribe() {
        const subscription = new Subscription(this.collection, this.query, this.queryArgsCBOR, this.orderBys, this.currentLimit, this.currentOffset);
        this.collection.store.ditto.subscriptionManager.add(subscription);
        return subscription;
    }
    /**
     * Enables you to listen for changes that occur in a collection locally.
     *
     * The `handler` block will be called when local changes are made to documents
     * that match the query generated by the chain of operations that precedes the
     * call to {@link PendingCursorOperation.observeLocal | observeLocal()}. The
     * returned {@link LiveQuery} object must be kept in scope for as long as you
     * want the provided `handler` to be called when an update occurs.
     *
     * This won't subscribe to receive changes made remotely by others and so it
     * will only fire updates when a local change is made. If you want to receive
     * remotely performed updates as well, you'll have to create a subscription
     * via {@link PendingCursorOperation.subscribe | subscribe()} with the
     * relevant query. The returned {@link LiveQuery} object must be kept in scope
     * for as long as you want the provided `eventHandler` to be called when an
     * update occurs.
     *
     * @param handler A closure that will be called every time there is a
     * transaction committed to the store that involves modifications to documents
     * matching the query in the collection this method was called on.
     *
     * @throws {Error} when called in a React Native environment.
     *
     * @return A {@link LiveQuery} object that must be kept in scope for as long
     * as you want to keep receiving updates.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    observeLocal(handler) {
        return this._observe(handler, false);
    }
    /**
     * Enables you to listen for changes that occur in a collection locally and to
     * signal when you are ready for the live query to deliver the next event.
     *
     * The `handler` block will be called when local changes are made to documents
     * that match the query generated by the chain of operations that precedes the
     * call to
     * {@link PendingCursorOperation.observeLocalWithNextSignal | observeLocalWithNextSignal()}.
     * The returned {@link LiveQuery} object must be kept in scope for as long as
     * you want the provided `handler` to be called when an update occurs.
     *
     * This won't subscribe to receive changes made remotely by others and so it
     * will only fire updates when a local change is made. If you want to receive
     * remotely performed updates as well, you'll have to create a subscription
     * via {@link PendingCursorOperation.subscribe | subscribe()} with the
     * relevant query. The returned {@link LiveQuery} object must be kept in scope
     * for as long as you want the provided `eventHandler` to be called when an
     * update occurs.
     *
     * @param handler A closure that will be called every time there is a
     * transaction committed to the store that involves modifications to documents
     * matching the query in the collection that this method was called on.
     *
     * @throws {Error} when called in a React Native environment.
     *
     * @return A {@link LiveQuery} object that must be kept in scope for as long
     * as you want to keep receiving updates.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    observeLocalWithNextSignal(handler) {
        return this._observe(handler, true);
    }
    // ----------------------------------------------------------- Internal ------
    /** @internal */
    constructor(query, queryArgs, collection) {
        super(query, queryArgs, collection);
        Logger.warning(`Cursor operations are deprecated, use DQL (Ditto Query Language) instead. ` +
            `See https://ditto.com/link/dql-legacy-to-dql-adoption`);
    }
    /** @internal */
    _observe(handler, waitForNextSignal) {
        async function wrappedHandler(documents, event, nextSignal) {
            try {
                return await handler.call(this, documents, event);
            }
            finally {
                nextSignal();
            }
        }
        const handlerOrWrapped = waitForNextSignal
            ? handler
            : wrappedHandler;
        const liveQuery = new LiveQuery(this.query, this.queryArgs, this.queryArgsCBOR, this.orderBys, this.currentLimit, this.currentOffset, this.collection, handlerOrWrapped);
        this.collection.store.ditto.liveQueryManager.startLiveQuery(liveQuery);
        return liveQuery;
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
// -----------------------------------------------------------------------------
/**
 * These objects are returned when using {@link Collection.findByID | findByID()}
 * functionality on {@link Collection | collections}.
 *
 * You can either call {@link exec | exec()} on the  object to get an immediate
 * return value, or you can establish either a live query or a subscription,
 * which both work over time.
 *
 * A live query, established by calling
 * {@link PendingIDSpecificOperation.observeLocal | observeLocal()}, will notify
 * you every time there's an update to the document with the ID you provided in
 * the preceding {@link Collection.findByID | findByID()} call.
 *
 * A subscription, established by calling {@link PendingIDSpecificOperation.subscribe | subscribe()}, will
 * act as a signal to other peers that you would like to receive updates from
 * them about the document with the ID you provided in the preceding
 * {@link Collection.findByID | findByID()} call.
 *
 * Update and remove functionality is also exposed through this object.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class PendingIDSpecificOperation extends BasePendingIDSpecificOperation {
    async remove() {
        const ditto = this.collection.store.ditto;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            return await performAsyncToWorkaroundNonAsyncFFIAPI(async () => {
                const writeTransactionX = await writeTransaction(dittoHandle.deref());
                const didRemove = await collectionRemove(dittoHandle.deref(), this.collection.name, writeTransactionX, this.documentIDCBOR);
                await writeTransactionCommit(dittoHandle.deref(), writeTransactionX);
                return didRemove;
            });
        });
    }
    async evict() {
        const ditto = this.collection.store.ditto;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            return await performAsyncToWorkaroundNonAsyncFFIAPI(async () => {
                const writeTransactionX = await writeTransaction(dittoHandle.deref());
                const didEvict = await collectionEvict(dittoHandle.deref(), this.collection.name, writeTransactionX, this.documentIDCBOR);
                await writeTransactionCommit(dittoHandle.deref(), writeTransactionX);
                return didEvict;
            });
        });
    }
    async update(closure) {
        return this.updateWithClosure(closure, false, true, 'ID-specific cursor operation update()');
    }
    async updateV2(closure) {
        return this.updateWithClosure(closure, true, false, 'ID-specific cursor operation updateV2()');
    }
    /**
     * Enables you to subscribe to changes that occur in relation to a document
     * remotely.
     *
     * Having a subscription acts as a signal to other peers that you are
     * interested in receiving updates when local or remote changes are made to
     * the relevant document.
     *
     * The returned {@link Subscription} object must be kept in scope for as long
     * as you want to keep receiving updates.
     *
     * @returns A {@link Subscription} object that must be kept in scope for as
     * long as you want to keep receiving updates for the document.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
  
     */
    subscribe() {
        const subscription = new Subscription(this.collection, this.query, null, [], -1, 0);
        this.collection.store.ditto.subscriptionManager.add(subscription);
        return subscription;
    }
    /**
     * Enables you to listen for changes that occur in relation to a document
     * locally.
     *
     * This won't subscribe to receive changes made remotely by others and so it
     * will only fire updates when a local change is made. If you want to receive
     * remotely performed updates as well, you'll have to create a subscription
     * via {@link PendingIDSpecificOperation.subscribe | subscribe()} for the same
     * document ID.
     *
     * The returned {@link LiveQuery} object must be kept in scope for as long as
     * you want the provided `handler` to be called when an update occurs.
     *
     * @param handler A block that will be called every time there is a
     * transaction committed to the store that involves a modification to the
     * document with the relevant ID in the collection that
     * {@link PendingIDSpecificOperation.observeLocal | observeLocal()} was called
     * on.
     *
     * @returns A {@link LiveQuery} object that must be kept in scope for as long
     * as you want to keep receiving updates.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
  
     */
    observeLocal(handler) {
        return this._observe(handler, false);
    }
    /**
     * Enables you to listen for changes that occur in relation to a document
     * locally and to signal when you are ready for the live query to deliver the
     * next event.
     *
     * This won't subscribe to receive changes made remotely by others and so it
     * will only fire updates when a local change is made. If you want to receive
     * remotely performed updates as well, you'll have to create a subscription
     * via {@link PendingIDSpecificOperation.subscribe | subscribe()} for the same
     * document ID.
     *
     * The returned {@link LiveQuery} object must be kept in scope for as long as
     * you want the provided `handler` to be called when an update occurs.
     *
     * @param handler A block that will be called every time there is a
     * transaction committed to the store that involves a modification to the
     * document with the relevant ID in the collection that
     * {@link PendingIDSpecificOperation.observeLocal | observeLocal()} was called
     * on.
     *
     * @returns A {@link LiveQuery} object that must be kept in scope for as long
     * as you want to keep receiving updates.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
  
     */
    observeLocalWithNextSignal(handler) {
        return this._observe(handler, true);
    }
    /** @internal */
    constructor(documentID, collection) {
        super(documentID, collection);
        Logger.warning(`Cursor operations are deprecated, use DQL (Ditto Query Language) instead. ` +
            `See https://ditto.com/link/dql-legacy-to-dql-adoption`);
    }
    /** @internal */
    _observe(handler, waitForNextSignal) {
        const liveQuery = new LiveQuery(this.query, null, null, [], -1, 0, this.collection, async (documents, event, signalNext) => {
            if (documents.length > 1) {
                throw new Error(`Internal inconsistency, single document live query returned more than one document. Query: ${this.query}}.`);
            }
            if (event.isInitial === false && event.oldDocuments.length > 1) {
                throw new Error(`Internal inconsistency, single document live query returned an update event with more than one old documents. Query ${this.query}.`);
            }
            if (event.isInitial === false && event.insertions.length > 1) {
                throw new Error(`Internal inconsistency, single document live query returned an update event with more than one insertion, which doesn't make sense for single document observations. Query ${this.query}.`);
            }
            if (event.isInitial === false && event.deletions.length > 1) {
                throw new Error(`Internal inconsistency, single document live query returned an update event with more than one deletion, which doesn't make sense for single document observations. Query ${this.query}.`);
            }
            if (event.isInitial === false && event.updates.length > 1) {
                throw new Error(`Internal inconsistency, single document live query returned an update event with more than one update, which doesn't make sense for single document observations. Query ${this.query}.`);
            }
            if (event.isInitial === false && event.moves.length > 0) {
                throw new Error(`Internal inconsistency, single document live query returned an update event with moves, which doesn't make sense for single document observations. Query ${this.query}.`);
            }
            const totalNumberOfManipulations = event.isInitial === true
                ? 0
                : event.insertions.length +
                    event.deletions.length +
                    event.updates.length;
            if (totalNumberOfManipulations > 1) {
                throw new Error(`Internal inconsistency, single document live query returned a combination of inserts, updates, and/or deletes, which doesn't make sense for single document observation. Query ${this.query}.`);
            }
            // IDEA: use `undefined` instead of `null` and
            // adapt Wasm variant plus API definition.
            const document = documents[0] || null;
            const oldDocument = event.isInitial === true ? undefined : event.oldDocuments[0];
            const singleDocumentEvent = new SingleDocumentLiveQueryEvent(event.isInitial, oldDocument);
            if (waitForNextSignal) {
                void handler(document, singleDocumentEvent, signalNext);
            }
            else {
                try {
                    await handler(document, singleDocumentEvent);
                }
                finally {
                    signalNext();
                }
            }
        });
        this.collection.store.ditto.liveQueryManager.startLiveQuery(liveQuery);
        return liveQuery;
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/**
 * Represents a collection of a Ditto store.
 *
 * This is the entrypoint for inserting documents into a collection, as well as
 * querying a collection. You can get a collection by calling
 * {@link Store.collection | collection()} on a {@link Store} of a {@link Ditto}
 * object.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class Collection {
    /**
     * Generates a {@link PendingCursorOperation} using the provided query.
     *
     * The returned object can be used to find and return the documents or you can
     * chain a call to `observeLocal()` or `subscribe()` if you want to get
     * updates about the list of matching documents over time. It can also be used
     * to update, remove or evict the matching documents.
     *
     * You can incorporate dynamic data into the query string with placeholders in
     * the form of `$args.my_arg_name`, along with providing an accompanying
     * dictionary in the form of `{ "my_arg_name": "some value" }`. The
     * placeholders will be appropriately replaced by the corresponding argument
     * contained in `queryArgs`. This includes handling things like wrapping
     * strings in quotation marks and arrays in square brackets, for example.
     *
     * Find more information about the query string format in the documentation's
     * section on {@link https://ditto.com/link/js-common-concepts-querying Querying}
     *
     * @throws {Error} when called in a React Native environment.
     * @param query The query to run against the collection.
     * @param queryArgs The arguments to use to replace placeholders in the
     * provided query.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    find(query, queryArgs) {
        return new PendingCursorOperation(query, queryArgs !== null && queryArgs !== void 0 ? queryArgs : null, this);
    }
    /**
     * @deprecated Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    findAll() {
        return this.find('true');
    }
    /**
     * Generates a {@link PendingIDSpecificOperation} with the provided document
     * ID.
     *
     * The returned object can be used to find and return the document or you can
     * chain a call to
     * {@link PendingIDSpecificOperation.observeLocal | observeLocal()}, or
     * {@link PendingIDSpecificOperation.subscribe | subscribe()} if you want to
     * get updates about the document over time. It can also be used to update,
     * remove or evict the document.
     *
     * @param id The ID of the document to find.
     * @throws {Error} when called in a React Native environment.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    findByID(id) {
        const documentID = id instanceof DocumentID ? id : new DocumentID(id);
        return new PendingIDSpecificOperation(documentID, this);
    }
    /**
     * @deprecated Use DQL (Ditto Query Language) instead. For more information see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    async upsert(value, options = {}) {
        Logger.warning(`Collection.upsert() is deprecated, use ditto.store.execute() instead. ` +
            `For more information see: ` +
            `https://ditto.com/link/dql-legacy-to-dql-adoption`);
        return this.store.ditto.deferCloseAsync(async (dittoHandle) => {
            var _a;
            const writeStrategy = (_a = options.writeStrategy) !== null && _a !== void 0 ? _a : 'merge';
            const documentValueJSON = desugarJSObject(value);
            const documentValueCBOR = CBOR.encode(documentValueJSON);
            const idCBOR = await performAsyncToWorkaroundNonAsyncFFIAPI(async () => {
                return await collectionInsertValue(dittoHandle.deref(), this.name, documentValueCBOR, writeStrategy, undefined);
            });
            return new DocumentID(idCBOR, true);
        });
    }
    /**
     * Creates a new {@link Attachment} object, which can then be inserted into a
     * document. Node only, throws when running in the web browser.
     *
     * The file residing at the provided path will be copied into Ditto's store.
     * The {@link Attachment} object that is returned is what you can then use to
     * insert an attachment into a document.
     *
     * You can provide metadata about the attachment, which will be replicated to
     * other peers alongside the file attachment.
     *
     * Below is a snippet to show how you can use the
     * {@link newAttachment | newAttachment()} functionality to insert an
     * attachment into a document.
     *
     * ``` JavaScript
     * const attachment = await collection.newAttachment('/path/to/my/file.pdf')
     * await collection.upsert({ _id: '123', attachment, other: 'some-string' })
     * }
     * ```
     *
     * @param pathOrData The path to the file that you want to create an
     * attachment with or the raw data.
     * @param metadata Metadata relating to the attachment.
     *
     * @throws {Error} when called in a React Native environment.
     *
     * @deprecated Use {@link Store.newAttachment | ditto.store.newAttachment() }
     * instead.
     */
    async newAttachment(pathOrData, metadata = {}) {
        const ditto = this.store.ditto;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            const { id, len, handle } = await (async () => {
                if (typeof pathOrData === 'string') {
                    {
                        return dittoNewAttachmentFromFile(dittoHandle.deref(), pathOrData, 'Copy');
                    }
                }
                if (pathOrData instanceof Uint8Array) {
                    return await dittoNewAttachmentFromBytes(dittoHandle.deref(), pathOrData);
                }
                throw new Error(`Can't create new attachment, only file path as string or raw data as Uint8Array are supported, but got: ${typeof pathOrData}, ${pathOrData}`);
            })();
            const attachmentTokenJSON = {
                _id: id,
                _len: len,
                _meta: { ...metadata },
            };
            attachmentTokenJSON[DittoCRDTTypeKey] = DittoCRDTType.attachment;
            const attachmentToken = new AttachmentToken(attachmentTokenJSON);
            const attachment = new Attachment(ditto, attachmentToken);
            return Bridge.attachment.bridge(handle, () => attachment);
        });
    }
    /**
     * Trigger an attachment to be downloaded locally to the device and observe
     * its progress as it does so.
     *
     * When you encounter a document that contains an attachment the attachment
     * will not automatically be downloaded along with the document. You trigger
     * an attachment to be downloaded locally to a device by calling this method.
     * It will report events relating to the attachment fetch attempt as it tries
     * to download it. The `eventHandler` block may be called multiple times with
     * progress events. It will then be called with either a  `Completed` event or
     * a `Deleted` event. If downloading the attachment succeeds then the
     * `Completed` event that the `eventHandler` will be called with will hold a
     * reference to the downloaded attachment.
     *
     * @param token The {@link AttachmentToken} relevant to the attachment that
     * you wish to download and observe. Throws if token is invalid.
     * @param eventHandler An optional callback that will be called when there is
     * an update to the status of the attachment fetch attempt.
     *
     * @throws {Error} when called in a React Native environment.
     *
     * @return An `AttachmentFetcher` object, which must be kept alive for the
     * fetch request to proceed and for you to be notified about the attachment's
     * fetch status changes.
     *
     * @deprecated Use
     * {@link Store.fetchAttachment | ditto.store.fetchAttachment() } instead.
     */
    fetchAttachment(token, eventHandler) {
        if (token == null || !(token instanceof AttachmentToken))
            throw new Error(`Invalid attachment token: ${token}`);
        const ditto = this.store.ditto;
        return ditto.deferClose(() => {
            return ditto.attachmentFetcherManager.startAttachmentFetcher(token, eventHandler);
        });
    }
    /** @internal */
    constructor(name, store) {
        this.name = name;
        this.store = store;
    }
    /** @internal */
    findByIDCBOR(idCBOR) {
        const documentID = new DocumentID(idCBOR, true, true);
        return new PendingIDSpecificOperation(documentID, this);
    }
}

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
/**
 * Represents results returned when executing a DQL query containing a
 * {@link QueryResultItem} for each match.
 *
 * More info, such as metrics, will be provided in the near future.
 *
 * @template T The type of items in the query result.
 */
class QueryResult {
    /**
     * IDs of documents that were mutated _locally_ by a _mutating_ DQL query
     * passed to {@link Store.execute | `execute()`}. Empty array if no documents
     * have been mutated.
     *
     * **Note: Query results received from a {@link StoreObserver} never contain
     * mutated document IDs because a store observer is always registered using a
     * non-mutating `SELECT` query.
     *
     * **Important:** The returned document IDs are not cached, make sure to call
     * this method once and keep the return value for as long as needed.
     *
     * @returns an array of document IDs
     * @deprecated Use mutatedDocumentIDsV2() instead. This method will be removed
     * in a future version.
     */
    mutatedDocumentIDs() {
        const queryResultHandle = Bridge.queryResult.handleFor(this);
        const affectedCBORIDs = queryResultMutatedDocumentIDs(queryResultHandle.deref());
        return affectedCBORIDs.map((id) => new DocumentID(id, true));
    }
    /**
     * IDs of documents that were mutated _locally_ by a _mutating_ DQL query
     * passed to {@link Store.execute | `execute()`}. Empty array if no documents
     * have been mutated.
     *
     * **Note: Query results received from a {@link StoreObserver} never contain
     * mutated document IDs because a store observer is always registered using a
     * non-mutating `SELECT` query.
     *
     * **Important:** The returned document IDs are not cached, make sure to call
     * this method once and keep the return value for as long as needed.
     *
     * @returns an array of document ID values as JSON-compatible values
     */
    mutatedDocumentIDsV2() {
        const queryResultHandle = Bridge.queryResult.handleFor(this);
        const affectedCBORIDs = queryResultMutatedDocumentIDs(queryResultHandle.deref());
        return affectedCBORIDs.map((cborID) => CBOR.decode(cborID));
    }
    /**
     * The commit ID associated with this query result, if any.
     *
     * This ID uniquely identifies the commit in which this change was accepted
     * into the _local_ store. The commit ID is available for all query results
     * involving insertions, updates, or deletions. This ID can be used to track
     * whether a local change has been synced to other peers.
     *
     * For write transactions, the commit ID is only available after the
     * transaction has been successfully committed. Queries executed within an
     * uncommitted transaction will not have a commit ID.
     */
    get commitID() {
        const queryResultHandle = Bridge.queryResult.handleFor(this);
        if (queryResultHasCommitID(queryResultHandle.deref()))
            return queryResultCommitID(queryResultHandle.deref());
        return null;
    }
    // ----------------------------------------------------- Internal ------------
    /** @internal */
    constructor(queryResultPointer) {
        if (queryResultPointer == null) {
            throw new Error('Internal inconsistency, failed to initialize query result without a response pointer');
        }
        const resultItems = queryResultItems(queryResultPointer);
        this.items = resultItems.map((r) => Bridge.queryResultItem.bridge(r));
    }
}

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
/**
 * A store observer invokes a given handler whenever results for its query
 * change.
 *
 * The store observer will remain active until it is {@link cancel | cancelled},
 * or the Ditto instance managing the observer has been
 * {@link Ditto.close | closed}.
 *
 * Create a store observer by calling
 * {@link Store.registerObserver | `ditto.store.registerObserver()`}.
 *
 * @template T The type of items in query results. This is a convenience type
 * that is neither inferred from the store observer's
 * {@link StoreObserver.queryString | query} nor validated against it.
 * @template S The type of query arguments.
 */
class StoreObserver {
    /**
     * Convenience property, returns `true` once the store observer has been
     * cancelled.
     */
    get isCancelled() {
        return this._isCancelled;
    }
    /**
     * Cancels the store observer and unregisters it. No-op if the
     * store observer has already been cancelled.
     */
    cancel() {
        if (this._isCancelled)
            return;
        this._isCancelled = true;
        this.ditto.store.unregisterObserver(this);
    }
    /** @internal */
    constructor(ditto, query, queryArguments, observationHandler) {
        // --------------------------- Private --------------------------------------
        /**
         * `true` when the store observer has been cancelled.
         *
         * We mark the store observer as cancelled here as an optimization to avoid a
         * scan of all store observers in the store whenever the `isCancelled`
         * property is checked.
         */
        this._isCancelled = false;
        this.queryString = query;
        this.queryArguments = queryArguments
            ? Object.freeze({ ...queryArguments })
            : undefined;
        this.ditto = ditto;
        let queryArgumentsCBOR = null;
        if (queryArguments != null) {
            try {
                const queryArgumentsJSON = desugarJSObject(queryArguments);
                queryArgumentsCBOR = CBOR.encode(queryArgumentsJSON);
            }
            catch (error) {
                throw new DittoError('query/arguments-invalid');
            }
        }
        let storeObserverID;
        this.ditto.deferClose((dittoHandle) => {
            const weakThis = new WeakRef(this);
            function wrappedObservationHandler(cCBParams) {
                const strongThis = weakThis.deref();
                if (strongThis == null) {
                    Logger.debug(`Ignoring change event received by store observer ${storeObserverID} after it was cancelled`);
                    return;
                }
                const result = Bridge.queryResult.bridge(cCBParams.query_result, () => new QueryResult(cCBParams.query_result));
                Logger.debug(`Invoking user event handler with new event for store observer ${storeObserverID}`);
                observationHandler(result, () => {
                    return strongThis.signalNext();
                });
            }
            mapFFIErrors(() => {
                storeObserverID = tryExperimentalRegisterChangeObserver(dittoHandle.deref(), query, queryArgumentsCBOR, wrappedObservationHandler);
            });
        });
        if (storeObserverID == null) {
            throw new DittoError('internal', 'Internal inconsistency, store observer ID is undefined after registering');
        }
        this.liveQueryID = storeObserverID;
    }
    /**
     * Signals to Ditto Core that the observer is ready for the next event.
     */
    async signalNext() {
        const ditto = this.ditto;
        if (!ditto || ditto.isClosed)
            return;
        if (this.liveQueryID == null) {
            throw new Error('live query ID is null while signaling ready for next event');
        }
        return ditto.deferCloseAsync(async (dittoHandle) => {
            Logger.debug(`Signaling availability for live query ${this.liveQueryID}`);
            await liveQuerySignalAvailableNext(dittoHandle.deref(), this.liveQueryID);
        });
    }
}

//
// Copyright (c) 2020 - 2021 DittoLive Inc. All rights reserved.
//
// -----------------------------------------------------------------------------
/**
 * Provides information about the changes that have occurred in relation to an
 * event delivered when observing the collections in a {@link Store}.
 *
 * It contains information about the collections that are known about as well as
 * the collections that were previously known about in the previous event, along
 * with information about what collections have been inserted, deleted, updated,
 * or moved since the last event.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more details and
 * guidance, visit: https://ditto.com/link/dql.
 */
class CollectionsEvent {
    /** @internal */
    static initial(collections) {
        return new CollectionsEvent({
            isInitial: true,
            collections: collections,
            oldCollections: [],
            insertions: [],
            deletions: [],
            updates: [],
            moves: [],
        });
    }
    /** @internal */
    constructor(params) {
        this.isInitial = params.isInitial;
        this.collections = params.collections;
        this.oldCollections = params.oldCollections;
        this.insertions = params.insertions;
        this.deletions = params.deletions;
        this.updates = params.updates;
        this.moves = params.moves;
    }
}

//
// Copyright (c) 2020 - 2021 DittoLive Inc. All rights reserved.
//
// -----------------------------------------------------------------------------
/**
 * These objects are returned when calling
 * {@link Store.collections | collections()} on {@link Store}.
 *
 * They allow chaining of further collections-related functions. You can either
 * call {@link exec | exec()} on the object to get an array of
 * {@link Collection}s as an immediate return value, or you can establish either
 * a live query or a subscription, which both work over time.
 *
 * A live query, established by calling
 * {@link PendingCollectionsOperation.observeLocal | observeLocal()}, will
 * notify you every time there's a change in the collections that the device
 * knows about.
 *
 * A subscription, established by calling {@link subscribe | subscribe()}, will
 * act as a signal to other peers that the device connects to that you would
 * like to receive updates from them about the collections that they know about.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class PendingCollectionsOperation {
    /**
     * Sort the collections based on a property of the collection.
     *
     * @param propertyPath The property path specifies the logic to be used when
     * sorting the matching collections.
     *
     * @param direction Specify whether you want the sorting order to be
     * `Ascending` or `Descending`.
     *
     * @throws {Error} when called in a React Native environment.
     *
     * @return A {@link PendingCollectionsOperation} that you can chain further
     * function calls to.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    sort(propertyPath, direction = 'ascending') {
        // The return value is ignored here because we don't want to await the
        // completion of the operation at this point.
        void this.pendingCursorOperation.sort(propertyPath, direction);
        return this;
    }
    /**
     * Offset the resulting set of collections.
     *
     * This is useful if you aren't interested in the first N collections for one
     * reason or another. For example, you might already have obtained the first
     * 20 collections and so you might want to get the next 20 collections, and
     * that is when you would use {@link offset | offset()}.
     *
     * @param offset The number of collections that you want the eventual
     * resulting set of collections to be offset by (and thus not include).
     *
     * @throws {Error} when called in a React Native environment.
     *
     * @return A {@link PendingCollectionsOperation} that you can chain further
     * function calls to.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    offset(offset) {
        // The return value is ignored here because we don't want to await the
        // completion of the operation at this point.
        void this.pendingCursorOperation.offset(offset);
        return this;
    }
    /**
     * Limit the number of collections that get returned.
     *
     * @param limit The maximum number of collections that will be returned.
     *
     * @throws {Error} when called in a React Native environment.
     *
     * @return A {@link PendingCollectionsOperation} that you can chain further
     * function calls to.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    limit(limit) {
        // The return value is ignored here because we don't want to await the
        // completion of the operation at this point.
        void this.pendingCursorOperation.limit(limit);
        return this;
    }
    /**
     * Subscribes the device to updates about collections that other devices know
     * about.
     *
     * The returned {@link Subscription} object must be kept in scope for as long
     * as you want to keep receiving updates.
     *
     * @throws {Error} when called in a React Native environment.
     *
     * @return A {@link Subscription} object that must be kept in scope for as
     * long as you want to keep receiving updates from other devices about the
     * collections that they know about.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    subscribe() {
        return this.pendingCursorOperation.subscribe();
    }
    /**
     * Enables you to listen for changes that occur in relation to the collections
     * that are known about locally.
     *
     * The returned {@link LiveQuery} object must be kept in scope for as long as
     * you want the provided `handler` to be called when an update occurs.
     *
     * This won't subscribe to receive updates from other devices and so it will
     * only fire when a local change to the known about collections occurs. If you
     * want to receive remote updates as well, then create a subscription via
     * {@link PendingCollectionsOperation.subscribe | subscribe()}.
     *
     * @param handler A closure that will be called every time there is an update
     * about the list of known about collections.
     *
     * @throws {Error} when called in a React Native environment.
     *
     * @return A {@link LiveQuery} object that must be kept in scope for as long
     * as you want to keep receiving updates.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    observeLocal(handler) {
        return this._observe(handler, false);
    }
    /**
     * Enables you to listen for changes that occur in relation to the collections
     * that are known about locally.
     *
     * The returned {@link LiveQuery} object must be kept in scope for as long as
     * you want the provided `handler` to be called when an update occurs.
     *
     * This won't subscribe to receive updates from other devices and so it will
     * only fire when a local change to the known about collections occurs. If you
     * want to receive remote updates as well, then create a subscription via
     * {@link PendingCollectionsOperation.subscribe | subscribe()}.
     *
     * @param handler A closure that will be called every time there is an update
     * about the list of known about collections.
     *
     * @throws {Error} when called in a React Native environment.
     *
     * @return A {@link LiveQuery} object that must be kept in scope for as long
     * as you want to keep receiving updates.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    observeLocalWithNextSignal(handler) {
        return this._observe(handler, true);
    }
    /**
     * Return the list of collections requested based on the preceding function
     * chaining.
     *
     * @throws {Error} when called in a React Native environment.
     *
     * @return A list of {@link Collection}s based on the preceding function
     * chaining.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    async exec() {
        const documents = await this.pendingCursorOperation.exec();
        return collectionsFromDocuments(documents, this.store);
    }
    /** @internal */
    constructor(store) {
        this.store = store;
        this.pendingCursorOperation = new PendingCursorOperation('true', null, new Collection('__collections', store));
    }
    /** @internal */
    then(onfulfilled, onrejected) {
        return this.exec().then(onfulfilled, onrejected);
    }
    // ----------------------------------------------------------- Internal ------
    /** @internal */
    _observe(handler, waitForNextSignal) {
        const weakStore = new WeakRef(this.store);
        const collectionsObservationHandler = function (documents, event, nextSignal) {
            const strongStore = weakStore.deref();
            if (!strongStore)
                return;
            const collections = collectionsFromDocuments(documents, strongStore);
            let collEvent;
            if (event.isInitial === true) {
                collEvent = CollectionsEvent.initial(collections);
            }
            else {
                const oldCollections = collectionsFromDocuments(event.oldDocuments, strongStore);
                collEvent = new CollectionsEvent({
                    isInitial: false,
                    collections,
                    oldCollections,
                    insertions: event.insertions,
                    deletions: event.deletions,
                    updates: event.updates,
                    moves: event.moves,
                });
            }
            // The handler return promises are ignored here because we are not
            // handling errors during handler execution.
            if (waitForNextSignal)
                void handler(collEvent, nextSignal);
            else
                void handler(collEvent);
        };
        return this.pendingCursorOperation._observe(collectionsObservationHandler, waitForNextSignal);
    }
}
/** @private */
function collectionsFromDocuments(documents, store) {
    const collections = [];
    for (const document of documents) {
        const collectionName = document.at('name').value;
        if (collectionName !== undefined && typeof collectionName === 'string')
            collections.push(new Collection(collectionName, store));
    }
    return collections;
}

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
/**
 * These objects are returned when using `find`-like functionality on
 * {@link Collection}.
 *
 * They allow chaining of further query-related functions to do things like add
 * a limit to the number of documents you want returned or specify how you want
 * the documents to be sorted and ordered.
 *
 * You can call {@link exec | exec()} on the cursor to get an array of
 * {@link Document | documents} or you can use methods for updating, removing
 * or evicting any matching documents.
 *
 * Live queries and subscriptions are only available outside of transactions.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class WriteTransactionPendingCursorOperation extends BasePendingCursorOperation {
    sort(propertyPath, direction = 'ascending') {
        return super.sort(propertyPath, direction);
    }
    offset(offset) {
        return super.offset(offset);
    }
    limit(limit) {
        return super.limit(limit);
    }
    async remove() {
        const ditto = this.collection.store.ditto;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            const query = this.query;
            const transaction = this.collection
                .writeTransaction;
            const documentsX = await performAsyncToWorkaroundNonAsyncFFIAPI(async () => collectionRemoveQueryStr(dittoHandle.deref(), this.collection.name, transaction.writeTransactionPointer, query, this.queryArgsCBOR, this.orderBys, this.currentLimit, this.currentOffset));
            const results = documentsX.map((idCBOR) => {
                return new DocumentID(idCBOR, true);
            });
            results.forEach((documentId) => {
                transaction.addResult('removed', documentId, this.collection.name);
            });
            return results;
        });
    }
    async evict() {
        const ditto = this.collection.store.ditto;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            const query = this.query;
            const transaction = this.collection
                .writeTransaction;
            const documentsX = await performAsyncToWorkaroundNonAsyncFFIAPI(async () => collectionEvictQueryStr(dittoHandle.deref(), this.collection.name, transaction.writeTransactionPointer, query, this.queryArgsCBOR, this.orderBys, this.currentLimit, this.currentOffset));
            const results = documentsX.map((idCBOR) => {
                return new DocumentID(idCBOR, true);
            });
            results.forEach((documentId) => {
                transaction.addResult('evicted', documentId, this.collection.name);
            });
            return results;
        });
    }
    async update(closure) {
        const transaction = this.collection
            .writeTransaction;
        const results = await super.updateWithClosure(closure, 'write transaction cursor operation update()', transaction.writeTransactionPointer);
        results.keys().forEach((documentId) => {
            transaction.addResult('updated', documentId, this.collection.name);
        });
        return results;
    }
    // ----------------------------------------------------------- Internal ------
    /** @internal */
    constructor(query, queryArgs, collection) {
        super(query, queryArgs, collection);
    }
}

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
/**
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class WriteTransactionPendingIDSpecificOperation extends BasePendingIDSpecificOperation {
    async remove() {
        const ditto = this.collection.store.ditto;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            const transaction = this.collection
                .writeTransaction;
            const result = await performAsyncToWorkaroundNonAsyncFFIAPI(async () => collectionRemove(dittoHandle.deref(), this.collection.name, transaction.writeTransactionPointer, this.documentIDCBOR));
            transaction.addResult('removed', this.documentID, this.collection.name);
            return result;
        });
    }
    async evict() {
        const ditto = this.collection.store.ditto;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            const transaction = this.collection
                .writeTransaction;
            const result = await performAsyncToWorkaroundNonAsyncFFIAPI(async () => await collectionEvict(dittoHandle.deref(), this.collection.name, transaction.writeTransactionPointer, this.documentIDCBOR));
            transaction.addResult('evicted', this.documentID, this.collection.name);
            return result;
        });
    }
    async update(closure) {
        const transaction = this.collection
            .writeTransaction;
        const updateResults = this.updateWithClosure(closure, false, true, 'write transaction cursor operation update()', transaction);
        transaction.addResult('updated', this.documentID, this.collection.name);
        return updateResults;
    }
    async updateV2(closure) {
        const transaction = this.collection
            .writeTransaction;
        const updateResults = this.updateWithClosure(closure, true, false, 'write transaction cursor operation updateV2()', transaction);
        transaction.addResult('updated', this.documentID, this.collection.name);
        return updateResults;
    }
    async exec() {
        const ditto = this.collection.store.ditto;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            return await performAsyncToWorkaroundNonAsyncFFIAPI(async () => {
                const transaction = this.collection
                    .writeTransaction;
                const documentPointer = await collectionGetWithWriteTransaction(dittoHandle.deref(), this.collection.name, this.documentIDCBOR, transaction.writeTransactionPointer);
                let document = undefined;
                if (documentPointer)
                    document = Bridge.document.bridge(documentPointer);
                return document;
            });
        });
    }
    // ----------------------------------------------------------- Internal ------
    /** @internal */
    constructor(documentID, collection) {
        super(documentID, collection);
    }
}

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
/**
 * Represents a collection of a Ditto store that is used in the context of a
 * write transaction.
 *
 * Supports most of a regular {@link Collection | collection}'s functionality
 * but cannot be subscribed or live queried and can not be used to create
 * attachments.
 *
 * Create a `WriteTransactionCollection` by starting a {@link WriteTransaction}
 * and using its `scoped` method.
 *
 * Not available in React Native environments.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class WriteTransactionCollection {
    /**
     * Search for documents in this collection using the provided query string.
     *
     * The returned cursor operation can be used to chain operations on the
     * resulting document set.
     *
     * @param query The query to run against the collection.
     * @param queryArgs These arguments replace placeholders in the provided
     * query.
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    find(query, queryArgs) {
        return new WriteTransactionPendingCursorOperation(query, queryArgs !== null && queryArgs !== void 0 ? queryArgs : null, this);
    }
    /**
     * Convenience method, equivalent to calling {@link find | find()} and passing
     * the query `"true"`.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    findAll() {
        return this.find('true');
    }
    /**
     * Generates a {@link WriteTransactionPendingIDSpecificOperation} with the
     * provided document ID.
     *
     * The returned object can be used to find and return the document. It can
     * also be used to update, remove or evict the document.
     *
     * @param id The ID of the document to find.
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    findByID(id) {
        const documentID = id instanceof DocumentID ? id : new DocumentID(id);
        return new WriteTransactionPendingIDSpecificOperation(documentID, this);
    }
    async upsert(value, options = {}) {
        const ditto = this.store.ditto;
        return ditto.deferCloseAsync(async (dittoHandle) => {
            var _a;
            const writeStrategy = (_a = options.writeStrategy) !== null && _a !== void 0 ? _a : 'merge';
            const documentValueJSON = desugarJSObject(value);
            const documentValueCBOR = CBOR.encode(documentValueJSON);
            const idCBOR = await performAsyncToWorkaroundNonAsyncFFIAPI(async () => {
                return await collectionInsertValue(dittoHandle.deref(), this.name, documentValueCBOR, writeStrategy, this.writeTransaction.writeTransactionPointer);
            });
            const insertedDocumentId = new DocumentID(idCBOR, true);
            this.writeTransaction.addResult('inserted', insertedDocumentId, this.name);
            return new DocumentID(idCBOR, true);
        });
    }
    /**
     * See comment in {@link CollectionInterface.findByIDCBOR()}
     *
     * @internal */
    findByIDCBOR(idCBOR) {
        const documentID = new DocumentID(idCBOR, true, true);
        return new WriteTransactionPendingIDSpecificOperation(documentID, this);
    }
    /**
     * This constructor is marked internal because write transaction collections
     * should be created from a {@link WriteTransaction} instance.
     *
     * @internal */
    constructor(name, store, writeTransaction) {
        this.name = name;
        this.store = store;
        this.writeTransaction = writeTransaction;
    }
}

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
/**
 * Perform writes in a transaction.
 *
 * Create a write transaction using {@link Store.write | ditto.store.write}.
 *
 * @deprecated Use DQL (Ditto Query Language) instead. For more information see:
 * https://ditto.com/link/dql-legacy-to-dql-adoption
 */
class WriteTransaction {
    /**
     * Creates a transaction-specific
     * {@link WriteTransactionCollection | collection} object that will ensure
     * that operations called on it are all in the context of the collection name
     * provided to this function. You can create many
     * {@link WriteTransactionCollection | collection} objects per
     * {@link WriteTransaction} object.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     * */
    scoped(toCollectionNamed) {
        if (typeof toCollectionNamed !== 'string')
            throw new Error('Collection name must be a string');
        return new WriteTransactionCollection(toCollectionNamed, this.ditto.store, this);
    }
    /** @internal */
    constructor(ditto, cTransaction) {
        this.writeTransactionPointer = cTransaction;
        this.ditto = ditto;
        this.results = [];
    }
    /**
     * Initialise a write transaction given a Ditto instance.
     *
     * This is not implemented as a constructor in order to be able to use FFI
     * async functions. Users start transactions through {@link Store.write}.
     *
     * @param ditto an instance of Ditto
     * @internal
     */
    static async init(ditto) {
        return ditto.deferCloseAsync(async (dittoHandle) => {
            const writeTransactionPointer = await writeTransaction(dittoHandle.deref());
            return new WriteTransaction(ditto, writeTransactionPointer);
        });
    }
    /** @internal */
    async commit() {
        return this.ditto.deferCloseAsync(async (dittoHandle) => {
            return writeTransactionCommit(dittoHandle.deref(), this.writeTransactionPointer);
        });
    }
    /** @internal */
    async rollback() {
        return this.ditto.deferCloseAsync(async (dittoHandle) => {
            return writeTransactionRollback(dittoHandle.deref(), this.writeTransactionPointer);
        });
    }
    /**
     * Adds an entry to the list of results that is returned at the end of a
     * transaction.
     *
     * @internal
     */
    addResult(type, docID, collectionName) {
        this.results.push({
            type,
            docID,
            collectionName,
        });
    }
}

/**  Encapsulates information about a transaction.
 *
 * @see {@link Store.transaction | ditto.store.transaction()}
 */
class TransactionInfo {
    constructor(id, isReadOnly, hint) {
        this.id = id;
        this.hint = hint;
        this.isReadOnly = isReadOnly;
    }
}
/**
 * Represents a transaction in the Ditto store.
 *
 * A `Transaction` groups multiple operations into a single atomic unit,
 * ensuring that all operations within the transaction are either fully applied
 * or not applied at all, thereby maintaining data integrity.
 *
 * For more information on creating and using transactions, refer to the
 * {@link Store.transaction | ditto.store.transaction()} method. For a comprehensive guide on
 * transactions, please visit the
 * [Ditto documentation](https://ditto.com/link/sdk-latest-crud-transactions).
 */
class Transaction {
    constructor(store) {
        this.store = store;
    }
    /** Provides information about the current transaction. */
    get info() {
        const transactionHandle = Bridge.transaction.handleFor(this);
        const cborData = transactionInfo(transactionHandle.deref());
        const options = CBOR.decode(cborData);
        return new TransactionInfo(options.id, options.is_read_only, options.hint);
    }
    async execute(query, queryArguments) {
        if (typeof query !== 'string') {
            throw new DittoError('query/invalid', `Expected parameter 'query' to be of type 'string', found: ${typeof query}`);
        }
        return this.store.ditto.deferCloseAsync(async () => {
            let queryArgumentsCBOR = null;
            if (queryArguments) {
                try {
                    const queryArgumentsJSON = desugarJSObject(queryArguments);
                    queryArgumentsCBOR = CBOR.encode(queryArgumentsJSON);
                }
                catch (error) {
                    throw new DittoError('query/arguments-invalid', `Unable to encode query arguments: ${error.message}`);
                }
            }
            const transactionHandle = Bridge.transaction.handleFor(this);
            const queryResultPointer = await mapFFIErrorsAsync(async () => transactionExecuteAsync(transactionHandle.deref(), query, queryArgumentsCBOR));
            return Bridge.queryResult.bridge(queryResultPointer, () => new QueryResult(queryResultPointer));
        });
    }
    // ----------------------------------------------------------- Internal ------
    /** @internal */
    async complete(action) {
        const transactionHandle = Bridge.transaction.handleFor(this);
        const result = await mapFFIErrorsAsync(async () => await transactionCompleteAsync(transactionHandle.deref(), capitalize(action)));
        return result.toLowerCase();
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/**
 * The entrypoint for all actions that relate to data stored by Ditto. Provides
 * access to collections, a write transaction API, and a query hash API.
 *
 * You don't create one directly but can access it from a particular
 * {@link Ditto} instance via its {@link Ditto.store | store} property.
 */
class Store {
    /** @internal */
    // NOTE: currently, this property will only return the currently _running_
    // transactions rather than all pending. This means it's at most a single
    // read-write transaction, and potentially multiple read-only transactions.
    // Ideally, we'd want to have all _enqueued_ transactions appear here but
    // we don't have the infrastructure in the Rust Core for this yet.
    // Therefore, we'll keep this property internal for the time being,
    // which is still useful for some tests.
    get transactions() {
        return this.ditto.deferClose((dittoHandle) => {
            const storePointer = dittoPointerToStorePointer(dittoHandle.deref());
            const cborData = storeTransactions(storePointer);
            const data = CBOR.decode(cborData);
            return data.map((t) => new TransactionInfo(t.id, t.is_read_only, t.hint));
        });
    }
    /**
     * Register a handler to be called whenever a query's results change in the
     * local store.
     *
     * Convenience method, same as
     * {@link registerObserverWithSignalNext | registerObserverWithSignalNext()},
     * except that here, the next invocation of the observation handler is
     * triggered automatically instead of having to call the passed in
     * `signalNext` function.
     *
     * @param query A string containing a valid query expressed in DQL.
     * @param observationHandler A function that is called whenever the query's
     * results change. The function is passed a {@link QueryResult} containing a
     * {@link QueryResultItem} for each match.
     * @param queryArguments An object of values keyed by the placeholder name
     * without the leading `:`. Example: `{ "name": "Joanna" }` for a query like
     * `SELECT * FROM people WHERE name = :name`.
     * @template T The type of items returned by the query. This is a convenience
     * type that is neither inferred from the `query` parameter nor validated
     * against it.
     * @template U The type of the query arguments.
     * @returns A {@link StoreObserver} that can be used to cancel the
     * observation.
     * @throws {@link DittoError} `query/invalid`: if `query` argument is not a
     * string or not valid DQL.
     * @throws {@link DittoError} `query/arguments-invalid`: if `queryArguments`
     * argument is invalid (e.g. contains unsupported types).
     * @throws {@link DittoError} `query/unsupported`: if the query is not a
     * `SELECT` query.
     * @throws {@link DittoError} may throw other errors.
     */
    registerObserver(query, observationHandler, queryArguments) {
        const changeHandlerWithSignalNext = (queryResult, signalNext) => {
            try {
                observationHandler(queryResult);
            }
            finally {
                signalNext();
            }
        };
        return this.registerObserverWithSignalNext(query, changeHandlerWithSignalNext, queryArguments);
    }
    /**
     * Registers and returns a store observer for a query, configuring Ditto to
     * trigger the passed in observation handler whenever documents in the local
     * store change such that the result of the matching query changes. The passed
     * in query must be a `SELECT` query.
     *
     * Here, a function is passed as an additional argument to the observation
     * handler. Call this function as soon as the observation handler is ready to
     * process the the next change event. This allows the observation handler to
     * control how frequently it is called. See
     * {@link registerObserver | registerObserver()} for a convenience method that
     * automatically signals the next invocation.
     *
     * The first invocation of `observationHandler` will always happen after this
     * method has returned.
     *
     * @param query A string containing a valid query expressed in DQL.
     * @param observationHandler An observation handler function that is called
     * whenever the query's results change. The function is passed a
     * {@link QueryResult} containing a {@link QueryResultItem} for each match.
     * @param queryArguments An object of values keyed by the placeholder name
     * without the leading `:`. Example: `{ "name": "Joanna" }` for a query like
     * `SELECT * FROM people WHERE name = :name`.
     * @template T The type of items returned by the query. This is a convenience
     * type that is neither inferred from the `query` parameter nor validated
     * against it.
     * @template U The type of the query arguments
     * @returns A {@link StoreObserver} that can be used to cancel the
     * observation.
     * @throws {@link DittoError} `query/invalid`: if `query` argument is not a
     * string or not valid DQL.
     * @throws {@link DittoError} `query/arguments-invalid`: if `queryArguments`
     * argument is invalid (e.g. contains unsupported types).
     * @throws {@link DittoError} `query/unsupported`: if the query is not a
     * `SELECT` query.
     * @throws {@link DittoError} may throw other errors.
     */
    registerObserverWithSignalNext(query, observationHandler, queryArguments) {
        if (typeof query !== 'string') {
            throw new DittoError('query/invalid', `Expected parameter 'query' to be of type 'string', found: ${typeof query}`);
        }
        const storeObserver = new StoreObserver(this.ditto, query, queryArguments !== null && queryArguments !== void 0 ? queryArguments : null, observationHandler);
        // @ts-expect-error modifying readonly property
        this.observers = Object.freeze([...this.observers, storeObserver]);
        // We have two requirements for this step: (1) we want to be able to wait
        // for the call to FFI to finish while closing ditto and (2) we want to
        // return from this function without waiting for the call to FFI to finish.
        // If we would await the call here, we could end up in a situation where
        // the first callback to the event handler is emitted before we return from
        // the method call that started the observer.
        void this.ditto.deferCloseAsync(async (dittoHandle) => {
            return new Promise((resolve) => {
                void step(async () => {
                    try {
                        await mapFFIErrorsAsync(async () => await liveQueryStart(dittoHandle.deref(), storeObserver.liveQueryID));
                    }
                    catch (error) {
                        // As this closure executes after the surrounding method has returned we don't throw
                        // the error here. Instead we log the error.
                        Logger.error(`Failed to start live query: ${error.message}`);
                    }
                    resolve();
                });
            });
        });
        return storeObserver;
    }
    /**
     * Returns the collection for the given name. If the collection doesn't exist
     * yet, it will be created automatically as soon as the first entry is
     * inserted. A collection name is valid if:
     * * its length is less than 100
     * * it is not empty
     * * it does not contain the char '\0'
     * * it does not begin with "$TS_"
     *
     * @throws {Error} when called in a React Native environment.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    collection(name) {
        return new Collection(name, this);
    }
    /**
     * Returns an object that lets you fetch or observe the collections in the
     * store.
     *
     * @return A {@link PendingCollectionsOperation} object that you can use to
     * fetch or observe the collections in the store
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    collections() {
        return new PendingCollectionsOperation(this);
    }
    /**
     * Returns the names of all available collections in the store of the related
     * {@link Ditto} instance.
     *
     * @throws {Error} when called in a React Native environment.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    collectionNames() {
        return this.ditto.deferClose((dittoHandle) => {
            return mapFFIErrors(() => dittoGetCollectionNames(dittoHandle.deref()));
        });
    }
    async execute(query, queryArguments) {
        if (typeof query !== 'string') {
            throw new DittoError('query/invalid', `Expected parameter 'query' to be of type 'string', found: ${typeof query}`);
        }
        return this.ditto.deferCloseAsync(async (dittoHandle) => {
            let queryArgumentsCBOR = null;
            if (queryArguments != null) {
                try {
                    const queryArgumentsJSON = desugarJSObject(queryArguments);
                    queryArgumentsCBOR = CBOR.encode(queryArgumentsJSON);
                }
                catch (error) {
                    throw new DittoError('query/arguments-invalid', `Unable to encode query arguments: ${error.message}`);
                }
            }
            const queryResultPointer = await mapFFIErrorsAsync(async () => await performAsyncToWorkaroundNonAsyncFFIAPI(() => tryExecStatement(dittoHandle.deref(), query, queryArgumentsCBOR)));
            return Bridge.queryResult.bridge(queryResultPointer, () => new QueryResult(queryResultPointer));
        });
    }
    /**
     * Initiate a write transaction in a callback.
     *
     * Allows you to group multiple operations together that affect multiple
     * documents, potentially across multiple collections.
     *
     * @param callback is given access to a
     * {@link WriteTransaction | write transaction object} that can be used to
     * perform operations on the store.
     * @throws {Error} when called in a React Native environment.
     * @returns a list of `WriteTransactionResult`s. There is a result for each
     * operation performed as part of the write transaction.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    async write(callback) {
        Logger.warning(`ditto.store.write() is deprecated, use ditto.store.transaction() instead. ` +
            `See https://ditto.com/link/dql-legacy-to-dql-adoption`);
        // Run caller's callback, rolling back if needed.
        return this.ditto.deferCloseAsync(async () => {
            const transaction = await WriteTransaction.init(this.ditto);
            try {
                await callback(transaction);
            }
            catch (error) {
                await transaction.rollback();
                Logger.warning(`Transaction rolled back due to an error: ${error === null || error === void 0 ? void 0 : error.message}`);
                throw error;
            }
            await transaction.commit();
            return transaction.results;
        });
    }
    /**
     * Creates a new {@link Attachment} object, which can then be inserted into a
     * document.
     *
     * The file residing at the provided path will be copied into
     * Ditto's store.
     * The {@link Attachment} object that is returned is what you can then use to
     * insert an attachment into a document.
     *
     * **Note**: Relative paths for file sources are resolved from the current working
     * directory.
     *
     * You can provide metadata about the attachment, which will be replicated to
     * other peers alongside the file attachment.
     *
     * @example Inserting an attachment into a document
     * ```JavaScript
     * // Copy the file into Ditto's store and create an attachment object.
     * const attachment = await ditto.store.newAttachment(
     *   '/path/to/my/file.pdf',
     *   { my_field: 'optional metadata' }
     * )
     *
     * // Prepare the document value including the attachment.
     * const doc = {
     *   _id: '123',
     *   my_attachment: attachment,
     *   other: 'some-string'
     * }
     *
     * // Insert the document into the collection, marking `my_attachment` as an
     * // attachment field.
     * await ditto.store.execute(
     *   `INSERT INTO my_collection (my_attachment ATTACHMENT)
     *    VALUES (:doc)`,
     *   { doc }
     * )
     * ```
     *
     * @param pathOrData The path to the file that you want to create an
     * attachment with or the raw data.
     *
     * @param metadata Optional metadata that will be stored alongside the
     * attachment.
     *
     * @returns A promise for an {@link Attachment} object that can be used to
     * insert the attachment into a document.
     *
     * @throws {@link DittoError} `store/attachment-file-permission-denied` when
     * the file at the given path could not be read because of insufficient
     * permissions.
     *
     * @throws {@link DittoError} `store/attachment-file-not-found` when the file
     * at the given path could not be found.
     *
     * @throws {@link DittoError} `store/failed-to-create-attachment` when the
     * attachment could not be created for other reasons.
     *
     * @throws {@link DittoError} `sdk/unsupported` when trying to create an
     * attachment from a file path in a web browser.
     */
    async newAttachment(pathOrData, metadata) {
        if (metadata != null)
            validateAttachmentMetadata(metadata);
        return this.ditto.deferCloseAsync(async (dittoHandle) => {
            //
            // Create inputs for the attachment token from either a file path or raw data.
            //
            const { id, len, handle } = await (async () => {
                if (typeof pathOrData === 'string') {
                    {
                        return mapFFIErrors(() => dittoNewAttachmentFromFile(dittoHandle.deref(), pathOrData, 'Copy'), {
                            1: ['store/failed-to-create-attachment'],
                            2: ['store/attachment-file-not-found'],
                            3: ['store/attachment-file-permission-denied'],
                        });
                    }
                }
                if (pathOrData instanceof Uint8Array) {
                    return mapFFIErrorsAsync(async () => await dittoNewAttachmentFromBytes(dittoHandle.deref(), pathOrData), {
                        1: ['store/failed-to-create-attachment'],
                    });
                }
                throw new Error(`Can't create new attachment, only file path as string or raw data as Uint8Array are supported, but got: ${typeof pathOrData}, ${pathOrData}`);
            })();
            const attachmentTokenJSON = {
                _id: id,
                _len: len,
                _meta: { ...metadata },
                [DittoCRDTTypeKey]: DittoCRDTType.attachment,
            };
            const attachmentToken = new AttachmentToken(attachmentTokenJSON);
            // this.ditto is safe to use because we are inside a deferCloseAsync block
            const attachment = new Attachment(this.ditto, attachmentToken);
            return Bridge.attachment.bridge(handle, () => attachment);
        });
    }
    /**
     * Trigger an attachment to be downloaded locally to the device and observe
     * its progress as it does so.
     *
     * When you encounter a document that contains an attachment, the attachment
     * will not automatically be downloaded along with the document. You trigger
     * an attachment to be downloaded locally to a device by calling this method.
     * It will report events relating to the attachment fetch attempt as it tries
     * to download it. The `eventHandler` block may be called multiple times with
     * progress events. It will then be called with either a  `Completed` event or
     * a `Deleted` event. If downloading the attachment succeeds then the
     * `Completed` event that the `eventHandler` will be called with will hold a
     * reference to the downloaded attachment.
     *
     * The attachment to be fetched is identified by the `token` parameter. This
     * may either be an {@link AttachmentToken} instance received from a
     * {@link Document} or a plain object as is returned in a
     * {@link QueryResultItem} (see example below).
     *
     * @example Fetch an attachment from a document in the store
     *
     * ```js
     * // Fetch the attachment token from a document in the store
     * const result = await ditto.store.execute(`
     *   SELECT *
     *   FROM COLLECTION cars (my_attachment ATTACHMENT)
     *   WHERE my_attachment.id = :id`,
     *   { id: "123" }
     * )
     * const attachmentToken = result.items[0].my_attachment
     *
     * // Trigger the attachment to be downloaded
     * const attachment = await ditto.store.fetchAttachment(attachmentToken)
     *
     * // Extract the attachment data
     * const attachmentData = await attachment.data()
     * ```
     *
     * @param token The {@link AttachmentToken} instance or plain object
     * representation of the attachment to be downloaded.
     *
     * @param eventHandler An optional callback that will be called when there is
     * an update to the status of the attachment fetch attempt.
     *
     * @returns An {@link AttachmentFetcher} object, which is `PromiseLike` so
     * that you can `await` it to wait for the attachment to be downloaded. It
     * also provides a {@link AttachmentFetcher.stop | stop()} method to cancel
     * the fetch attempt.
     *
     * @throws {@link DittoError} `store/attachment-not-found` when the attachment
     * could not be found.
     *
     * @throws {@link DittoError} `store/attachment-token-invalid` when the given
     * attachment token is invalid.
     *
     * @throws {@link DittoError} `store/failed-to-fetch-attachment` when fetching
     * the attachment fails for other reasons.
     */
    fetchAttachment(token, eventHandler) {
        if (token == null)
            throw new Error("Missing required parameter 'token'");
        let attachmentToken;
        if (token instanceof AttachmentToken)
            attachmentToken = token;
        else
            attachmentToken = new AttachmentToken(token);
        return this.ditto.deferClose(() => {
            const attachmentFetcher = new AttachmentFetcher(this.ditto, attachmentToken, null, eventHandler);
            // @ts-expect-error modifying readonly property
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            this.attachmentFetchers = Object.freeze([
                ...this.attachmentFetchers,
                attachmentFetcher,
            ]);
            return attachmentFetcher;
        });
    }
    // ----------------------------------------------------------- Internal ------
    /** @internal */
    constructor(ditto) {
        /**
         * All currently active store observers.
         *
         * **Note:** Manage store observers using
         * {@link registerObserver | registerObserver()} to register a new store
         * observer and {@link StoreObserver.cancel | StoreObserver.cancel()} to
         * remove an existing store observer.
         */
        // The type parameters are defined as `any` to avoid recursive type inference.
        this.observers = Object.freeze([]);
        /**
         * All currently active attachment fetchers.
         *
         * **Note:** Manage attachment fetchers using
         * {@link fetchAttachment | fetchAttachment()} to start a new attachment fetch
         * and {@link AttachmentFetcher.stop | AttachmentFetcher.stop()} to cancel
         * an existing attachment fetch.
         */
        this.attachmentFetchers = Object.freeze([]);
        this.ditto = ditto;
    }
    /**
     * Unregister a store observer. No-op if the change observer has already
     * been removed.
     *
     * This must only be called by the store observer itself.
     *
     * @param changeObserver the store observer to unregister
     * @returns true if the store observer was found and removed, false otherwise
     * @throws {@link DittoError} `internal`: if the store observer does not belong to
     * this store
     * @throws {@link DittoError} `internal`: if the store observer has not been
     * cancelled yet
     * @throws {@link DittoError} `internal`: for any other error that occurs while
     * trying to unregister the store observer
     * @internal
     */
    unregisterObserver(storeObserver) {
        if (storeObserver.ditto !== this.ditto) {
            throw new DittoError('internal', `Internal inconsistency, can't remove store observer that does not belong to this store`);
        }
        if (!storeObserver.isCancelled) {
            throw new DittoError('internal', "Internal inconsistency, can't remove store observer that has not been cancelled");
        }
        // Return early if the store observer has already been removed.
        const indexToDelete = this.observers.findIndex((observer) => observer === storeObserver);
        if (indexToDelete === -1)
            return false;
        const newObservers = [...this.observers];
        newObservers.splice(indexToDelete, 1);
        // @ts-expect-error modifying readonly property
        this.observers = Object.freeze(newObservers);
        const dittoHandle = Bridge.ditto.handleFor(this.ditto);
        this.ditto.deferClose(() => {
            mapFFIErrors(() => liveQueryStop(dittoHandle.deref(), storeObserver.liveQueryID));
        });
        return true;
    }
    /**
     * Remove an attachment fetcher that is owned by this store. No-op if the
     * attachment fetcher has already been removed.
     *
     * This must only be called by the attachment fetcher itself.
     *
     * @param attachmentFetcher the attachment fetcher to finalize
     * @returns true if the attachment fetcher was found and removed, false
     * otherwise
     * @internal
     */
    removeAttachmentFetcher(attachmentFetcher) {
        if (attachmentFetcher.ditto !== this.ditto) {
            throw new DittoError('internal', `Internal inconsistency, can't finalize attachment fetcher that does not belong to this store`);
        }
        if (attachmentFetcher.manager != null) {
            throw new DittoError('internal', "Internal inconsistency, store can't remove attachment fetcher that is owned by the attachment fetcher manager");
        }
        if (!attachmentFetcher.isStopped) {
            throw new DittoError('internal', "Internal inconsistency, can't remove attachment fetcher that has not stopped");
        }
        const indexToDelete = this.attachmentFetchers.findIndex((fetcher) => fetcher === attachmentFetcher);
        if (indexToDelete === -1)
            return false;
        const newAttachmentFetchers = [...this.attachmentFetchers];
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        newAttachmentFetchers.splice(indexToDelete, 1);
        // @ts-expect-error modifying readonly property
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.attachmentFetchers = Object.freeze(newAttachmentFetchers);
        return true;
    }
    // ------------------------------------------ Working with Transactions ------
    /**
     * Executes multiple DQL queries within a single atomic transaction.
     *
     * This ensures that either all statements are executed successfully, or none
     * are executed at all, providing strong consistency guarantees. Certain mesh
     * configurations may impose limitations on these guarantees. For more
     * details, refer to the [Ditto
     * documentation](https://ditto.com/link/sdk-latest-crud-transactions).
     *
     * Transactions are initiated as read-write by default, and only one
     * read-write transaction can be executed at any given time. Any other
     * read-write transaction started concurrently will wait until the current
     * transaction has been committed or rolled back. Therefore, it is crucial to
     * ensure a transaction finishes as early as possible to prevent blocking
     * other read-write transactions.
     *
     * A transaction can also be configured to be read-only using the `isReadOnly`
     * parameter. Multiple read-only transactions can be executed concurrently.
     * However, executing a mutating DQL statement in a read-only transaction will
     * throw an error.
     *
     * If errors occur in an `execute()` call within a transaction block and the
     * error is caught and handled within the block, the transaction will continue
     * to run and not be rolled back. When an error is thrown at any point inside
     * the transaction block or while committing the transaction, the transaction
     * is implicitly rolled back, and the error is propagated to the caller.
     *
     * When a Ditto instance goes out of scope, it will drive all pending
     * transactions to completion before being shut down.
     *
     * **Warning:** Calling `ditto.store.execute()` or creating a nested
     * transaction within a transaction may lead to a deadlock.
     *
     * The transaction closure provided here can either return a
     * {@link TransactionCompletionAction} or an arbitrary value, either of which
     * will then also be returned by the call to this method itself. If one of the
     * {@link TransactionCompletionAction} values `'commit'` or `'rollback'` is
     * returned from the closure, that action is applied. If any other value,
     * including `null`, is returned, the transaction is committed unless an error
     * is thrown from the closure.
     *
     * Example usage (explicit completion):
     *
     * ```ts
     * await store.transaction(async (transaction) => {
     *   // ...
     *   return 'commit'
     * })
     * ```
     *
     * Example usage (returning a custom type):
     *
     * ```ts
     * interface UserData {
     *   id: string
     *   name: string
     * }
     *
     * const user: UserData = await store.transaction<UserData>(async (transaction) => {
     *   // ...
     *   return { id: 'u1', name: 'Alice' }
     * })
     * ```
     *
     * @template T The type of the value returned from the `scope` function.
     * Defaults to `TransactionCompletionAction`.
     * @param {Function} scope A function that provides access to a transaction
     * object to execute DQL queries.
     * @param {TransactionOptions} [options] Optional settings for the
     * transaction.
     * @returns {Promise<T>} A promise that resolves to the value returned by the
     * scope function. If that value is a {@link TransactionCompletionAction}, the
     * transaction is completed with the same action.
     * @throws {DittoError} Throws `DittoError` of `store/transaction-read-only`
     * if a mutating query is executed in a read-only transaction.
     * @throws {DittoError} May throw other `DittoError`s.
     * @throws Will rethrow any error thrown within the `scope` function.
     * @see {@link Transaction}
     * @see {@link TransactionOptions}
     */
    async transaction(scope, options = {}) {
        return this.ditto.deferCloseAsync(async () => {
            if ((options === null || options === void 0 ? void 0 : options.isReadOnly) && typeof options.isReadOnly !== 'boolean')
                throw new TypeError("Expected 'options.isReadOnly' to be a boolean");
            if ((options === null || options === void 0 ? void 0 : options.hint) && typeof options.hint !== 'string')
                throw new TypeError("Expected 'options.hint' to be a string");
            const transaction = await this.beginTransaction(options);
            // REFACTOR: completing with action `rollback` should never fail even
            // though the API is fallible (because `commit` _can_ fail). The Rust Core
            // will log an error if anything goes wrong here, so we simply ignore any
            // `transaction.complete()` errors.
            let result;
            try {
                result = await scope(transaction);
            }
            catch (error) {
                await transaction.complete('rollback');
                throw error;
            }
            if (result === 'rollback' || result === 'commit') {
                return (await transaction.complete(result));
            }
            await transaction.complete('commit');
            return result;
        });
    }
    // ----------------------------------------------------------- Internal ------
    /** @internal */
    async beginTransaction(options = {}) {
        return this.ditto.deferCloseAsync(async (dittoHandle) => {
            var _a, _b;
            // We explicitely set the default value here to maintain consistency with
            // other API that we already have, while acknowledging that default values
            // are generally better to be dictated from Core (via a factory method).
            const isReadOnly = (_a = options.isReadOnly) !== null && _a !== void 0 ? _a : false;
            const hint = (_b = options.hint) !== null && _b !== void 0 ? _b : null;
            const storePointer = dittoPointerToStorePointer(dittoHandle.deref());
            const transactionPointer = await storeBeginTransaction(storePointer, {
                isReadOnly,
                hint,
            });
            return Bridge.transaction.bridge(transactionPointer, () => new Transaction(this));
        });
    }
    /** @internal */
    close() {
        for (const observer of this.observers)
            observer.cancel();
        for (const fetcher of this.attachmentFetchers)
            fetcher.stop();
        // NOTE: live query webhook is taken care of by the FFI's
        // `ditto_shutdown()`, no need to unregister it here.
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
// -----------------------------------------------------------------------------
/**
 * Returns a string representation of the given address. Use this function to
 * compare multiple addresses or whenever you need the address to be a key in a
 * hash object.
 *
 * @deprecated Use `peerKeyString` to identify a peer. It is accessible via
 * {@link Peer}, {@link Connection}, and {@link ConnectionRequest}.
 */
function addressToString(address) {
    return `${address.siteId}-${address.pubkey}`;
}
// -----------------------------------------------------------------------------
/**
 * The entrypoint for all actions that relate presence of other peers known by
 * the current peer, either directly or through other peers.
 *
 * You don't create one directly but can access it from a particular `Ditto`
 * instance via its `presence` property.
 */
class Presence {
    /**
     * Set this handler to control which peers in a Ditto mesh can connect to the
     * current peer.
     *
     * Each peer in a Ditto mesh will attempt to connect to other peers that it
     * can reach. By default, the mesh will try and establish connections that
     * optimize for the best overall connectivity between peers. However, you can
     * set this handler to assert some control over which peers you connect to.
     *
     * If set, this handler is called for every incoming connection request from a
     * remote peer and is passed the other peer's `peerKey`, `peerMetadata`, and
     * `identityServiceMetadata`. The handler can then accept or reject the
     * request by returning an according {@link ConnectionRequestAuthorization}
     * value. When the connection request is rejected, the remote peer may retry
     * the connection request after a short delay.
     *
     * Connection request handlers must reliably respond to requests within a
     * short time. If a handler takes too long to respond or throws an exception,
     * the connection request will be denied. The response timeout is currently 10
     * seconds but may be subject to change in future releases.
     *
     * @see {@link peerMetadata | peerMetadata()}
     */
    get connectionRequestHandler() {
        return this._connectionRequestHandler;
    }
    /**
     * @throws TypeError: if the given handler is not a function.
     */
    set connectionRequestHandler(handler) {
        let wrappedHandler = null;
        if (handler != null) {
            if (typeof handler !== 'function') {
                throw new TypeError(`Expected parameter 'handler' to be a function but got ${typeof handler} instead`);
            }
            wrappedHandler = async (connectionRequest) => {
                const request = Bridge.connectionRequest.bridge(connectionRequest);
                // Any errors will be caught by ffi.ts and passed to `handleError` below
                const authorization = await handler(request);
                if (authorization !== 'allow' && authorization !== 'deny') {
                    Logger.error(`The connection request handler must return "allow" or "deny" but returned "${authorization}" instead. The connection request will be denied.`);
                    return 'Deny';
                }
                connectionRequestAuthorize(connectionRequest, authorization === 'allow' ? 'Allow' : 'Deny');
            };
        }
        this._connectionRequestHandler = handler;
        const handleError = (error) => {
            Logger.error(`The connection request handler threw an error while handling a connection request, the connection request will be denied. ${error}`);
        };
        const dittoHandle = Bridge.ditto.handleFor(this.ditto);
        this.ditto.deferClose(() => {
            presenceSetConnectionRequestHandler(dittoHandle.deref(), wrappedHandler, handleError);
        });
    }
    /**
     * Returns the current presence graph capturing all known peers and
     * connections between them.
     */
    get graph() {
        return this.ditto.deferClose((dittoHandle) => {
            const graphJSONString = dittoPresenceV3(dittoHandle.deref());
            return JSON.parse(graphJSONString);
        });
    }
    /**
     * Metadata associated with the current peer. Other peers in the same mesh can
     * access this user-provided object of metadata via the presence {@link graph}
     * and when evaluating connection requests using
     * {@link connectionRequestHandler | connectionRequestHandler()}.
     *
     * Uses UTF-8 encoding.
     *
     * @see {@link peerMetadata | peerMetadata()} for a convenience property that
     * provides access to parsed metadata.
     */
    get peerMetadataJSONString() {
        return this.ditto.deferClose((dittoHandle) => {
            return mapFFIErrors(() => {
                return presencePeerMetadataJSON(dittoHandle.deref());
            });
        });
    }
    /**
     * Set arbitrary metadata to be associated with the current peer.
     *
     * The metadata must not exceed 4 KB in size when JSON-encoded.
     *
     * @param {string} jsonString JSON-encoded metadata.
     *
     * @throws {@link DittoError} `validation/invalid-json`: if `jsonString` does
     * not contain valid JSON.
     *
     * @throws {@link DittoError} `validation/not-an-object`: if `jsonString` does
     * not contain an object.
     *
     * @throws {@link DittoError} `validation/size-limit-exceeded`: if the size
     *  limit for `jsonString` has been exceeded.
     *
     * @see {@link peerMetadataJSONString | peerMetadataJSONString()} for details
     * on usage of metadata.
     */
    async setPeerMetadataJSONString(jsonString) {
        await this.ditto.deferCloseAsync(async (dittoHandle) => {
            return mapFFIErrorsAsync(async () => {
                return presenceTrySetPeerMetadataJSON(dittoHandle.deref(), jsonString);
            });
        });
    }
    /**
     * This is a convenience property that wraps
     * {@link peerMetadataJSONString | peerMetadataJSONString()}.
     *
     * @see {@link peerMetadataJSONString | peerMetadataJSONString()} for details.
     */
    get peerMetadata() {
        return JSON.parse(this.peerMetadataJSONString);
    }
    /**
     * This is a convenience method that wraps
     * {@link setPeerMetadataJSONString | setPeerMetadataJSONString()}.
     *
     * @throws {@link DittoError} `validation/not-an-object`: if `peerMetadata` is
     * not an object.
     *
     * @throws {@link DittoError} `validation/not-json-compatible`: if
     * `peerMetadata` is not JSON serializable.
     *
     * @throws {@link DittoError} `validation/size-limit-exceeded`: if the size
     *  limit for `peerMetadata` has been exceeded.
     *
     * @see {@link setPeerMetadataJSONString | setPeerMetadataJSONString()} for
     * details.
     */
    async setPeerMetadata(peerMetadata) {
        let jsonString;
        try {
            jsonString = JSON.stringify(peerMetadata);
        }
        catch (error) {
            throw new DittoError('validation/not-json-compatible', `Failed encoding peer metadata to JSON. ${error}`);
        }
        await this.setPeerMetadataJSONString(jsonString);
    }
    /**
     * Request information about Ditto peers in range of this device.
     *
     * This method returns an observer which should be held as long as updates are
     * required. A newly registered observer will have a peers update delivered to
     * it immediately. From then on it will be invoked repeatedly when Ditto
     * devices come and go, or the active connections to them change.
     */
    observe(didChangeHandler) {
        const observerToken = this.observerManager.addObserver(didChangeHandler);
        const observer = new Observer(this.observerManager, observerToken, {
            stopsWhenFinalized: true,
        });
        // REFACTOR: make the initial callback call async, too (othewise we'd be
        // mixing sync with async, which is a bit problematic in general but might
        // be OK with single-threaded JS). This is a bit tricky, simply
        // setTimeout(..., 0) here could lead us to a situation where the initial
        // call would be sent AFTER the regular notification.
        didChangeHandler(this.graph);
        return observer;
    }
    // -----------------------------------------------------------------------------
    /** @internal */
    constructor(ditto) {
        this._connectionRequestHandler = null;
        this.ditto = ditto;
        this.observerManager = new ObserverManager('PresenceObservation', {
            keepAlive: ditto.keepAlive,
            register: (callback) => {
                this.ditto.deferClose((dittoHandle) => {
                    dittoRegisterPresenceV3Callback(dittoHandle.deref(), callback);
                });
            },
            unregister: () => {
                void ditto.deferCloseAsync(async (dittoHandle) => {
                    return dittoClearPresenceV3Callback(dittoHandle.deref());
                });
            },
            process: (presenceGraphJSONString) => {
                const presenceGraph = JSON.parse(presenceGraphJSONString);
                return [presenceGraph];
            },
        });
    }
    /** @internal */
    close() {
        this.observerManager.close();
    }
}

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
/** @internal */
class LiveQueryManager {
    /** @internal */
    constructor(ditto, keepAlive) {
        this.finalizationRegistry = new FinalizationRegistry(this.finalize);
        this.ditto = ditto;
        this.keepAlive = keepAlive;
        this.liveQueriesByID = {};
    }
    /** @internal */
    startLiveQuery(liveQuery) {
        // REFACTOR: the starting closure runs detached from here which is a smell.
        // Can we make this whole starting mechanism non-async? The culprit is
        // the workaround for a zalgo with `ditto_live_query_start()` FFI function:
        // It immediately triggers the live query handler making it run "in-line"
        // when creating a live query, while subsequent invocations are async
        // (by definition). This is a classic zalgo case. Fix by making
        // `ditto_live_query_start()` trigger the first live query callback `async`,
        // just like the subsequent ones.
        void this.ditto.deferCloseAsync(async (dittoHandle) => {
            const liveQueryID = liveQuery.liveQueryID;
            if (!liveQueryID) {
                throw new Error("Internal inconsistency, tried to add a live query that doesn't have a live query ID (probably stopped).");
            }
            const existingLiveQuery = this.liveQueriesByID[liveQueryID];
            if (existingLiveQuery) {
                throw new Error('Internal inconsistency, tried to add a live query with an ID that has already been added.');
            }
            const weakLiveQuery = new WeakRef(liveQuery);
            this.liveQueriesByID[liveQueryID] = weakLiveQuery;
            this.finalizationRegistry.register(liveQuery, liveQueryID, this.finalize);
            liveQuery.liveQueryManager = this;
            this.ditto.keepAlive.retain(`LiveQuery.${liveQueryID}`);
            return new Promise((resolve, reject) => {
                // not awaited on purpose; let the invocation of the initial observation
                // happen in a "fire-and-forget" / detached / escaping fashion, to be
                // consistent with the subsequent invocations.
                void step(async () => {
                    await liveQueryStart(dittoHandle.deref(), liveQueryID);
                    resolve();
                });
            });
        });
    }
    /** @internal */
    stopLiveQuery(liveQuery) {
        this.finalizationRegistry.unregister(liveQuery);
        const liveQueryID = liveQuery.liveQueryID;
        if (!liveQueryID) {
            throw new Error("Internal inconsistency, tried to remove a live query that doesn't have a live query ID (probably stopped).");
        }
        liveQuery.liveQueryManager = null;
        this.stopLiveQueryWithID(liveQueryID);
    }
    /** @internal */
    close() {
        for (const liveQueryID in this.liveQueriesByID) {
            const weakLiveQuery = this.liveQueriesByID[liveQueryID];
            const liveQuery = weakLiveQuery.deref();
            if (liveQuery)
                this.stopLiveQuery(liveQuery);
        }
    }
    stopLiveQueryWithID(liveQueryID) {
        this.ditto.deferClose((dittoHandle) => {
            liveQueryStop(dittoHandle.deref(), liveQueryID);
            this.keepAlive.release(`LiveQuery.${liveQueryID}`);
            delete this.liveQueriesByID[liveQueryID];
        });
    }
    finalize(liveQueryID) {
        this.stopLiveQueryWithID(liveQueryID);
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/**
 * @internal
 * @deprecated Replaced by `Presence`.
 */
class PresenceManager {
    constructor(ditto) {
        this.ditto = ditto;
        this.isClosed = false;
        this.isRegistered = false;
        this.currentRemotePeers = [];
        this.callbacksByPresenceToken = {};
    }
    /** @internal */
    addObserver(callback) {
        if (this.isClosed) {
            // REFACTOR: throw a catchable error here, such that calling code
            // can be more specific when forwarding it to the user.
            throw new Error(`Internal inconsistency, can't add presence observer, observer mananger close()-ed.`);
        }
        this.registerIfNeeded();
        const token = cryptoGenerateSecureRandomToken();
        this.callbacksByPresenceToken[token] = callback;
        this.ditto.keepAlive.retain(`PresenceObservation.${token}`);
        // REFACTOR: make the initial callback call async, too (othewise we'd be
        // mixing sync with async, which is a bit problematic in general but might
        // be OK with single-threaded JS). This is a bit tricky, simply
        // setTimeout(..., 0) here could lead us to a situation where the initial
        // call would be sent AFTER the regular notification.
        callback(this.currentRemotePeers);
        return token;
    }
    /** @internal */
    async removeObserver(token) {
        const callback = this.callbacksByPresenceToken[token];
        if (typeof callback === 'undefined') {
            throw new Error(`Can't remove presence observer, token '${token}' has never been registered before.`);
        }
        if (callback === null) {
            // Observer has already been removed, no-op.
            return;
        }
        if (typeof this.callbacksByPresenceToken[token] != 'undefined') {
            this.ditto.keepAlive.release(`PresenceObservation.${token}`);
            // REFACTOR: not deleting the token here will keep eating up
            // memory over long periods of time. We actually need to track
            // the observer objects themselves and remove it from the table
            // as soon as the observer object is garbage collected.
            this.callbacksByPresenceToken[token] = null;
            return this.unregisterIfNeeded();
        }
    }
    /** @internal */
    hasObserver(token) {
        return typeof this.callbacksByPresenceToken[token] != 'undefined';
    }
    /** @internal */
    async close() {
        this.isClosed = true;
        const tokens = Object.keys(this.callbacksByPresenceToken);
        return Promise.all(tokens.map((token) => this.removeObserver(token)));
    }
    hasObservers() {
        return Object.keys(this.callbacksByPresenceToken).length > 0;
    }
    registerIfNeeded() {
        this.ditto.deferClose((dittoHandle) => {
            const needsToRegister = !this.isRegistered;
            if (needsToRegister) {
                this.isRegistered = true;
                const remotePeersJSONString = dittoPresenceV1(dittoHandle.deref());
                this.currentRemotePeers = this.decode(remotePeersJSONString).sort(this.compareRemotePeers);
                dittoRegisterPresenceV1Callback(dittoHandle.deref(), this.handlePresenceV1Callback.bind(this));
            }
        });
    }
    unregisterIfNeeded() {
        return this.ditto.deferCloseAsync(async (dittoHandle) => {
            const needsToUnregister = !this.hasObservers() && this.isRegistered;
            if (needsToUnregister) {
                this.isRegistered = false;
                await dittoClearPresenceCallback(dittoHandle.deref());
                this.currentRemotePeers = [];
            }
        });
    }
    handlePresenceV1Callback(remotePeersJSONString) {
        const remotePeers = this.decode(remotePeersJSONString).sort(this.compareRemotePeers);
        this.currentRemotePeers = remotePeers;
        this.notify();
    }
    notify() {
        if (this.isClosed) {
            // NOTE: we don't notify observers after closing.
            return;
        }
        for (const token in this.callbacksByPresenceToken) {
            const callback = this.callbacksByPresenceToken[token];
            if (callback)
                callback(this.currentRemotePeers);
        }
    }
    decode(remotePeersJSONString) {
        const remotePeersJSON = JSON.parse(remotePeersJSONString);
        return remotePeersJSON.map((remotePeerJSON) => {
            var _a, _b;
            return {
                networkID: remotePeerJSON['network_id'],
                deviceName: remotePeerJSON['device_name'],
                rssi: (_a = remotePeerJSON['rssi']) !== null && _a !== void 0 ? _a : undefined,
                approximateDistanceInMeters: (_b = remotePeerJSON['approximate_distance_in_meters']) !== null && _b !== void 0 ? _b : undefined,
                connections: remotePeerJSON['connections'],
            };
        });
    }
    compareRemotePeers(left, right) {
        // NOTE: we use the exact same sort order here as in the ObjC version.
        if (left.connections.length === 0 && right.connections.length > 0)
            return +1;
        if (left.connections.length > 0 && right.connections.length === 0)
            return -1;
        if (left.deviceName < right.deviceName)
            return -1;
        if (left.deviceName > right.deviceName)
            return +1;
        return 0;
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/** @internal */
class TransportConditionsManager extends ObserverManager {
    constructor(ditto) {
        const keepAlive = ditto.keepAlive;
        super('TransportConditionsObservation', { keepAlive });
        this.ditto = ditto;
    }
    register(callback) {
        return this.ditto.deferClose((dittoHandle) => {
            return dittoRegisterTransportConditionChangedCallback(dittoHandle.deref(), callback);
        });
    }
    unregister() {
        return this.ditto.deferClose((dittoHandle) => {
            return dittoRegisterTransportConditionChangedCallback(dittoHandle.deref(), null);
        });
    }
    process(conditionSource, transportCondition) {
        /* eslint-disable */
        let apiConditionSource;
        switch (conditionSource) {
            case 'Bluetooth':
                apiConditionSource = 'BLE';
                break;
            case 'Tcp':
                apiConditionSource = 'TCP';
                break;
            case 'Awdl':
                apiConditionSource = 'AWDL';
                break;
            case 'Mdns':
                apiConditionSource = 'MDNS';
                break;
            case 'WiFiAware':
                apiConditionSource = 'WiFiAware';
                break;
        }
        /* eslint-enable */
        /* eslint-disable */
        let apiTransportCondition;
        switch (transportCondition) {
            case 'Unknown':
                apiTransportCondition = 'Unknown';
                break;
            case 'Ok':
                apiTransportCondition = 'OK';
                break;
            case 'GenericFailure':
                apiTransportCondition = 'GenericFailure';
                break;
            case 'AppInBackground':
                apiTransportCondition = 'AppInBackground';
                break;
            case 'MdnsFailure':
                apiTransportCondition = 'MDNSFailure';
                break;
            case 'TcpListenFailure':
                apiTransportCondition = 'TCPListenFailure';
                break;
            case 'NoBleCentralPermission':
                apiTransportCondition = 'NoBLECentralPermission';
                break;
            case 'NoBlePeripheralPermission':
                apiTransportCondition = 'NoBLEPeripheralPermission';
                break;
            case 'CannotEstablishConnection':
                apiTransportCondition = 'CannotEstablishConnection';
                break;
            case 'BleDisabled':
                apiTransportCondition = 'BLEDisabled';
                break;
            case 'NoBleHardware':
                apiTransportCondition = 'NoBLEHardware';
                break;
            case 'WifiDisabled':
                apiTransportCondition = 'WiFiDisabled';
                break;
            case 'TemporarilyUnavailable':
                apiTransportCondition = 'TemporarilyUnavailable';
                break;
        }
        /* eslint-enable */
        return [apiTransportCondition, apiConditionSource];
    }
}

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
/**
 * A sync subscription configures Ditto to receive updates from remote peers
 * about documents matching the subscription's query.
 *
 * The sync subscription will remain active until it is
 * {@link SyncSubscription.cancel | cancelled}, or the Ditto instance managing
 * the subscription has been {@link Ditto.close | closed}.
 *
 * Create a sync subscription by calling
 * {@link Sync.registerSubscription | `ditto.sync.registerSubscription()`}.
 *
 * @template T The type of query arguments passed to the sync subscription.
 */
class SyncSubscription {
    /**
     * `true` when the sync subscription has been cancelled or the {@link Ditto}
     * instance managing this subscription has been closed.
     */
    get isCancelled() {
        return this._isCancelled;
    }
    /**
     * Cancels the sync subscription and unregisters it. No-op
     * if the sync subscription has already been cancelled or the {@link Ditto}
     * instance managing this subscription has been closed.
     */
    cancel() {
        if (this._isCancelled)
            return;
        this._isCancelled = true;
        this.ditto.sync.unregisterSubscription(this);
    }
    // --------------------------- Internal --------------------------------------
    /** @internal */
    constructor(ditto, query, queryArguments, queryArgumentsCBOR) {
        // --------------------------- Private --------------------------------------
        /**
         * `true` when the sync subscription has been cancelled.
         *
         * We mark the sync subscription as cancelled here as an optimization to avoid
         * a scan of all subscriptions in the store whenever the `isCancelled`
         * property is checked.
         */
        this._isCancelled = false;
        if ((queryArguments == null) !== (queryArgumentsCBOR == null)) {
            throw new DittoError('internal', 'Internal inconsistency, query arguments and query arguments CBOR must be both null or both non-null', { queryArguments, queryArgumentsCBOR });
        }
        this.ditto = ditto;
        this.queryString = query;
        this.queryArguments = queryArguments
            ? Object.freeze({ ...queryArguments })
            : undefined;
        this.queryArgumentsCBOR = queryArgumentsCBOR;
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
/**
 * Provides access to sync related functionality of Ditto.
 *
 * Access this object via {@link Ditto.sync | Ditto.sync} on any Ditto instance.
 */
class Sync {
    /**
     * Returns `true` if sync is active, otherwise returns `false`. Use
     * {@link Sync.start | ditto.sync.start()} to activate and
     * {@link Sync.stop | ditto.sync.stop()} to deactivate sync.
     */
    get isActive() {
        return this.ditto.isSyncActive;
    }
    /**
     * Starts the network transports. Ditto will connect to other devices.
     *
     * By default Ditto will enable all peer-to-peer transport types. On **Node**,
     * this means BluetoothLE, WiFi/LAN, and AWDL. On the **Web**, only connecting
     * via  Websockets is supported. The default network configuration can be
     * modified with {@link Ditto.updateTransportConfig | updateTransportConfig()}
     * or replaced with {@link Ditto.setTransportConfig | setTransportConfig()}.
     *
     * Performance of initial sync when bootstrapping new peers can be improved by
     * calling {@link Ditto.disableSyncWithV3 | disableSyncWithV3()} before
     * {@link start | start()}. Only call that method when all peers in the mesh
     * are known to be running Ditto v4 or higher.
     *
     * Ditto will prevent the process from exiting until sync is stopped (not
     * relevant when running in the browser).
     *
     * **NOTE**: the BluetoothLE transport on Linux is experimental, this method
     * panics if no BluetoothLE hardware is available. Therefore, contrary to the
     * above, the BluetoothLE transport is temporarily disabled by default on
     * Linux.
     *
     * @see {@link Sync.isActive | ditto.sync.isActive}
     * @see {@link Sync.stop | ditto.sync.stop()}
     */
    start() {
        this.ditto.startSync();
    }
    /**
     * Stops all network transports.
     *
     * You may continue to use the Ditto store locally but no data will sync to or
     * from other devices.
     *
     * @see {@link Sync.isActive | ditto.sync.isActive}
     * @see {@link Sync.start | ditto.sync.start()}
     */
    stop() {
        this.ditto.stopSync();
    }
    /**
     * Installs and returns a sync subscription for a query, configuring Ditto to
     * receive updates from other peers for documents matching that query. The
     * passed in query must be a `SELECT` query, otherwise an error is thrown.
     *
     * @param query a string containing a valid query expressed in DQL.
     * @param queryArguments an object containing the arguments for the query.
     * Example: `{mileage: 123}` for a query with `:mileage` placeholder.
     * @template T The type of the query arguments.
     * @returns An active `SyncSubscription` for the passed in query and
     * arguments. It will remain active until it is
     * {@link SyncSubscription.cancel | cancelled} or the {@link Ditto} instance
     * managing the sync subscription has been closed.
     * @throws {@link DittoError} `query/invalid`: if `query` argument is not a
     * string or not valid DQL.
     * @throws {@link DittoError} `query/arguments-invalid`: if `queryArguments`
     * argument is invalid (e.g. contains unsupported types).
     * @throws {@link DittoError} `query/unsupported`: if the query is not a
     * `SELECT` query.
     * @throws {@link DittoError} may throw other errors.
     */
    registerSubscription(query, queryArguments) {
        if (typeof query !== 'string') {
            throw new DittoError('query/invalid', `Expected parameter 'query' to be of type 'string', found: ${typeof query}`);
        }
        let queryArgumentsCBOR = null;
        if (queryArguments != null) {
            try {
                const queryArgumentsJSON = desugarJSObject(queryArguments);
                queryArgumentsCBOR = CBOR.encode(queryArgumentsJSON);
            }
            catch (error) {
                throw new DittoError('query/arguments-invalid', `Unable to encode query arguments: ${error.message}`);
            }
        }
        this.ditto.deferClose((dittoHandle) => {
            mapFFIErrors(() => tryAddSyncSubscription(dittoHandle.deref(), query, queryArgumentsCBOR));
        });
        const subscription = new SyncSubscription(this.ditto, query, queryArguments || null, queryArgumentsCBOR);
        // @ts-expect-error modifying readonly property
        this.subscriptions = Object.freeze([...this.subscriptions, subscription]);
        return subscription;
    }
    // ---------------------------------------------------------- Internal ------
    /** @internal */
    constructor(ditto) {
        /**
         * All currently active {@link SyncSubscription | sync subscriptions}.
         *
         * **Note:** Manage sync subscriptions using
         * {@link registerSubscription | registerSubscription()} to register a new
         * sync subscription and
         * {@link SyncSubscription.cancel | SyncSubscription.cancel()} to remove an
         * existing sync subscription.
         */
        this.subscriptions = Object.freeze([]);
        this.ditto = ditto;
    }
    /**
     * Removes the passed in `syncSubscription`, configuring Ditto to not receive
     * updates for documents matching the corresponding query anymore. No-op if
     * the passed in `syncSubscription` has already been removed.
     *
     * This must only be called by the sync subscription itself.
     *
     * @param syncSubscription the sync subscription to remove
     * @returns `true` if the passed in sync subscription could be found and has
     * been removed, otherwise returns `false`.
     * @throws {@link DittoError} `internal`: if the replication subscription does not
     * belong to this store
     * @throws {@link DittoError} `internal`: if the replication subscription has not
     * been cancelled yet
     * @internal
     */
    unregisterSubscription(syncSubscription) {
        if (syncSubscription.ditto !== this.ditto) {
            throw new DittoError('internal', `Can't remove replication subscription that does not belong to this store`);
        }
        if (!syncSubscription.isCancelled) {
            throw new DittoError('internal', "Internal inconsistency, can't remove replication subscription that has not been cancelled");
        }
        const indexToDelete = this.subscriptions.findIndex((s) => s === syncSubscription);
        if (indexToDelete === -1)
            return false;
        const newSyncSubscriptions = [...this.subscriptions];
        newSyncSubscriptions.splice(indexToDelete, 1);
        // @ts-expect-error modifying readonly property
        this.subscriptions = Object.freeze(newSyncSubscriptions);
        this.ditto.deferClose((dittoHandle) => {
            mapFFIErrors(() => tryRemoveSyncSubscription(dittoHandle.deref(), syncSubscription.queryString, syncSubscription.queryArgumentsCBOR));
        });
        return true;
    }
    /** @internal */
    close() {
        for (const subscription of this.subscriptions)
            subscription.cancel();
        // Nothing to do, when sync is stopped, this object should be
        // already be cleaned up properly.
    }
}

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
/**
 * Tracks `Subscription` instances in order to remove them when Ditto is
 * closed.
 *
 * @internal
 */
class SubscriptionManager {
    /** @internal */
    constructor(ditto) {
        this.ditto = ditto;
        this.subscriptions = {};
        this.finalizationRegistry = new FinalizationRegistry(this.removeWithContextInfo.bind(this));
    }
    /**
     * Begin tracking a subscription instance and start it.
     *
     * @internal
     */
    add(subscription) {
        const contextInfo = subscription.contextInfo;
        this.ditto.deferClose((dittoHandle) => {
            this.subscriptions[contextInfo.id] = new WeakRef(subscription);
            this.finalizationRegistry.register(subscription, subscription.contextInfo, subscription);
            addSubscription(dittoHandle.deref(), contextInfo.collectionName, contextInfo.query, contextInfo.queryArgsCBOR, contextInfo.orderBys, contextInfo.limit, contextInfo.offset);
        });
    }
    /**
     * Stop tracking a subscription instance and cancel it.
     *
     * @internal
     */
    remove(subscription) {
        if (this.subscriptions[subscription.contextInfo.id] == null) {
            throw new Error(`Internal inconsistency, tried to remove a subscription that is not tracked: ${subscription.contextInfo.id}`);
        }
        this.finalizationRegistry.unregister(subscription);
        this.removeWithContextInfo(subscription.contextInfo);
    }
    /**
     * Stop tracking all subscriptions and cancel them.
     *
     * @internal
     */
    close() {
        this.ditto.deferClose(() => {
            for (const subscriptionID in this.subscriptions) {
                const subscription = this.subscriptions[subscriptionID].deref();
                subscription === null || subscription === void 0 ? void 0 : subscription.cancel();
            }
        });
    }
    /**
     * Remove tracked subscription without unregistering from finalization
     * registry.
     *
     * @internal
     */
    removeWithContextInfo(contextInfo) {
        this.ditto.deferClose((dittoHandle) => {
            delete this.subscriptions[contextInfo.id];
            removeSubscription(dittoHandle.deref(), contextInfo.collectionName, contextInfo.query, contextInfo.queryArgsCBOR, contextInfo.orderBys, contextInfo.limit, contextInfo.offset);
        });
    }
}

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
/**
 * Manages attachment fetchers to make sure we free all resources when the
 * fetcher is garbage collected and to allow us to wait for freeing of
 * ressources to be finished before the ditto instance is closed.
 *
 * @internal
 */
class AttachmentFetcherManager {
    /** @internal */
    constructor(ditto) {
        // --- Private ---
        this.contextInfoByID = {};
        this.finalizationRegistry = new FinalizationRegistry(this.stopWithContextInfo.bind(this));
        this.ditto = ditto;
    }
    /**
     * Start an attachment fetcher.
     *
     * @internal */
    startAttachmentFetcher(token, eventHandler) {
        return this.ditto.deferClose(() => {
            const attachmentFetcher = new AttachmentFetcher(this.ditto, token, this, eventHandler);
            // Register in finalization registry.
            const contextInfo = {
                id: attachmentFetcher.id,
                attachmentTokenID: token.idBytes,
                cancelTokenPromise: attachmentFetcher.cancelTokenPromise,
                attachmentFetcher: new WeakRef(attachmentFetcher),
            };
            this.finalizationRegistry.register(attachmentFetcher, contextInfo, attachmentFetcher);
            // Keep a reference to the context info so that we can stop the fetcher.
            this.contextInfoByID[attachmentFetcher.id] = contextInfo;
            // Prevent cancellation of the fetch once it was fulfilled or rejected.
            const resetCancelToken = () => {
                if (this.contextInfoByID[attachmentFetcher.id] != null)
                    this.contextInfoByID[attachmentFetcher.id].cancelTokenPromise = null;
            };
            attachmentFetcher.attachment.then((value) => {
                resetCancelToken();
                return value;
            }, (reason) => {
                resetCancelToken();
                return reason;
            });
            // Keep the attachment fetcher alive until it is stopped.
            this.ditto.keepAlive.retain(`AttachmentFetcher.${attachmentFetcher.id})`);
            return attachmentFetcher;
        });
    }
    /**
     * Stop an attachment fetcher and wait for it to be stopped.
     *
     * @internal */
    async stopAttachmentFetcher(attachmentFetcher) {
        this.finalizationRegistry.unregister(attachmentFetcher);
        const contextInfo = this.contextInfoByID[attachmentFetcher.id];
        if (contextInfo == null) {
            throw new Error(`Internal inconsistency: cannot stop attachment fetcher ${attachmentFetcher.id}, which is not registered.`);
        }
        await this.stopWithContextInfo(contextInfo);
    }
    /**
     * Closing the manager will cancel all attachment fetchers.
     *
     * @internal
     */
    close() {
        // REFACTOR: the closing closure runs detached from here which is a smell.
        // Can we make this whole closing mechanism non-async? The culprit is
        // the cancelTokenPromise that _have to_ `await` on close. The reason
        // for this is that the FFI function `ditto_resolve_attachment()` is
        // async but should be non-async. Refactor and make that non-async, then
        // de-async-ify the closing mechanism.
        void this.ditto.deferCloseAsync(async () => {
            const contextInfos = Object.values(this.contextInfoByID);
            const stopped = contextInfos.map(async (contextInfo) => {
                const attachmentFetcher = contextInfo.attachmentFetcher.deref();
                if (attachmentFetcher != null)
                    await this.stopAttachmentFetcher(attachmentFetcher);
            });
            await Promise.all(stopped);
        });
    }
    /**
     * Stop the attachment fetcher without unregistering it from the finalization
     * registry.
     */
    stopWithContextInfo(contextInfo) {
        return this.ditto.deferCloseAsync(async (dittoHandle) => {
            // Remove the manager's own record of the context info.
            if (this.contextInfoByID[contextInfo.id] == null) {
                throw new Error(`Internal inconsistency: attachment fetcher ${contextInfo.id} not found in active attachment fetchers.`);
            }
            delete this.contextInfoByID[contextInfo.id];
            // Release the keep-alive.
            this.ditto.keepAlive.release(`AttachmentFetcher.${contextInfo.id})`);
            // Cancel the fetcher if it is still running.
            const cancelToken = await contextInfo.cancelTokenPromise;
            if (cancelToken) {
                dittoCancelResolveAttachment(dittoHandle.deref(), contextInfo.attachmentTokenID, cancelToken);
            }
        });
    }
}

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
/**
 * The entrypoint for small peer user info collection. Small peer info consists
 * of information gathered into a system collection on a regular interval and
 * optionally synced to the Big Peer for device dashboard and debugging
 * purposes.
 *
 * An instance of this class is available on each `Ditto` instance via its
 * {@link Ditto.smallPeerInfo | `smallPeerInfo`} property. Instantiating this
 * class directly is not supported.
 */
class SmallPeerInfo {
    /**
     * Indicates whether small peer info collection is currently enabled, defaults
     * to `true`.
     *
     * **Note**: whether the background ingestion process is enabled or not is a
     * separate decision to whether this information is allowed to sync to other
     * peers (including the big peer). This is controlled by
     * {@link getSyncScope | getSyncScope()} and
     * {@link setSyncScope | setSyncScope()}.
     */
    get isEnabled() {
        return this.ditto.deferClose((dittoHandle) => {
            return dittoSmallPeerInfoGetIsEnabled(dittoHandle.deref());
        });
    }
    /**
     * Set whether small peer info collection is enabled.
     *
     * @throws when set to a non-boolean value.
     */
    set isEnabled(newValue) {
        if (typeof newValue !== 'boolean')
            throw new TypeError(`Expected boolean, got ${typeof newValue}`);
        this.ditto.deferClose((dittoHandle) => {
            dittoSmallPeerInfoSetEnabled(dittoHandle.deref(), newValue);
        });
    }
    /**
     * The metadata associated with the small peer info.
     *
     * Small peer info metadata is a free-form, user-provided JSON object that
     * is inserted into the small peer info system document at each collection
     * interval.
     */
    get metadata() {
        return JSON.parse(this.metadataJSONString);
    }
    /**
     * Set the metadata associated with the small peer info.
     *
     * The metadata must be a JSON-serializable object that conforms to the
     * following constraints:
     *
     * - Must be a JSON object (not an array, string, number, etc.)
     * - The size when encoded as JSON must be less than 128 KB
     * - May only be nested up to 64 levels deep
     *
     * @example <caption>Valid metadata</caption>
     * ditto.smallPeerInfo.metadata = {
     *  "foo": "bar",
     *  "nested": {
     *    "inner": "value"
     *   }
     * }
     *
     * @throws when set to a value that violates any of the constraints listed
     * above.
     */
    set metadata(metadata) {
        this.metadataJSONString = JSON.stringify(metadata);
    }
    /**
     * The metadata associated with the small peer info, as a JSON string.
     */
    get metadataJSONString() {
        return this.ditto.deferClose((dittoHandle) => {
            return dittoSmallPeerInfoGetMetadata(dittoHandle.deref());
        });
    }
    /**
     * Set the metadata associated with the small peer info, as a JSON string.
     *
     * @see {@link SmallPeerInfo.metadata | `metadata`} for more information on
     * valid values.
     * @throws when set to a value that violates any of the constraints listed in
     * {@link SmallPeerInfo.metadata | `metadata`}.
     */
    set metadataJSONString(metadata) {
        if (typeof metadata !== 'string')
            throw new TypeError(`Expected string, got ${typeof metadata}`);
        this.ditto.deferClose((dittoHandle) => {
            // throws if any validation errors occur
            dittoSmallPeerInfoSetMetadata(dittoHandle.deref(), metadata);
        });
    }
    /**
     * Determines which "kind" of peers the small peer info will be replicated to.
     *
     * Defaults to `LocalPeerOnly`, which means no replication. Set this to
     * `BigPeerOnly` to replicate collected info to the Big Peer.
     *
     * @throws when set to a value other than `BigPeerOnly` or `LocalPeerOnly`.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    get syncScope() {
        return this.ditto.deferClose((dittoHandle) => {
            return dittoSmallPeerInfoGetSyncScope(dittoHandle.deref());
        });
    }
    set syncScope(syncScope) {
        this.ditto.deferClose((dittoHandle) => {
            return dittoSmallPeerInfoSetSyncScope(dittoHandle.deref(), syncScope);
        });
    }
    /**
     * Determines which "kind" of peers the small peer info will be replicated to.
     *
     * Defaults to `LocalPeerOnly`, which means no replication. Set this to
     * `BigPeerOnly` to replicate collected info to the Big Peer.
     *
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    async getSyncScope() {
        return this.ditto.deferClose((dittoHandle) => {
            return dittoSmallPeerInfoGetSyncScope(dittoHandle.deref());
        });
    }
    /**
     * Set the sync scope.
     *
     * See {@link getSyncScope} for more information.
     *
     * @param syncScope the new sync scope.
     * @throws when set to a value other than `BigPeerOnly` or `LocalPeerOnly`.
     * @deprecated Use DQL (Ditto Query Language) instead. For more information
     * see: https://ditto.com/link/dql-legacy-to-dql-adoption
     */
    async setSyncScope(syncScope) {
        return this.ditto.deferClose((dittoHandle) => {
            return dittoSmallPeerInfoSetSyncScope(dittoHandle.deref(), syncScope);
        });
    }
    /** @internal */
    constructor(ditto) {
        this.ditto = ditto;
    }
}

//
// Copyright © 2025 DittoLive Incorporated. All rights reserved.
//
const AUTH_HANDLER_NOOP = {
    authenticationRequired(_authenticator) { },
    authenticationExpiringSoon(_authenticator, _secondsRemaining) { },
    authenticationStatusDidChange(_authenticator) { },
};
/**
 * The name of the directory, relative to the current working directory, that
 * will be used for persistence if no other directory is specified.
 *
 * @internal
 * @deprecated The new Ditto configuration APIs define the default in core
 */
const DEFAULT_PERSISTENCE_DIRECTORY = 'ditto';
/**
 * @internal
 */
class ConfigOrParameters {
    get isConfig() {
        return this._config !== undefined;
    }
    get isParameters() {
        return this._parameters !== undefined;
    }
    get kind() {
        if (this.isConfig && !this.isParameters) {
            return 'config';
        }
        else if (this.isParameters && !this.isConfig) {
            return 'parameters';
        }
        else {
            throw new DittoError('internal', 'ConfigOrParameters is neither a config nor parameters');
        }
    }
    get config() {
        switch (this.kind) {
            case 'config':
                return this._config;
            case 'parameters':
                const identity = this._parameters.identity;
                switch (identity.type) {
                    case 'onlineWithAuthentication':
                    case 'onlinePlayground':
                        return new DittoConfig(identity.appID, {
                            mode: 'server',
                            url: this.urlFrom(identity.customAuthURL, identity.appID),
                        }, this._parameters.persistenceDirectory);
                    case 'sharedKey':
                        return new DittoConfig(identity.appID, {
                            mode: 'smallPeersOnly',
                            privateKey: identity.sharedKey,
                        }, this._parameters.persistenceDirectory);
                    case 'offlinePlayground':
                        return new DittoConfig(identity.appID, {
                            mode: 'smallPeersOnly',
                        }, this._parameters.persistenceDirectory);
                    case 'manual':
                        Logger.warning("Can't create a `DittoConfig` from a `manual` " +
                            ' identity, manual identities are being phased out and ' +
                            'not supported with the `DittoConfig`-based APIs anymore. ' +
                            "Mapping onto `{ mode: 'smallPeersOnly' }`.");
                        return new DittoConfig(DittoConfig.DEFAULT_DATABASE_ID, {
                            mode: 'smallPeersOnly',
                        }, this._parameters.persistenceDirectory);
                }
        }
    }
    get identity() {
        switch (this.kind) {
            case 'parameters':
                return this._parameters.identity;
            case 'config':
                const { databaseID: id, connect } = this._config;
                switch (connect.mode) {
                    case 'server':
                        return {
                            type: 'onlineWithAuthentication',
                            appID: id,
                            authHandler: AUTH_HANDLER_NOOP,
                            enableDittoCloudSync: false,
                            customAuthURL: connect.url,
                        };
                    case 'smallPeersOnly':
                        if (connect.privateKey) {
                            return {
                                type: 'sharedKey',
                                appID: id,
                                sharedKey: connect.privateKey,
                            };
                        }
                        else {
                            return {
                                type: 'offlinePlayground',
                                appID: id,
                            };
                        }
                }
        }
    }
    get persistenceDirectory() {
        switch (this.kind) {
            case 'parameters':
                return this._parameters.persistenceDirectory;
            case 'config':
                return this._config.persistenceDirectory;
        }
    }
    constructor(identityOrConfig, persistenceDirectory) {
        // Not supported by the JS SDK
        this.passphrase = null;
        this.historyTrackingEnabled = false;
        if (identityOrConfig instanceof DittoConfig) {
            this._config = identityOrConfig;
            this._parameters = undefined;
        }
        else {
            const persistenceDirectoryValidated = this.validatePersistenceDirectory(persistenceDirectory);
            this.validateIdentity(identityOrConfig);
            this._parameters = {
                identity: identityOrConfig,
                persistenceDirectory: persistenceDirectoryValidated,
            };
            this._config = undefined;
        }
    }
    /**
     * Returns a copy having sensitive data replaced with a placeholder
     */
    redactingSensitiveData() {
        switch (this.kind) {
            case 'config':
                const configCopy = this._config.copy();
                if (configCopy.connect.mode === 'smallPeersOnly' &&
                    configCopy.connect.privateKey != null)
                    configCopy.connect.privateKey = '[REDACTED]';
                return new ConfigOrParameters(configCopy);
            case 'parameters':
                const identityCopy = { ...this._parameters.identity };
                if (identityCopy.type === 'sharedKey')
                    identityCopy.sharedKey = '[REDACTED]';
                return new ConfigOrParameters(identityCopy, this._parameters.persistenceDirectory);
        }
    }
    validateIdentity(identity) {
        var _a, _b;
        if (!identity || typeof identity !== 'object') {
            throw new TypeError('Expected `identity` to be an object, but got: ' + typeof identity);
        }
        const validIdentity = { ...identity };
        // @ts-expect-error we validate the existence of the value below.
        const appID = identity.appID;
        if (![
            'offlinePlayground',
            'sharedKey',
            'manual',
            'onlinePlayground',
            'onlineWithAuthentication',
        ].includes(identity.type))
            throw new Error(`Unknown identity type: ${identity.type}`);
        if ((identity.type === 'offlinePlayground' ||
            identity.type === 'sharedKey' ||
            identity.type === 'onlinePlayground' ||
            identity.type === 'onlineWithAuthentication') &&
            typeof appID === 'undefined')
            throw new Error(`Property .appID must be given for identity, but isn't.`);
        if (typeof appID !== 'undefined' && typeof appID !== 'string') {
            throw new Error(`Property .appID must be be of type string, but is of type '${typeof appID}': ${appID}`);
        }
        if ((identity.type === 'offlinePlayground' ||
            identity.type === 'sharedKey') &&
            typeof identity.siteID !== 'undefined') {
            const siteID = identity.siteID;
            const isSiteIDNumberOrBigInt = typeof siteID === 'number' || typeof siteID === 'bigint';
            if (!isSiteIDNumberOrBigInt)
                throw new Error('siteID must be a number or BigInt');
            if (siteID < 0)
                throw new Error('siteID must be >= 0');
            if (siteID > BigInt('0xffffffffffffffff'))
                throw new Error('siteID must be < 2^64');
        }
        if (identity.type === 'offlinePlayground') {
            if (typeof identity.siteID !== 'undefined') {
                Logger.warning(`Property .siteID is deprecated and should no longer be specified in an offline playground identity.`);
            }
        }
        if (identity.type === 'sharedKey') {
            if (typeof identity.siteID !== 'undefined') {
                Logger.warning(`Property .siteID is deprecated and should no longer be specified in a shared key identity.`);
            }
            // No validations of the remainder of the properties yet.
        }
        if (identity.type === 'manual') ;
        if (identity.type === 'onlinePlayground') {
            const token = identity.token;
            if (typeof token === 'undefined') {
                throw new Error(`Property .token must be given for identity but isn't. You can find the corresponding token on the Ditto Portal.`);
            }
            if (typeof token !== 'undefined' && typeof token !== 'string') {
                throw new Error(`Property .token of identity must be be of type string, but is of type '${typeof token}': ${token}`);
            }
        }
        if (identity.type === 'onlineWithAuthentication') {
            const authHandlerType = typeof identity.authHandler;
            if (authHandlerType !== 'object') {
                throw new TypeError(`Property .authHandler on identity of type onlineWithAuthentication must be an object, but is of type '${authHandlerType}'.`);
            }
            const expiringSoonType = typeof ((_a = identity.authHandler) === null || _a === void 0 ? void 0 : _a.authenticationExpiringSoon);
            const authenticationRequiredType = typeof ((_b = identity.authHandler) === null || _b === void 0 ? void 0 : _b.authenticationRequired);
            if (expiringSoonType !== 'function') {
                throw new TypeError(`Property .authHandler.authenticationExpiringSoon on identity of type onlineWithAuthentication must be a function, but is of type '${expiringSoonType}'.`);
            }
            if (authenticationRequiredType !== 'function') {
                throw new TypeError(`Property .authHandler.authenticationRequired on identity of type onlineWithAuthentication must be a function, but is of type '${authenticationRequiredType}'.`);
            }
        }
        return validIdentity;
    }
    /**
     * Returns the default persistence directory if the given path is null and
     * throws an error if the given path is empty or contains only whitespace.
     *
     * @deprecated this is only used by the legacy `DittoConfig` constructor.
     */
    validatePersistenceDirectory(persistenceDirectory) {
        if (persistenceDirectory == null)
            return DEFAULT_PERSISTENCE_DIRECTORY;
        if (persistenceDirectory.trim().length === 0) {
            throw new Error(`Invalid persistenceDirectory: '${persistenceDirectory}'`);
        }
        return persistenceDirectory;
    }
    urlFrom(customAuthURL, appID) {
        if (customAuthURL != null)
            return customAuthURL;
        return `https://${appID}.cloud.ditto.live`;
    }
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
// -----------------------------------------------------------------------------
/**
 * Ditto is the entry point for accessing Ditto-related functionality.
 */
class Ditto {
    /**
     * A string containing the semantic version of the Ditto SDK. Example: 4.4.3
     */
    static get VERSION() {
        // Requires having called FFI.initSDKVersion() first.
        return dittoGetSDKSemver();
    }
    /**
     * The default root directory used for Ditto data persistence.
     *
     * This property returns the platform-dependent directory where Ditto stores
     * its data when a relative persistence directory path (or `null`) is
     * provided.
     *
     * **Node.js**
     *
     * - On macOS, this is the `~/Library/Application Support/ditto` directory.
     * - On Windows, this is the `~/AppData/Roaming/ditto` directory.
     * - On Linux, this is the `~/.local/share/ditto` directory.
     *
     * Note that sandboxed environments, such as Electron apps running under
     * Apple's App Sandbox, can require setting a
     * {@link DittoConfig.persistenceDirectory | custom persistence directory} as
     * these default directories may not be accessible.
     *
     * **React Native**
     *
     * - On iOS and macOS, this is the Application Support directory.
     * - On Android, this is the app's internal files directory.
     *
     * **Browsers**
     *
     * In browsers, this returns an empty string as there is no file system
     * access.
     *
     * @returns A string representing the default root directory.
     * @throws {DittoError} `sdk/unsupported` if the current environment is not
     * supported by Ditto.
     * @see {@link DittoConfig.persistenceDirectory} for more information on
     * configuring the persistence directory.
     */
    static get DEFAULT_ROOT_DIRECTORY() {
        {
            const { homedir } = require('os');
            const path = require('path');
            if (process.platform === 'darwin') {
                return path.join(homedir(), 'Library', 'Application Support', 'ditto');
            }
            else if (process.platform === 'win32') {
                return path.join(homedir(), 'AppData', 'Roaming', 'ditto');
            }
            else {
                // Linux
                return path.join(homedir(), '.local', 'share', 'ditto');
            }
        }
    }
    /**
     * Asynchronously creates and returns a new `Ditto` instance using the
     * provided configuration.
     *
     * This is the recommended way to initialize Ditto in async environments.
     *
     * This API is in **preview** and will become the standard way to initialize
     * Ditto instances in v5, replacing the legacy
     * {@link Ditto.constructor | Ditto constructor}.
     *
     * In Ditto 4.x, this method is only partially `async` and blocks for a
     * significant portion of the initialization process. It will become fully
     * `async` in Ditto 5.x.
     *
     * @param config - The configuration to initialize the new Ditto instance
     *   with. Defaults to {@link DittoConfig.default}.
     *
     * @returns The newly created `Ditto` instance.
     *
     * @throws {@link DittoError} with code `persistenceDirectoryLocked` if the
     *   chosen persistence directory is already in use by another Ditto instance.
     *
     * @throws {@link DittoError} with code `invalidDittoConfig` if the passed in
     *   `DittoConfig`'s contents do not meet the required validation criteria.
     *   For detailed information on the validation requirements, consult the
     *   documentation of the individual properties of `DittoConfig`.
     *
     * @throws May throw other {@link DittoError}s for other initialization
     * failures.
     *
     * @see {@link openSync | Ditto.openSync()} for a blocking, non-async
     * alternative.
     */
    static async open(config = DittoConfig.default) {
        if (!(config instanceof DittoConfig)) {
            throw new TypeError(`Ditto.open() expects a DittoConfig, but got ${typeof config}`);
        }
        if (typeof config.connect !== 'object') {
            throw new TypeError(`Ditto.open() expects a DittoConfig with a \`connect\` property, but got ${typeof config.connect}`);
        }
        if (!Ditto.isEnvironmentSupported()) {
            throw new Error('Ditto does not support this JavaScript environment. Please consult ' +
                'the Ditto JavaScript documentation for a list of supported ' +
                'environments and browsers. You can use ' +
                '`Ditto.isEnvironmentSupported()` to run this check anytime.');
        }
        // FIXME: Failures in error reporting in the async open method
        //
        // const dittoPointer = await mapFFIErrorsAsync(async () =>
        //   FFI.dittoOpenAsyncThrows(
        //     config.toCBOR(),
        //     'PlatformDependent',
        //     Ditto.DEFAULT_ROOT_DIRECTORY,
        //   ),
        // );
        const dittoPointer = mapFFIErrors(() => dittoOpenThrows(config.toCBOR(), 'PlatformDependent', Ditto.DEFAULT_ROOT_DIRECTORY));
        // We are passing undocumented parameters to the constructor
        // @ts-expect-error ts(2554)
        return new Ditto(null, null, config, dittoPointer);
    }
    /**
     * Synchronously creates and returns a new `Ditto` instance using the provided
     * configuration.
     *
     * This is a blocking convenience method for initializing Ditto, intended for
     * use in non-async environments.
     *
     * This API is in **preview** and will become the standard way to initialize
     * Ditto instances in v5, replacing the legacy
     * {@link Ditto.constructor | Ditto constructor}.
     *
     * @param config - The configuration to initialize the new Ditto instance
     *   with. Defaults to {@link DittoConfig.default}.
     *
     * @returns The newly created `Ditto` instance.
     *
     * @throws {@link DittoError} with code `persistenceDirectoryLocked` if the
     *   chosen persistence directory is already in use by another Ditto instance.
     *
     * @throws {@link DittoError} with code `invalidDittoConfig` if the passed in
     *   `DittoConfig`'s contents do not meet the required validation criteria.
     *   For detailed information on the validation requirements, consult the
     *   documentation of the individual properties of `DittoConfig`.
     *
     * @throws May throw other {@link DittoError}s for other initialization
     * failures.
     *
     * @see {@link open | Ditto.open()} for an async alternative.
     */
    static openSync(config = DittoConfig.default) {
        if (!(config instanceof DittoConfig)) {
            throw new TypeError(`Ditto.openSync() expects a DittoConfig, but got ${typeof config}`);
        }
        if (typeof config.connect !== 'object') {
            throw new TypeError(`Ditto.open() expects a DittoConfig with a \`connect\` property, but got ${typeof config.connect}`);
        }
        if (!Ditto.isEnvironmentSupported()) {
            throw new Error('Ditto does not support this JavaScript environment. Please consult ' +
                'the Ditto JavaScript documentation for a list of supported ' +
                'environments and browsers. You can use ' +
                '`Ditto.isEnvironmentSupported()` to run this check anytime.');
        }
        const dittoPointer = mapFFIErrors(() => dittoOpenThrows(config.toCBOR(), 'PlatformDependent', Ditto.DEFAULT_ROOT_DIRECTORY));
        // We are passing undocumented parameters to the constructor
        // @ts-expect-error ts(2554)
        return new Ditto(null, null, config, dittoPointer);
    }
    /**
     * Configure a custom identifier for this peer.
     *
     * When using {@link Presence.observe | presence.observe()}, each remote peer
     * is represented by a short UTF-8 "device name". By default this will be a
     * truncated version of the device's hostname.
     *
     * Changes to this property after {@link startSync | startSync()} was called
     * will only take effect after the next restart of sync. The value does not
     * need to be unique among peers. Device names longer than 24 bytes will be
     * truncated once {@link startSync | startSync()} is called.
     */
    get deviceName() {
        return this._deviceName;
    }
    set deviceName(value) {
        if (this.isSyncActive) {
            Logger.warning('Changes to the device name take effect when sync is restarted.');
        }
        this._deviceName = value;
    }
    /**
     * Returns a string identifying the version of the Ditto SDK. *
     *
     * @deprecated This property is deprecated, use {@link Ditto.VERSION} instead.
     */
    get sdkVersion() {
        return this.deferClose((dittoHandle) => {
            return dittoGetSDKVersion(dittoHandle.deref());
        });
    }
    /**
     * The (validated) identity this Ditto instance was initialized with.
     *
     * **Phased out in 4.x.** This API will be replaced by {@link DittoConfig} in
     * v5.
     */
    get identity() {
        if (this.configOrParameters.isConfig) {
            Logger.warning('Accessing legacy `identity` property on a Ditto instance initialized ' +
                'with the new DittoConfig API. The mapping may not be exact.');
        }
        return this.configOrParameters.identity;
    }
    /**
     * The path this Ditto instance was initialized with, if no path was given at
     * construction time, the default value is returned (see constructor).
     *
     * @deprecated `Ditto.path` is deprecated. Please update your code to use the
     * new 'Ditto.persistenceDirectory' property instead.
     */
    get path() {
        Logger.warning("'Ditto.path' is deprecated. Use 'Ditto.persistenceDirectory' instead.");
        return this.persistenceDirectory;
    }
    /**
     * The configuration used to initialize this `Ditto` instance.
     *
     * This API is in **preview** and provides a read-only property to access the
     * configuration used during initialization of a `Ditto` instance in v5.
     *
     * Note: Sensitive data such as passphrases and private keys are redacted from
     * the returned configuration and replaced with the string `[REDACTED]`.
     *
     * If this instance was initialized using the deprecated parameter-based APIs,
     * the returned configuration will be an incomplete approximation, since there
     * is no exact 1:1 mapping between the old parameters and the new
     * {@link DittoConfig}. In this case, a warning will be logged.
     *
     * - Warning: Accessing this property on a `Ditto` instance created with the
     *   deprecated parameter-based APIs may result in a partially filled
     *   configuration. Prefer using the new `DittoConfig`-based initialization
     *   methods {@link Ditto.open | Ditto.open()} and
     *   {@link Ditto.openSync | Ditto.openSync()} whenever possible.
     */
    get config() {
        if (this.configOrParameters.isParameters) {
            Logger.warning(`Attempted to access property 'config' of a 'Ditto' ` +
                `instance initialized using the deprecated parameter-based APIs. ` +
                `Since there is no exact 1:1 mapping between the old parameters ` +
                `and the new 'DittoConfig', the returned configuration will be an ` +
                `incomplete approximation.`);
        }
        return this.configOrParameters.config;
    }
    /**
     * The persistence directory used by Ditto to persist data, represented by an
     * absolute path.
     *
     * It is not recommended to directly read or write to this directory as its
     * structure and contents are managed by Ditto and may change in future
     * versions.
     *
     * When {@link Logger} is enabled, logs may be written to this directory even
     * after a Ditto instance was deallocated. Please refer to the documentation
     * of {@link Logger} for more information.
     *
     * In browsers, this string acts as a namespace for the in-memory data store
     * and does not correspond to a file system directory.
     */
    get absolutePersistenceDirectory() {
        return this.deferClose((dittoHandle) => {
            return dittoAbsolutePersistenceDirectory(dittoHandle.deref());
        });
    }
    /**
     * Path to the local directory used for persistent data storage.
     *
     * Defaults to 'ditto'. In environments without file system access, such as
     * browsers, this is used as a namespace for the internal data store.
     *
     * It is not recommended to directly read or write to this directory as its
     * structure and contents are managed by Ditto and may change in future
     * versions.
     *
     * When {@link Logger} is enabled, logs may be written to this directory even
     * after a Ditto instance was {@link Ditto.close | closed}. Please refer to
     * the documentation of {@link Logger} for more information.
     *
     * @deprecated replaced by
     * {@link Ditto.absolutePersistenceDirectory | absolutePersistenceDirectory},
     * which guarantees an absolute path.
     */
    get persistenceDirectory() {
        return this.configOrParameters.persistenceDirectory;
    }
    /**
     * Returns `true` if an offline license token has been set, otherwise returns `false`.
     *
     * @see {@link setOfflineOnlyLicenseToken | setOfflineOnlyLicenseToken()}
     */
    get isActivated() {
        return this.deferClose((dittoHandle) => {
            return dittoIsActivated(dittoHandle.deref());
        });
    }
    /**
     * `true` once {@link Ditto.close | Ditto.close()} has been called, otherwise
     * `false`.
     */
    get isClosed() {
        var _a;
        return (_a = this._isClosed) !== null && _a !== void 0 ? _a : false;
    }
    /**
     * Returns `true` if sync is active, otherwise returns `false`. Use
     * {@link startSync | startSync()} to activate and
     * {@link stopSync | stopSync()} to deactivate sync.
     *
     * @deprecated use {@link Sync.isActive | ditto.sync.isActive} instead.
     */
    get isSyncActive() {
        return this.deferClose((dittoHandle) => {
            return dittoIsSyncActive(dittoHandle.deref());
        });
    }
    /**
     * Initializes a new `Ditto` instance.
     *
     * **NOTE**: The `sharedKey` identity is only supported for Node environments,
     * using this to create a Ditto instance in the web browser will throw an
     * exception.
     *
     * **Phased out in 4.x** — replaced by
     * {@link Ditto.open | Ditto.open()} and
     * {@link Ditto.openSync | Ditto.openSync()} factory methods. This API will be
     * replaced by the new factory methods in v5.
     *
     * @param identity - Identity for the new Ditto instance, defaults to
     * `offlinePlayground` with `appID` being the empty string `''`.
     *
     * @param persistenceDirectory optional string containing a directory path
     * that Ditto will use for persistence. Defaults to `"ditto"`. On Windows, the
     * path will be automatically normalized.
     *
     * @see {@link Ditto.identity}
     * @see {@link Ditto.persistenceDirectory}
     * @throws {Error} when the current environment is not supported by this SDK.
     * @throws {Error} for other failures during initialization of Ditto and
     * validation of the provided identity.
     */
    // NOTE: This constructor takes undocumented additional parameters so that the
    // async part of making a new Ditto instance can be done in Ditto.open() and
    // this constructor uses the outputs of that to set up the Ditto instance.
    constructor(identity, persistenceDirectory) {
        var _a, _b, _c, _d, _e;
        // ------------------------------------------------------------ Private ------
        this.deferCloseAllowed = true;
        this._isClosed = false;
        /** Set of pending operations that need to complete before the Ditto instance can be closed in a safe manner. */
        this.pendingOperations = new Set();
        if (!Ditto.isEnvironmentSupported()) {
            throw new Error('Ditto does not support this JavaScript environment. Please consult ' +
                'the Ditto JavaScript documentation for a list of supported ' +
                'environments and browsers. You can use ' +
                '`Ditto.isEnvironmentSupported()` to run this check anytime.');
        }
        let dittoPointer = null;
        let configOrParameters;
        // See `Ditto.open()` and `Ditto.openSync()` where this constructor is
        // called with undocumented parameters:
        // - DittoConfig instance
        // - FFI.Pointer<FFI.FFIDitto>
        if (arguments.length === 4 && arguments[2] instanceof DittoConfig) {
            // the constructor was called from Ditto.open() or Ditto.openSync()
            if (identity != null || persistenceDirectory != null) {
                throw new DittoError('internal', 'identity and persistenceDirectory params must be null when constructing Ditto with DittoConfig');
            }
            configOrParameters = new ConfigOrParameters(arguments[2]);
            dittoPointer = arguments[3];
        }
        else {
            // the constructor was called directly
            const identityOrDefault = identity !== null && identity !== void 0 ? identity : DEFAULT_IDENTITY;
            configOrParameters = new ConfigOrParameters(identityOrDefault, persistenceDirectory);
        }
        this.configOrParameters = configOrParameters.redactingSensitiveData();
        // Legacy Ditto initialization
        if (dittoPointer == null) {
            const identityConfig = makeIdentityConfig(configOrParameters.identity);
            // History tracking is an experimental and deprecated feature that is not
            // supported in the JS SDK.
            const historyTracking = 'Disabled';
            // The JS SDK, unlike (nearly all of) the other SDKs, expects its `TransportConfig`s to have
            // certain transports enabled/disabled by default. Specifically, it expects this to be
            // determined for P2P transports based on the environment. We specify this here by setting
            // `transportConfigMode` to 'PlatformDependent'.
            const transportConfigMode = 'PlatformDependent';
            dittoPointer = mapFFIErrors(() => dittoTryNewBlocking(configOrParameters.persistenceDirectory, identityConfig, historyTracking, transportConfigMode));
        }
        Bridge.ditto.bridge(dittoPointer, this);
        this._deviceName = defaultDeviceName();
        // WORKAROUND (only for legacy identity): the login provider triggers the
        // registered callback right when the auth client is being constructed. At
        // this point, we don't have the auth client, which would be needed to
        // perform a login, nor did we have a chance to create an authenticator.
        // Therefore catch that first callback, store the seconds remaining and
        // proceed with propagating it after all pieces are in place.
        let secondsRemainingUntilAuthenticationExpires = null;
        let enableDittoCloudSync = false;
        this.keepAlive = new KeepAlive();
        if (configOrParameters.isConfig) {
            // For the new config, no auth callback handler is set up in the Ditto
            // constructor. Instead, it is set up every time an expiration handler is
            // set.
            this.auth = new OnlineAuthenticatorV2(this.keepAlive, this);
        }
        else if (((_a = configOrParameters.identity) === null || _a === void 0 ? void 0 : _a.type) === 'onlineWithAuthentication') {
            // IMPORTANT: Keeping the auth client around accumulates run-times and
            // resources which becomes a problem specifically in tests (where we use one
            // Ditto instance per test). We therefore keep it only if needed, i.e.
            // _only_ for the onlineWithAuthentication and online identities and
            // transfer ownership of it to the authenticator.
            enableDittoCloudSync =
                (_c = (_b = configOrParameters.identity) === null || _b === void 0 ? void 0 : _b.enableDittoCloudSync) !== null && _c !== void 0 ? _c : true;
            this.auth = new OnlineAuthenticator(this.keepAlive, this, configOrParameters.identity.authHandler);
            const weakThis = new WeakRef(this);
            const loginProviderPointer = dittoAuthClientMakeLoginProvider(function (secondsRemaining) {
                const strongThis = weakThis.deref();
                if (!strongThis) {
                    Logger.warning(`Internal inconsistency, LoginProvider callback fired after the corresponding Ditto instance has been deallocated.`);
                    return;
                }
                if (strongThis.auth) {
                    strongThis.auth['@ditto.authenticationExpiring'](secondsRemaining);
                }
                else {
                    // WORKAROUND: see description above where the
                    // secondsRemainingUntilAuthenticationExpires variable is declared.
                    secondsRemainingUntilAuthenticationExpires = secondsRemaining;
                }
            });
            // We don't need to worry about awaiting the result of this call because
            // auth all happens in the background and so there are no guarantees we
            // need to uphold by making sure things are in a certain state before the
            // constructor finishes
            void dittoAuthSetLoginProvider(dittoPointer, loginProviderPointer);
        }
        else if (((_d = configOrParameters.identity) === null || _d === void 0 ? void 0 : _d.type) === 'onlinePlayground') {
            enableDittoCloudSync =
                (_e = configOrParameters.identity.enableDittoCloudSync) !== null && _e !== void 0 ? _e : true;
            this.auth = new OnlineAuthenticator(this.keepAlive, this, {
                authenticationRequired: function (authenticator) {
                    // No-op.
                },
                authenticationExpiringSoon: function (authenticator, secondsRemaining) {
                    // No-op.
                },
            });
        }
        else {
            this.auth = new NotAvailableAuthenticator(this.keepAlive);
        }
        dittoSetCloudSyncEnabled(dittoPointer, enableDittoCloudSync);
        transportsInit();
        //
        // Assign instance properties.
        //
        this.appID = dittoAuthClientGetAppID(dittoPointer);
        this.siteID = dittoAuthClientGetSiteID(dittoPointer);
        this.sync = new Sync(this);
        this.store = new Store(this);
        this.smallPeerInfo = new SmallPeerInfo(this);
        this.presence = new Presence(this);
        this.presenceManager = new PresenceManager(this);
        this.liveQueryManager = new LiveQueryManager(this, this.keepAlive);
        this.attachmentFetcherManager = new AttachmentFetcherManager(this);
        this.transportConditionsManager = new TransportConditionsManager(this);
        this.subscriptionManager = new SubscriptionManager(this);
        disableDeadlockTimeoutWhenDebugging();
        // WORKAROUND: see description above where the
        // secondsRemainingUntilAuthenticationExpires variable is declared.
        if (configOrParameters.isParameters &&
            secondsRemainingUntilAuthenticationExpires != null) {
            this.auth['@ditto.authenticationExpiring'](secondsRemainingUntilAuthenticationExpires);
        }
    }
    /**
     * Don't terminate the process when callbacks are pending for a long time.
     *
     * Some methods in the Ditto library accept asynchronous functions as callback
     * parameters. If these asynchronous functions do not resolve within a certain
     * period of time after having been invoked by Ditto, deadlock detection gets
     * triggered, resulting in the termination of the process.
     *
     * When Ditto is executed in a Node.js environment with an interactive
     * debugger attached, this deadlock detection might get activated upon
     * encountering a breakpoint. Calling `Ditto.disableDeadlockDetection()`
     * disables this behavior, thus allowing the use of an interactive debugger
     * without triggering the deadlock detection.
     *
     * This feature is only available in Node.js environments.
     */
    static disableDeadlockDetection() {
        {
            const current = getDeadlockTimeout();
            if (current !== 0) {
                try {
                    setDeadlockTimeout(0);
                }
                catch (e) {
                    throw new Error(`Failed to disable deadlock detection: ${e === null || e === void 0 ? void 0 : e.message}`);
                }
            }
        }
    }
    /**
     * Returns `true` if deadlock detection is enabled.
     *
     * See
     * {@link Ditto.disableDeadlockDetection | Ditto.disableDeadlockDetection()}
     * for more information.
     *
     * When called outside of a Node.js environment, this method always returns
     * `false` as deadlock detection is only available in Node.js.
     *
     * @returns `true` if deadlock detection is enabled
     */
    static hasDeadlockDetection() {
        return getDeadlockTimeout() !== 0;
    }
    /**
     * Check if the current environment supports running Ditto.
     *
     * Required APIs include:
     *
     * - `BigInt`
     * - `FinalizationRegistry`
     * - `WeakRef`
     *
     *  Internet Explorer is not supported.
     *
     * @returns `true` if the environment is supported
     */
    static isEnvironmentSupported() {
        // From https://stackoverflow.com/questions/21825157/internet-explorer-11-detection
        let isIE = false;
        if (typeof window !== 'undefined' &&
            window.navigator &&
            window.navigator.userAgent &&
            window.navigator.appVersion) {
            isIE =
                window.navigator.userAgent.indexOf('MSIE') !== -1 ||
                    window.navigator.appVersion.indexOf('Trident/') > -1;
        }
        let hasRequiredAPIs;
        try {
            hasRequiredAPIs = checkAPIs();
        }
        catch (error) {
            throw new Error(`Error checking environment support: ${error}`);
        }
        return !isIE && hasRequiredAPIs;
    }
    /**
     * Activate a `Ditto` instance by setting an offline only license token. You
     * cannot initiate sync with `Ditto` before you have activated it. The offline
     * license token is only valid for identities of type `development`, `manual`,
     * `offlinePlayground`, and `sharedKey`.
     *
     * @param licenseToken the license token to activate the `Ditto` instance
     * with. You can find yours on the [Ditto portal](https://portal.ditto.live).
     */
    setOfflineOnlyLicenseToken(licenseToken) {
        if (typeof licenseToken !== 'string') {
            throw new TypeError(`Expected parameter licenseToken to have type string, but got '${typeof licenseToken}'`);
        }
        if (IdentityTypesRequiringOfflineLicenseToken.includes(this.configOrParameters.identity.type)) {
            this.deferClose((dittoHandle) => {
                mapFFIErrors(() => {
                    tryVerifyLicense(dittoHandle.deref(), licenseToken);
                });
            });
        }
        else {
            const errorMessage = this.configOrParameters.isConfig
                ? `The connect mode '${this.config.connect.mode}' does not require an offline license token.`
                : `The identity type '${this.identity.type}' does not require an offline license token.`;
            Logger.error(errorMessage);
        }
    }
    /**
     * Returns the current transport configuration, frozen. If you want to modify
     * the transport config, make a {@link TransportConfig.copy | copy} first. Or
     * use the {@link updateTransportConfig | updateTransportConfig()}
     * convenience method. By default peer-to-peer transports (Bluetooth, WiFi,
     * and AWDL) are enabled if available in the current environment
     * (Web, Node, OS, etc.).
     *
     * @see {@link setTransportConfig | setTransportConfig()}
     * @see {@link updateTransportConfig | updateTransportConfig()}
     */
    get transportConfig() {
        return this.deferClose((dittoHandle) => {
            const configCBOR = dittoTransportConfig(dittoHandle.deref());
            const transportConfig = transportConfigFromDeserializable(CBOR.decode(configCBOR));
            return transportConfig.freeze();
        });
    }
    /**
     * Assigns a new transports configuration. By default peer-to-peer transports
     * (Bluetooth, WiFi, and AWDL) are enabled. You may use this method to alter
     * the configuration at any time, however sync will not begin until
     * {@link startSync | startSync()} is called.
     *
     * @see {@link transportConfig}
     * @see {@link updateTransportConfig | updateTransportConfig()}
     */
    setTransportConfig(transportConfig) {
        const transportConfigNew = transportConfig.copy().freeze();
        const configSerializeReady = transportConfigToSerializable(transportConfigNew);
        const configCBOR = CBOR.encode(configSerializeReady);
        this.deferClose((dittoHandle) => {
            dittoSetTransportConfig(dittoHandle.deref(), configCBOR);
        });
    }
    /**
     * Convenience method for updating the transport config. Creates a copy of the
     * current transport config, passes that copy to the `update` closure,
     * allowing it to mutate as needed, and sets that updated copy afterwards.
     */
    updateTransportConfig(update) {
        const transportConfig = this.transportConfig.copy();
        update(transportConfig);
        this.setTransportConfig(transportConfig);
        return this;
    }
    /**
     * Starts the network transports. Ditto will connect to other devices.
     *
     * By default Ditto will enable all peer-to-peer transport types. On **Node**,
     * this means BluetoothLE, WiFi/LAN, and AWDL. On the **Web**, only connecting
     * via  Websockets is supported. The default network configuration can be
     * modified with {@link updateTransportConfig | updateTransportConfig()}
     * or replaced with {@link setTransportConfig | setTransportConfig()}.
     *
     * Performance of initial sync when bootstrapping new peers can be improved by
     * calling {@link disableSyncWithV3 | disableSyncWithV3()} before
     * {@link startSync | startSync()}. Only call that method when all peers in
     * the mesh are known to be running Ditto v4 or higher.
     *
     * Ditto will prevent the process from exiting until sync is stopped (not
     * relevant when running in the browser).
     *
     * **NOTE**: the BluetoothLE transport on Linux is experimental, this
     * method panics if no BluetoothLE hardware is available. Therefore, contrary
     * to the above, the BluetoothLE transport is temporarily disabled by default
     * on Linux.
     *
     * @see {@link isSyncActive}
     * @see {@link stopSync | stopSync()}
     * @deprecated use {@link Sync.start | ditto.sync.start()} instead.
     */
    startSync() {
        this.deferClose((dittoHandle) => {
            if (IdentityTypesRequiringOfflineLicenseToken.includes(this.configOrParameters.identity.type) &&
                !this.isActivated) {
                throw new Error('Sync could not be started because Ditto has not yet been activated. This can be achieved with a successful call to `setOfflineOnlyLicenseToken`. If you need to obtain a license token then please visit https://portal.ditto.live.');
            }
            if (!this.isSyncActive)
                this.keepAlive.retain('sync');
            this._deviceName = dittoSetDeviceName(dittoHandle.deref(), this.deviceName);
            try {
                mapFFIErrors(() => dittoTryStartSync(dittoHandle.deref()));
            }
            catch (error) {
                // Don't keep the process alive if starting sync failed and sync is not
                // already active.
                if (!this.isSyncActive)
                    this.keepAlive.release('sync');
                throw error;
            }
        });
    }
    /**
     * Stops all network transports.
     *
     * You may continue to use the Ditto store locally but no data will sync to or
     * from other devices.
     *
     * @see {@link isSyncActive}
     * @see {@link startSync | startSync()}
     * @deprecated use {@link Sync.stop | ditto.sync.stop()} instead.
     */
    stopSync() {
        this.deferClose((dittoHandle) => {
            if (this.isSyncActive)
                this.keepAlive.release('sync');
            dittoStopSync(dittoHandle.deref());
        });
    }
    /**
     * Registers an observer for info about Ditto peers in range of this device.
     *
     * Ditto will prevent the process from exiting as long as there are active
     * peers observers (not relevant when running in the browser).
     *
     * @param callback called immediately with the current state of peers
     * in range and whenever that state changes. Then it will be invoked
     * repeatedly when Ditto devices come and go, or the active connections to
     * them change.
     *
     * @deprecated please use {@link Presence.observe | presence.observe()} instead.
     */
    observePeers(callback) {
        Logger.warning('`ditto.observePeers()` is deprecated, please use `ditto.presence.observe()` instead.');
        const token = this.presenceManager.addObserver(callback);
        return new Observer(this.presenceManager, token, {
            stopsWhenFinalized: true,
        });
    }
    /**
     * Register observer for changes of underlying transport conditions.
     *
     * Ditto will prevent the process from exiting as long as there are active
     * transport conditions observers (not relevant when running in the browser).
     *
     * @param callback called when underlying transport conditions change with
     * the changed `condition` and its `source`.
     */
    observeTransportConditions(callback) {
        const token = this.transportConditionsManager.addObserver(callback);
        return new Observer(this.transportConditionsManager, token, {
            stopsWhenFinalized: true,
        });
    }
    /**
     * Removes all sync metadata for remote peers that aren't currently connected.
     *
     * This method shouldn't usually be called. Manually running garbage
     * collection often will result in slower sync times. Ditto automatically runs
     * a garbage a collection process in the background at optimal times.
     *
     * Manually running garbage collection is typically only useful during testing
     * if large amounts of data are being generated. Alternatively, if an entire
     * data set is to be evicted and it's clear that maintaining this metadata
     * isn't necessary, then garbage collection could be run after evicting the
     * old data.
     *
     * This method does not have any effect when running Ditto in a browser.
     *
     * @deprecated this method is deprecated and will be removed in v5.0.0.
     */
    async runGarbageCollection() {
        return this.deferCloseAsync(async (dittoHandle) => {
            return dittoRunGarbageCollection(dittoHandle.deref());
        });
    }
    /**
     * Disable sync with peers running version 3 or lower of the Ditto SDK.
     *
     * Required for the execution of mutating DQL statements.
     *
     * This setting spreads to other peers on connection. Those peers will in turn
     * spread it further until all peers in the mesh take on the same setting.
     * This is irreversible and will persist across restarts of the Ditto
     * instance.
     *
     * Calling this method before starting sync is recommended whenever possible.
     * This improves performance of initial sync when this peer has never before
     * connected to a Ditto mesh for which sync with v3 peers is disabled.
     *
     * @throws {Error} when called in a React Native environment where sync with v3
     * is always disabled.
     */
    async disableSyncWithV3() {
        return this.deferCloseAsync(async (dittoHandle) => {
            await dittoDisableSyncWithV3(dittoHandle.deref());
        });
    }
    /**
     * Shut down Ditto and release all resources.
     *
     * Must be called before recreating a Ditto instance that uses the same
     * persistence directory.
     */
    async close() {
        if (this.isClosed)
            return;
        this._isClosed = true;
        this.stopSync();
        this.store.close();
        this.presence.close();
        this.auth.close();
        this.sync.close();
        await this.presenceManager.close();
        this.liveQueryManager.close();
        this.attachmentFetcherManager.close();
        this.transportConditionsManager.close();
        this.subscriptionManager.close();
        if (this.keepAlive.isActive) {
            throw new Error('Internal inconsistency, still kept alive after the Ditto object has been close()-ed. Active IDs: ' +
                this.keepAlive.currentIDs().join(', '));
        }
        // Await all pending operations before closing. Rejected promises are
        // ignored because they are handled at the original call site.
        do
            await Promise.allSettled(this.pendingOperations);
        while (
        // REFACTOR: in theory, we could end up in an endless loop here if for
        // some reason a resolved or rejected promise isn't removed from
        // `pendingOperations`. AFAICS, this is not possible atm due to the
        // way `deferClose` and `deferCloseAsync` is implemented. Would be
        // great to rework this and make it more solid if possible.
        this.pendingOperations.size > 0);
        this.deferCloseAllowed = false;
        await Bridge.ditto.close(this);
    }
    /**
     * The number of operations pending before the Ditto instance can be closed.
     *
     * For testing purposes only.
     * @internal */
    get numPendingOperations() {
        return this.pendingOperations.size;
    }
    /**
     * Makes sure that the closure is executed only if the Ditto instance hasn't
     * been closed yet.
     *
     * The closure is given a {@link Handle | handle} to the Ditto instance that
     * is valid while the closure is executing.
     *
     * @param closure the synchronous closure to execute.
     * @returns the result of the closure.
     * @throws if the Ditto instance was closed before calling this method.
     * @internal
     */
    deferClose(closure) {
        if (!this.deferCloseAllowed) {
            throw new Error(`Can't perform operation using a Ditto instance that has been closed.`);
        }
        const dittoHandle = Bridge.ditto.handleFor(this);
        return closure(dittoHandle);
    }
    /**
     * Makes sure that the closure is executed to completion before the Ditto
     * instance is closed.
     *
     * Any calls to {@link close | `Ditto.close()`} will wait until the closure
     * has completed before closing the Ditto instance.
     *
     * The closure is given a {@link Handle | handle} to the Ditto instance that
     * is valid while the closure is executing.
     *
     * @param closure the asynchronous closure to execute.
     * @returns the result of the closure.
     * @throws if the Ditto instance was closed before calling this method.
     * @internal
     */
    async deferCloseAsync(closure) {
        if (!this.deferCloseAllowed) {
            throw new Error(`Can't perform operation using a Ditto instance that has been closed.`);
        }
        const dittoHandle = Bridge.ditto.handleFor(this);
        const pendingOperation = closure(dittoHandle);
        this.pendingOperations.add(pendingOperation);
        let result;
        try {
            result = await pendingOperation;
        }
        finally {
            // Remove the promise from the set of pending operations even if it
            // rejected.
            this.pendingOperations.delete(pendingOperation);
        }
        return result;
    }
}
/**
 * Returns true if the current JS environment supports all required APIs.
 *
 * @param _globalObject optional global object to test this function without
 * having to mock `global`.
 * @returns `true` iff all required APIs exist on `global`.
 * @internal
 */
const checkAPIs = (_globalObject) => {
    const requiredBrowserAPIs = [
        'BigInt',
        'WeakRef',
        'FinalizationRegistry',
    ];
    const globalObject = _globalObject || globalThis || global || window;
    return requiredBrowserAPIs.every((apiName) => !!globalObject[apiName]);
};
/**
 * Disable deadlock timeout when Node.js is running with `--inspect` parameter.
 *
 * This heuristic is not failsafe as debugging mode can also be enabled by
 * sending a `SIGUSR1` signal to the process.
 *
 * @internal
 */
const disableDeadlockTimeoutWhenDebugging = () => {
    var _a, _b;
    {
        const hasInspector = process &&
            ((_a = process === null || process === void 0 ? void 0 : process.execArgv) === null || _a === void 0 ? void 0 : _a.some((arg) => arg.includes('--inspect') || arg.includes('--debug')));
        const hasLegacyDebugMode = (process && ((_b = process === null || process === void 0 ? void 0 : process.execArgv) === null || _b === void 0 ? void 0 : _b.some((arg) => arg.includes('--debug')))) ||
            // @ts-ignore - v8debug may be undefined
            typeof v8debug === 'object';
        if (hasInspector || hasLegacyDebugMode) {
            try {
                setDeadlockTimeout(0);
                Logger.warning('Detected Node running with inspector enabled, disabling deadlock timeout.');
            }
            catch (e) {
                Logger.error(`Detected Node running with inspector enabled but failed to disable deadlock timeout: ${e === null || e === void 0 ? void 0 : e.message}`);
            }
        }
    }
};

//
// Copyright © 2025 DittoLive Incorporated. All rights reserved.
//
/**
 * Represents a diff between two arrays.
 *
 * Create a diff between arrays of {@link QueryResultItem} using a {@link Differ}.
 */
class Diff {
    constructor(cborData) {
        const object = CBOR.decode(cborData);
        this.insertions = object.insertions;
        this.deletions = object.deletions;
        this.updates = object.updates;
        this.moves = object.moves.map(([from, to]) => ({ from, to }));
    }
}
/**
 * Calculates diffs between arrays of {@link QueryResultItem}.
 *
 * Use a {@link Differ} with a {@link StoreObserver} to get the diff between
 * subsequent query results delivered by the store observer.
 */
class Differ {
    /** Create a new differ. */
    constructor() {
        const ffiDiffer = differNew();
        return Bridge.differ.bridge(ffiDiffer, this);
    }
    /**
     * Calculate the diff of the provided items against the last set of items that
     * were passed to this differ.
     *
     * The returned {@link Diff} identifies changes from the old array of items
     * to the new array of items using indices into both arrays.
     *
     * Initially, the differ has no items, so the first call to this method will
     * always return a diff showing all items as insertions.
     *
     * The identity of items is determined by their `_id` field.
     */
    diff(items) {
        const pointers = items.map((item) => item.deref());
        const cborData = differDiff(this.deref(), pointers);
        return new Diff(cborData);
    }
    /** @internal */
    deref() {
        return Bridge.differ.handleFor(this).deref();
    }
}

//
// Copyright © 2023 DittoLive Incorporated. All rights reserved.
//
// Used to define a custom inspect function for Node.js that will be used when
// the object is inspected with console.log() or util.inspect().
const CUSTOM_INSPECT_SYMBOL = Symbol.for('nodejs.util.inspect.custom');
/**
 * Represents a single match of a DQL query, similar to a “row” in SQL terms.
 * It’s a reference type serving as a “cursor”, allowing for efficient access of
 * the underlying data in various formats.
 *
 * The {@link QueryResultItem.value | value } property is lazily materialized
 * and kept in memory until it goes out of scope. To reduce the memory
 * footprint, structure your code such that items can be processed as a stream,
 * i.e. one by one (or in batches) and
 * {@link QueryResultItem.dematerialize | dematerialize() } them right after
 * use.
 *
 * @template T The type of the item's {@link QueryResultItem.value | value }.
 */
class QueryResultItem {
    /**
     * Returns the content as a materialized object.
     *
     * The item's value is
     * {@link QueryResultItem.materialize | materialized() } on first access
     * and subsequently on each access after performing
     * {@link QueryResultItem.dematerialize | dematerialize() }. Once
     * materialized, the value is kept in memory until explicitly
     * {@link QueryResultItem.dematerialize | dematerialize() }-ed or the item
     * goes out of scope.
     *
     * Note: This property is very similar to {@link Document.value}.
     */
    get value() {
        this.materialize();
        if (this.materializedValue === undefined)
            throw new Error('Internal Error: Materialized value is undefined');
        return this.materializedValue;
    }
    /**
     * Returns `true` if value is currently held materialized in memory, otherwise
     * returns `false`.
     *
     * See {@link QueryResultItem.materialize | materialize()} and
     * {@link QueryResultItem.dematerialize | dematerialize()}.
     */
    get isMaterialized() {
        return this.materializedValue !== undefined;
    }
    /**
     * Loads the CBOR representation of the item's content, decodes it as an
     * object so it can be accessed via {@link QueryResultItem.value | value }.
     * Keeps the object in memory until
     * {@link QueryResultItem.dematerialize | dematerialize() } is called. No-op
     * if {@link QueryResultItem.value | value } is already materialized.
     */
    materialize() {
        if (!this.isMaterialized) {
            const cborValue = this.cborData();
            let materializedValue;
            try {
                materializedValue = CBOR.decode(cborValue);
            }
            catch (error) {
                throw new Error(`Internal inconsistency: CBOR decoding error while materializing result item: ${error.message}`);
            }
            if (materializedValue === undefined) {
                throw new Error('Internal inconsistency: Materialized value is undefined');
            }
            this.materializedValue = materializedValue;
        }
    }
    /**
     * Releases the materialized value from memory. No-op if item is not
     * materialized.
     */
    dematerialize() {
        this.materializedValue = undefined;
    }
    /**
     * Returns the content of the item as CBOR data.
     *
     * Important: The returned CBOR data is not cached, make sure to call this
     * method once and keep it for as long as needed.
     */
    cborData() {
        return queryResultItemCBOR(this.deref());
    }
    /**
     * Returns the content of the item as a JSON string.
     *
     * Important: The returned JSON string is not cached, make sure to call this
     * method once and keep it for as long as needed.
     */
    jsonString() {
        return queryResultItemJSON(this.deref());
    }
    // ----------------------------------------------------------- Internal ------
    /**
     * Defines a custom inspect representation for Node.js that will be used when
     * the object is inspected with console.log() or util.inspect().
     *
     * @internal
     */
    [CUSTOM_INSPECT_SYMBOL](_depth, _inspectOptions, inspect) {
        return customInspectRepresentation(this, inspect);
    }
    /** @internal */
    constructor() { }
    /** @internal */
    static fromJSON(jsonData) {
        const encodedData = new TextEncoder().encode(jsonData);
        return Bridge.queryResultItem.bridge(queryResultItemNew(encodedData));
    }
    /** @internal */
    deref() {
        return Bridge.queryResultItem.handleFor(this).deref();
    }
}

/**
 * Get a count of bridged objects binned by bridge type.
 *
 * Use this in testing to ensure that all objects are properly garbage collected at the end of tests.
 *
 * @returns an object with a key per bridge type, set to the count of registered
 * objects.
 */
function getBridgeLoad() {
    const countsByType = {};
    Bridge.all.map((bridgeWeakRef) => {
        const bridge = bridgeWeakRef.deref();
        if (!bridge)
            return null;
        if (bridge.count === 0)
            return null;
        countsByType[bridge.type.name] = bridge.count;
    });
    return countsByType;
}

//
// Copyright © 2021 DittoLive Incorporated. All rights reserved.
//
// NOTE: this is the last file to be rolled up. Typically, you'll use this to
// tie up certain associations that would otherwise lead to import cycles. The
// bridges are a good example of this: the type constructors for the bridged
// types need to be registered with it, but can't do it at creation time of the
// bridges, because anything that would require a certain bridge would
// immediately require the bridged type, oftentimes leading to an import cycle.
Bridge.attachment.registerType(Attachment);
Bridge.connectionRequest.registerType(ConnectionRequest);
Bridge.document.registerType(Document);
Bridge.queryResultItem.registerType(QueryResultItem);
Bridge.differ.registerType(Differ);
Bridge.transaction.registerType(Transaction);
Bridge.queryResult.registerType(QueryResult);
Bridge.mutableDocument.registerType(MutableDocument);
Bridge.ditto.registerType(Ditto);

exports.Attachment = Attachment;
exports.AttachmentFetcher = AttachmentFetcher;
exports.AttachmentToken = AttachmentToken;
exports.Authenticator = Authenticator;
exports.BasePendingCursorOperation = BasePendingCursorOperation;
exports.BasePendingIDSpecificOperation = BasePendingIDSpecificOperation;
exports.CBOR = CBOR;
exports.Collection = Collection;
exports.CollectionsEvent = CollectionsEvent;
exports.ConnectionRequest = ConnectionRequest;
exports.Counter = Counter;
exports.DEFAULT_IDENTITY = DEFAULT_IDENTITY;
exports.Diff = Diff;
exports.Differ = Differ;
exports.Ditto = Ditto;
exports.DittoConfig = DittoConfig;
exports.DittoError = DittoError;
exports.Document = Document;
exports.DocumentID = DocumentID;
exports.DocumentPath = DocumentPath;
exports.ERROR_CODES = ERROR_CODES;
exports.IdentityTypesRequiringOfflineLicenseToken = IdentityTypesRequiringOfflineLicenseToken;
exports.KeepAlive = KeepAlive;
exports.LiveQuery = LiveQuery;
exports.LiveQueryEventInitial = LiveQueryEventInitial;
exports.LiveQueryEventUpdate = LiveQueryEventUpdate;
exports.Logger = Logger;
exports.MutableCounter = MutableCounter;
exports.MutableDocument = MutableDocument;
exports.MutableDocumentPath = MutableDocumentPath;
exports.MutableRegister = MutableRegister;
exports.NotAvailableAuthenticator = NotAvailableAuthenticator;
exports.Observer = Observer;
exports.OnlineAuthenticator = OnlineAuthenticator;
exports.OnlineAuthenticatorV2 = OnlineAuthenticatorV2;
exports.PendingCollectionsOperation = PendingCollectionsOperation;
exports.PendingCursorOperation = PendingCursorOperation;
exports.PendingIDSpecificOperation = PendingIDSpecificOperation;
exports.Presence = Presence;
exports.QueryResult = QueryResult;
exports.QueryResultItem = QueryResultItem;
exports.Register = Register;
exports.SingleDocumentLiveQueryEvent = SingleDocumentLiveQueryEvent;
exports.SmallPeerInfo = SmallPeerInfo;
exports.Store = Store;
exports.StoreObserver = StoreObserver;
exports.Subscription = Subscription;
exports.Sync = Sync;
exports.SyncSubscription = SyncSubscription;
exports.Transaction = Transaction;
exports.TransactionInfo = TransactionInfo;
exports.TransportConfig = TransportConfig;
exports.UpdateResult = UpdateResult;
exports.UpdateResultsMap = UpdateResultsMap;
exports.WriteTransaction = WriteTransaction;
exports.WriteTransactionCollection = WriteTransactionCollection;
exports.WriteTransactionPendingCursorOperation = WriteTransactionPendingCursorOperation;
exports.WriteTransactionPendingIDSpecificOperation = WriteTransactionPendingIDSpecificOperation;
exports.addressToString = addressToString;
exports.checkAPIs = checkAPIs;
exports.disableDeadlockTimeoutWhenDebugging = disableDeadlockTimeoutWhenDebugging;
exports.getBridgeLoad = getBridgeLoad;
exports.init = init;
exports.makeIdentityConfig = makeIdentityConfig;
exports.mapFFIErrors = mapFFIErrors;
exports.mapFFIErrorsAsync = mapFFIErrorsAsync;
exports.transportConfigFromDeserializable = transportConfigFromDeserializable;
exports.transportConfigToSerializable = transportConfigToSerializable;
exports.validateAttachmentMetadata = validateAttachmentMetadata;
exports.validateDocumentIDCBOR = validateDocumentIDCBOR;
exports.validateDocumentIDValue = validateDocumentIDValue;
//# sourceMappingURL=ditto.cjs.pretty.js.map
